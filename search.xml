<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP/1.1深入学习（一）</title>
    <url>/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="HTTP解决了什么问题"><a href="#HTTP解决了什么问题" class="headerlink" title="HTTP解决了什么问题"></a>HTTP解决了什么问题</h2><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source_posts\HTTP-1-1深入学习\image01.png" alt="image-20220216145214793"></p>
<p>解决 WWW 信息交互必须面对的需求：</p>
<ul>
<li><p> 低门槛 </p>
</li>
<li><p>可扩展性：巨大的用户群体，超长的寿命 </p>
</li>
<li><p> 分布式系统下的 Hypermedia：大粒度数据的网络传输 </p>
</li>
<li><p>Internet 规模 </p>
<ul>
<li><p>无法控制的 scalability </p>
<ul>
<li><p>不可预测的负载、非法格式的数据、恶意消息 </p>
</li>
<li><p>客户端不能保持所有服务器信息，服务器不能保持多个请求间的状态信息</p>
<p>独立的组件部署：新老组件并存</p>
<p>向前兼容：自 1993 年起 HTTP0.9\1.0（1996）已经被广泛使用</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source_posts\HTTP-1-1深入学习\image02.png" alt="image-20220216145500667"></p>
<h2 id="浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式"><a href="#浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式" class="headerlink" title="浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式"></a>浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式</h2><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source\_posts\HTTP-1-1深入学习\image03.png" alt="image-20220216143022772" style="zoom:150%;">

<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143059824.png" alt="image-20220216143059824"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143217688.png" alt="image-20220216143217688"></p>
<p>一种无状态的、应用层的、以<strong>请求/应答方式</strong>运行的协议，使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。</p>
<h3 id="HTTP的协议格式"><a href="#HTTP的协议格式" class="headerlink" title="HTTP的协议格式"></a>HTTP的协议格式</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143444135.png" alt="image-20220216143444135"></p>
<h4 id="ABNF-扩充巴科斯-瑙尔范式-操作符"><a href="#ABNF-扩充巴科斯-瑙尔范式-操作符" class="headerlink" title="ABNF(扩充巴科斯-瑙尔范式)操作符"></a>ABNF(扩充巴科斯-瑙尔范式)操作符</h4><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143600821.png" alt="image-20220216143600821"></p>
<p><strong><em>ABNF的核心规则</em></strong></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143608965.png" alt="image-20220216143608965"></p>
<blockquote>
<p>基于ABNF描述的HTTP协议格式 + 具体实例</p>
</blockquote>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143758587.png" alt="image-20220216143758587"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143824981.png" alt="image-20220216143824981"></p>
<h2 id="网络分层：OSI模型与TCP-IP模型"><a href="#网络分层：OSI模型与TCP-IP模型" class="headerlink" title="网络分层：OSI模型与TCP/IP模型"></a>网络分层：OSI模型与TCP/IP模型</h2><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144746312.png" alt="image-20220216144746312"></p>
<h3 id="OSI模型与TCP模型的对照"><a href="#OSI模型与TCP模型的对照" class="headerlink" title="OSI模型与TCP模型的对照"></a>OSI模型与TCP模型的对照</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144826027.png" alt="image-20220216144826027"></p>
<h3 id="在不同层之间的报文头部封装"><a href="#在不同层之间的报文头部封装" class="headerlink" title="在不同层之间的报文头部封装"></a>在不同层之间的报文头部封装</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144956500.png" alt="image-20220216144956500"></p>
<p>注意一下在图中表明的各层的报文分别叫什么名字。</p>
<h2 id="评估Web架构的关键属性"><a href="#评估Web架构的关键属性" class="headerlink" title="评估Web架构的关键属性"></a>评估Web架构的关键属性</h2><p>HTTP 协议应当在以下属性中取得可接受的均衡：</p>
<ul>
<li><strong>性能</strong> Performance：影响高可用的关键因素 </li>
<li><strong>可伸缩性</strong> Scalability：支持部署可以互相交互的大量组件 </li>
<li><strong>简单性</strong> Simplicity：易理解、易实现、易验证 </li>
<li><strong>可见性</strong> Visiable：对两个组件间的交互进行监视或者仲裁的能力。如缓存、分层设计等</li>
<li><strong>可移植性</strong> Portability：在不同的环境下运行的能力 </li>
<li><strong>可靠性</strong> Reliability：出现部分故障时，对整体影响的程度 </li>
<li><strong>可修改性</strong> Modifiability：对系统作出修改的难易程度，由可进化性、可定制性、可扩展性、可配置性、可重用性构成</li>
</ul>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154311688.png" alt="image-20220216154311688"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154333582.png" alt="image-20220216154333582"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154407111.png" alt="image-20220216154407111"></p>
<h2 id="从五种架构风格推导出HTTP的REST架构"><a href="#从五种架构风格推导出HTTP的REST架构" class="headerlink" title="从五种架构风格推导出HTTP的REST架构"></a>从五种架构风格推导出HTTP的REST架构</h2><p> <img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154624220.png" alt="image-20220216154624220"></p>
<h3 id="数据流风格-Data-flow-Styles"><a href="#数据流风格-Data-flow-Styles" class="headerlink" title="数据流风格 Data-flow Styles"></a>数据流风格 Data-flow Styles</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154806375.png" alt="image-20220216154806375"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154827521.png" alt="image-20220216154827521"></p>
<h3 id="复制风格"><a href="#复制风格" class="headerlink" title="复制风格"></a>复制风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155000320.png" alt="image-20220216155000320"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155007623.png" alt="image-20220216155007623"></p>
<h3 id="分层风格"><a href="#分层风格" class="headerlink" title="分层风格"></a>分层风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155144846.png" alt="image-20220216155144846"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155211840.png" alt="image-20220216155211840"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155244132.png" alt="image-20220216155244132"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155251415.png" alt="image-20220216155251415"></p>
<h3 id="移动代码风格-Mobile-Code-Styles"><a href="#移动代码风格-Mobile-Code-Styles" class="headerlink" title="移动代码风格 Mobile Code Styles"></a>移动代码风格 Mobile Code Styles</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155401997.png" alt="image-20220216155401997"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155440972.png" alt="image-20220216155440972"></p>
<h3 id="点对点风格"><a href="#点对点风格" class="headerlink" title="点对点风格"></a>点对点风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155509897.png" alt="image-20220216155509897"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155556884.png" alt="image-20220216155556884"></p>
<h3 id="不同风格之间的演化"><a href="#不同风格之间的演化" class="headerlink" title="不同风格之间的演化"></a>不同风格之间的演化</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155625246.png" alt="image-20220216155625246"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公--Word</title>
    <url>/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/</url>
    <content><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Python实现高效自动化Word办公：如何批量合并多个文档-python-docx库）"><a href="#Python实现高效自动化Word办公：如何批量合并多个文档-python-docx库）" class="headerlink" title="Python实现高效自动化Word办公：如何批量合并多个文档(python-docx库）"></a>Python实现高效自动化Word办公：如何批量合并多个文档(python-docx库）</h1><p>在Word文件中，不但有文字内容，还有加粗、红色等格式，而且这些特殊的格式和文字内容是混合在一起的，但如果用Python来读取Word文件，这段文字会被分为纯文字、段落、字体、字号以及表格 等更具体的部分，而且每一个部分都对应着<strong>Python的变量和函数。</strong></p>
<p>用Python读取文件时，你需要记住很多个Python变量和函数。当然了，针对这一点， 你也不用担心，这些变量和函数在Python的Word扩展库<a href="https://python-docx.readthedocs.io/en/latest/#"><strong><em>官方文档</em></strong></a>可以查看。所以如果你需 要某个功能，但是不知道应该用什么变量和函数名称时，可以在官方文档中找到它的名字和 描述信息。</p>
<h3 id="用Python自动合并两个Word文件"><a href="#用Python自动合并两个Word文件" class="headerlink" title="用Python自动合并两个Word文件"></a>用Python自动合并两个Word文件</h3><ul>
<li><p>文件一（内容包含字体、字号、颜色等额外信息）：</p>
 <img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/image.png" class>
</li>
<li><p>文件二（内容文字出现在表格中）:</p>
 <img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/image01.png" class>

</li>
</ul>
<blockquote>
<p>第一个文件中，字体使用了黑体和宋体字，此外还有红色字体和加粗等格式。现在我需要 只提取其中的文字内容，不带任何格式。 </p>
<p>第二个文件中，文字被放在了一张表格里。现在我需要用Python把表格中的文字提取出 来，合并成一个新的文件。</p>
</blockquote>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mrge_without_format</span>(<span class="params">docfiles:<span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    只获取内容进行合并</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#遍历文件</span></span><br><span class="line">    <span class="keyword">for</span> docx_file <span class="keyword">in</span> <span class="built_in">sorted</span>(docfiles):</span><br><span class="line">        another_doc = Document(docx_file)</span><br><span class="line">        <span class="comment"># 获取每个文件的的所有段落</span></span><br><span class="line">        paras = another_doc.paragraphs</span><br><span class="line">        <span class="keyword">for</span> para <span class="keyword">in</span> paras:</span><br><span class="line">            <span class="comment"># 为新的word文件创建一个新段落</span></span><br><span class="line">            newpar = doc.add_paragraph(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="comment">#将提取的内容写入新的文本段落中</span></span><br><span class="line">            newpar.add_run(para.text)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#所有文件合并完成后在指定路径中保存</span></span><br><span class="line">        doc.save(Path(word_files_path,<span class="string">&#x27;new.docx&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用函数</span></span><br><span class="line">    merge-mrge_without_format(files)</span><br></pre></td></tr></table></figure>


<h3 id="用Python合并Word和其他类型的文件"><a href="#用Python合并Word和其他类型的文件" class="headerlink" title="用Python合并Word和其他类型的文件"></a>用Python合并Word和其他类型的文件</h3><p>相较于其他文件，Word文件支持的格式丰富程度远远高于Txt文件等，所以当这两种格式丰富程度不一致的文件进行合并时，要么向下兼容，去掉Txt不支持的格式；要 么向上兼容，对Txt进行格式再调整。否则容易出现合并之后仍需要手动调整格式的问题，影 响工作效率。</p>
<h4 id="将纯文本和Word文件合并"><a href="#将纯文本和Word文件合并" class="headerlink" title="将纯文本和Word文件合并"></a>将纯文本和Word文件合并</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> RGBColor</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># word文件所在路径</span></span><br><span class="line">word_files_path = <span class="string">&#x27;D:/Python自动化办公/Day02/word样例文件&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 取得该目录下所有的docx格式文件</span></span><br><span class="line"><span class="comment"># p = Path(word_files_path)</span></span><br><span class="line"></span><br><span class="line">my_content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">野老篱边江岸回，柴门不正逐江开。</span></span><br><span class="line"><span class="string">渔人网集澄潭下，贾客船随返照来。</span></span><br><span class="line"><span class="string">长路关心悲剑阁，片云何意傍琴台？</span></span><br><span class="line"><span class="string">王师未报收东郡，城阙秋生画角哀。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_content_mode1</span>(<span class="params">content</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    增加内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(doc)</span><br><span class="line">    para = doc.add_paragraph().add_run(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置字体格式</span></span><br><span class="line">    para.font.name = <span class="string">&#x27;仿宋&#x27;</span></span><br><span class="line">    <span class="comment"># 设置下划线</span></span><br><span class="line">    para.font.underline = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 设置颜色</span></span><br><span class="line">    para.font.color.rgb = RGBColor(<span class="number">255</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">    <span class="comment"># 其他设置参考官方文档</span></span><br><span class="line">    <span class="comment"># https://python-docx.readthedocs.io/en/latest/api/text.html#run-objects</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line">add_content_mode1(my_content)</span><br><span class="line">doc.save(Path(word_files_path, <span class="string">&#x27;new2.docx&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="将图片和Word文件合并"><a href="#将图片和Word文件合并" class="headerlink" title="将图片和Word文件合并"></a>将图片和Word文件合并</h4><p>我们经常见到的图片格式就有.jpg、.png、.gif等，由于这些格式应用范围广，格式 没有被商业软件加密，所以python-docx库的add_picture函数就能实现把图片插入Word的 功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> shared</span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line"><span class="comment"># 按英寸设置宽度，添加图片</span></span><br><span class="line">doc_add_picture(<span class="string">&#x27;test.jpg&#x27;</span>,width=shared.Inches(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>


<h4 id="将Execl和Word文件合并"><a href="#将Execl和Word文件合并" class="headerlink" title="将Execl和Word文件合并"></a>将Execl和Word文件合并</h4><ul>
<li><p>使用Python制作邀请函</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">today=datetime.date.today().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户信息文件</span></span><br><span class="line">customer = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/客户信息.xlsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邀请函模版</span></span><br><span class="line">invitation = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/邀请函模版.docx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邀请函路径</span></span><br><span class="line">invitation_path = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换内容</span></span><br><span class="line">replace_content = &#123;</span><br><span class="line">    <span class="string">&#x27;&lt;姓名&gt;&#x27;</span> : <span class="string">&#x27;no_name&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;性别&gt;&#x27;</span> : <span class="string">&#x27;m_f&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;今天日期&gt;&#x27;</span> : today</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generat_invitation</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    生成邀请函文件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    doc = Document(invitation)</span><br><span class="line">    <span class="comment"># 取出每一段</span></span><br><span class="line">    <span class="keyword">for</span> para <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> replace_content.items():</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> para.text:</span><br><span class="line">                <span class="comment"># 逐个关键字进行替换</span></span><br><span class="line">                para.text = para.text.replace(key, value)</span><br><span class="line"></span><br><span class="line">    file_name = PurePath(invitation_path).with_name(replace_content[<span class="string">&#x27;&lt;姓名&gt;&#x27;</span>]).with_suffix(<span class="string">&#x27;.docx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    doc.save(file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_customer</span>(<span class="params">customer_file: Path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    获取邀请函信息</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 从第一个sheet中取出客户信息</span></span><br><span class="line">    data = xlrd.open_workbook(customer_file)</span><br><span class="line">    table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得客户数量</span></span><br><span class="line">    customer_number = table.nrows</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, customer_number):</span><br><span class="line">        content = table.row_values(rowx=line, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">        replace_content[<span class="string">&#x27;&lt;姓名&gt;&#x27;</span>] = content[<span class="number">0</span>]</span><br><span class="line">        replace_content[<span class="string">&#x27;&lt;性别&gt;&#x27;</span>] = content[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(replace_content)</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;&lt;姓名&gt;&#x27;: &#x27;韩梅梅&#x27;, &#x27;&lt;性别&gt;&#x27;: &#x27;女士&#x27;, &#x27;&lt;今天日期&gt;&#x27;: &#x27;2021-01-01&#x27;&#125;</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;&lt;姓名&gt;&#x27;: &#x27;李雷&#x27;, &#x27;&lt;性别&gt;&#x27;: &#x27;先生&#x27;, &#x27;&lt;今天日期&gt;&#x27;: &#x27;2021-01-01&#x27;&#125;</span></span><br><span class="line">        generat_invitation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_customer(customer)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对不同类型文件进行合并时，要考虑不同的问题</p>
<blockquote>
<ol>
<li>对于支持格式丰富不同的文件时要考虑格式的兼容性；</li>
<li>  对于图片、音乐、视频和Word合并时要考虑是否是受到word支持的通用格式；</li>
<li>  对于像Excel格式于Word合并时能实现更复杂的功能，代码的复杂程度也会随之提高，一 般需要先分析功能，再进行代码编写。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-图片识别</title>
    <url>/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="使用Python实现高效自动化图片组在线-离线识别（转文字）"><a href="#使用Python实现高效自动化图片组在线-离线识别（转文字）" class="headerlink" title="使用Python实现高效自动化图片组在线/离线识别（转文字）"></a>使用Python实现高效自动化图片组在线/离线识别（转文字）</h1><h2 id="图片识别转文字的两种方式："><a href="#图片识别转文字的两种方式：" class="headerlink" title="图片识别转文字的两种方式："></a>图片识别转文字的两种方式：</h2><blockquote>
<p>在线识别</p>
<p>优点： 在线识别在初次进行文字识别的时候，准确率非常高。比如对聊天截图中的识别准确率就高达99%。因为在线识别使用了人工智能领域的深度学习算法和文字识别相结合的技术，能够把图片转换成文字后，还能在语义上把相近的字进行二次纠正。 比如说，被识别的内容包含英文单词“Hello”，一旦它的字母“o”被识别成数字“0”，在 线识别软件就会根据上下文语境把这类错误纠正回来，而这种二次纠正的功能在离线识别软 件中是没有的。</p>
<p>缺点：</p>
<ol>
<li>识别文字的过程需要在公有云的服务器上完成。也 就是说需要通过互联网把图片上传到服务器，那么一旦图片过大，或者图片数量比较多，就会导致上传时间过长。对于一些大批量文字识别场景/实时性要求很高的场景，在线识别不能满足要求</li>
<li>图片需要经过互联网传输，识别以后的图片该怎么保存，怎么销毁，是不是会被其他 人得到，这些都是安全风险。总之，信息泄露的风险比较大。所以像公司的合同、财务资料 等涉密程度比较高的扫描件，很少使用在线识别。</li>
</ol>
</blockquote>
<blockquote>
<p>离线识别</p>
<p>这种方式在识别过程中不需要连接网络，节省了在线传输图片的时间，适合那些对实时性要 求比较高或网络信号比较差的场景。</p>
<p>离线识别方式的问题就在于，初次识别文字的准确率比较低，识别完之后必须要经过人 工二次纠正才行。所以在前期人工校对，花费的时间相对来说会比较长。</p>
</blockquote>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image01.png" class>

<h2 id="在线识别"><a href="#在线识别" class="headerlink" title="在线识别"></a>在线识别</h2><p>在线文字识别方式，识别的主要功能的需要放在公有云的服务器中才能实现，所以在代码实 现中就要考虑用户验证和图片加密传输问题。</p>
<p>用户验证能确保识别的结果交还给你本人，图片加密传输能确保图片上的信息不会被其他人 窃取到。这些功能，各个公有云的AI产品都考虑得非常周全，一般会提供给用户一个扩展 库。你要做的，就是安装这些扩展库。</p>
<p><strong>以百度Ai图片转文字识别产品为例</strong></p>
<blockquote>
<p>pip install baidu-aip</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line">APP_ID = <span class="string">&#x27;&#x27;</span></span><br><span class="line">API_Key = <span class="string">&#x27;&#x27;</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID,API_Key,SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line">image = get_file_content(<span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用文字识别，图片参数为本地图片</span></span><br><span class="line">result = client.basicGeneral(image)</span><br><span class="line">print(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image02.png" class>

<p>当把这三个变量传入AipOcr函数，使用AipOcr函数通过互联网交互后，就可以用来识别用户 是不是被授权使用相应的产品，之后就可以把图片加密发送到AI产品的服务器上了。</p>
<h2 id="离线识别（pytesseract）"><a href="#离线识别（pytesseract）" class="headerlink" title="离线识别（pytesseract）"></a>离线识别（pytesseract）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开图片</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为灰度图片</span></span><br><span class="line">imgry = image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line"><span class="comment"># 二值化，采用阈值分割算法，threhold为分割点，根据图片质量调节</span></span><br><span class="line">threhold = <span class="number">150</span></span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">if</span> j&lt;threhold:</span><br><span class="line">        table.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">temp = imgry.point(table,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">temp = imgry.point(table,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OCR识别，调用pytesseract库，lang指定中文，--psm 6表示按行识别，有助于提升准确率</span></span><br><span class="line">text = pytesseract.image_to_string(temp,lang=<span class="string">&quot;chi_sim+eng&quot;</span>,config=<span class="string">&#x27;--psm 6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印识别结果</span></span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>遇到问题</strong></p>
<p>TesseractNotFoundError: tesseract is not installed or it’s not in your PATH. See README file for more information.</p>
<p><strong>原因</strong>：</p>
<p>pytesseract是依赖c++编写的tesseract工具才能正常工作的，需要先安装teseract</p>
<p><strong>解决</strong>：</p>
<p><a href="https://blog.csdn.net/wang_hugh/article/details/80760940">https://blog.csdn.net/wang_hugh/article/details/80760940</a></p>
</blockquote>
<p>对图片文字离线识别的一般过程如下：</p>
<ul>
<li>图像输入</li>
<li>前期处理，比如二值化，图像降噪，倾斜纠正</li>
<li>文字检测，比如版面分析，字符分割</li>
<li>文本识别，比如字符识别，后期纠正（<strong>影响准确率最大</strong>）</li>
<li>输出文本</li>
</ul>
<p>离线识别训练样本较小，正确率相较于在线识别是不高的。具体的解决方案有以下两种</p>
<blockquote>
<p>通过人工纠正，形成新的训练模型（不断增加算法模型中标本的数量）</p>
</blockquote>
<p>像身份证识别、票据识别、聊天截图等大部分文字识别场景，这些待识别图片采用了印刷体，每个字的间隔都是固定的，所以我们要想提升准确率，通常的做法是对每个字都进行人 工纠错。</p>
<p>所以整个过程你可以理解成三个步骤： 第一步，人工观察； 第二步，对比原始图像； 第三步，把错误的文字手工纠正为正确的汉字。 比如截图中的“某”字，多次识别错误，当我们人工把这些文字改为正确的“某”字之后， 就可以生成一个训练文件，再把训练文件和文字识别的算法合并成新的识别模型。等下次再 识别发票的时候，就可以采用新的模型进行识别。所以再次出  现“某”字，就可以正确识别了。</p>
<p><strong>这种文字标注对于单一场景非常有效，比如名片、火车票、飞机票、发票、车牌的识别场 景，经过手工标注，不断增加样本数量之后，能够让正确率呈对数级别增加。</strong></p>
<blockquote>
<p>使用在线识别软件来优化离线识别软件</p>
</blockquote>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image03.png" class>



<h2 id="识别成功后的文字处理工作"><a href="#识别成功后的文字处理工作" class="headerlink" title="识别成功后的文字处理工作"></a>识别成功后的文字处理工作</h2><p>下图为在线识别的结果</p>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image04.png" class>

<p>为了能够提取文本内容，去掉记录分段信息的”word”和 “{ }”，需要对这段文字再加工处理。</p>
<p>仔细观察的话，就会发现这段文字是有一定规律的，它的写法就是Python的基本数据类型“字典”，字典类型会强调一对或多对数据之间的映射关系。为了将识别的文字结果进行保存，我们还会使用另一个基本数据类型“列表”，一般用来表示多段文字的并列关系， 为了提取文本内容，我接下来把字典转换成列表就可以实现内容的提取了。 从字典到列表转换的功能怎么实现呢？首先来看一下两种数据类型的定义</p>
<p><img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220131094327030.png" alt="image-20220131094327030"></p>
<p>观察这两个数据类型不难发现，把字典的VALUE存放到列表里就能实现内容的提取了，如果 字典里有多个值，可以使用for循环进行遍历，然后批量提取。对于识别的结果，我们可以采 用一段代码进行从字典到列表的转换。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result[<span class="string">&#x27;words_result&#x27;</span>]:</span><br><span class="line">	info.append(i[<span class="string">&#x27;words&#x27;</span>])</span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure>
<p>处理好的内容如下</p>


]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-跨文件字数统计</title>
    <url>/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="使用Python实现快速读写文件，跨文件字数统计"><a href="#使用Python实现快速读写文件，跨文件字数统计" class="headerlink" title="使用Python实现快速读写文件，跨文件字数统计"></a>使用Python实现快速读写文件，跨文件字数统计</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">使用Python来批量统计多个文件的字数和标点符号</span><br></pre></td></tr></table></figure>
<h2 id="实现单个文件字数统计"><a href="#实现单个文件字数统计" class="headerlink" title="实现单个文件字数统计"></a>实现单个文件字数统计</h2><p>统计单个文件的字数，需要用到Python的文件读写函数和变量这两个功能。Python的读写函 数是对文件内容的读取操作，变量呢，用来存储统计好的文件字数。</p>
<ul>
<li>先把要统计的文件读入内存；</li>
<li>再对读入到内存的字数数量进行统计，并用变量保存；</li>
<li>最后是将结果写入统计字数的专用文件中。</li>
</ul>
<h3 id="将文件内容读取到内存中"><a href="#将文件内容读取到内存中" class="headerlink" title="将文件内容读取到内存中"></a>将文件内容读取到内存中</h3><p>Python实现读取文件内容到内存的函数有三个，这三个函数原理相同，但是读取的内容多少有些不同，分别为：</p>
<img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209190932306.png" alt="image-20220209190932306" style="zoom:50%;">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line">file_name = <span class="string">&quot;./e.txt&quot;</span></span><br><span class="line"><span class="comment"># 取得脚本所在目录</span></span><br><span class="line">current_path = pathlib.PurePath(__file__).parent</span><br><span class="line"></span><br><span class="line"><span class="comment">#和脚本同目录下的要打开文件绝对路径</span></span><br><span class="line">file = current_path.joinpath(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    content = f.read()</span><br><span class="line">    words = content.rstrip()</span><br><span class="line">    number = <span class="built_in">len</span>(words)</span><br><span class="line">    print(number)</span><br></pre></td></tr></table></figure>
<p>open()函数参数说明：</p>
<p>第一个参数file变量的值是要操作的文件路径和文件名称，你需要正 确指定它所在的路径和文件名称。第二个参数encoding变量的值指定了以哪种字符编码打开文件，错误的字符编码会导致内容读取异常，文字内容显示为“乱码”。</p>
<h4 id="获取完整路径"><a href="#获取完整路径" class="headerlink" title="获取完整路径"></a>获取完整路径</h4><ul>
<li>在代码中使用pathlib库的PurePath()函数，把当前Python脚本的路径转化为标准的 pathlib格式。</li>
<li>通过parent属性去掉脚本的文件名，取得当前脚本所在的路径。</li>
<li>再通过joinpath()函数把脚本所在的路径和e.txt文件名进行拼接，得到e.txt的完整路径。</li>
</ul>
<p>这种取得脚本同目录下的其他文件完整路径的用法，要比直接指定文件完整路径用法更灵活。</p>
<blockquote>
<p>__file__变量比较特殊，它是在Python中预先定义好的一个变量，默认情况下它的值会被 Python自动设置为当前脚本的完整路径名称。有了它，我就可以通过Python脚本的路径取得 e.txt的完整路径了。</p>
</blockquote>
<h4 id="设置字符编码"><a href="#设置字符编码" class="headerlink" title="设置字符编码"></a>设置字符编码</h4><p>第二个参数的作用是设置open()函数使用何种字符编码打开文件。</p>
<h4 id="函数传参调用"><a href="#函数传参调用" class="headerlink" title="函数传参调用"></a>函数传参调用</h4><p>为什们指定这个参数的时候，要特意写出变量名称encoding呢？</p>
<p>在函数定义的时候我们可以为函数指定一个或多个参数，如果使用了多个参数，你在调用函 数的时候需要按顺序依次传入每一个参数。但是如果你想要使用某个参数默认值或不想按照 顺序传入参数时怎么办呢？函数调用时，还可以根据参数的关键字来指定为函数传入哪些参 数。比如说open()函数的参数有7个，</p>
<p><img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209193920724.png" alt="image-20220209193920724"></p>
<p>在open()函数的定义中，encoding参数是open()函数的第4个参数。如果我们只需要第1个和 第4个参数，其他参数需要保持默认时，就可以使用如下格式调用open()函数：</p>
<p><img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209193956499.png" alt="image-20220209193956499"></p>
<p>在代码中，调用open()函数时，由于file参数是open()函数的第一个参数，因此可以不用指定 参数的关键字。encoding参数并非open()函数定义的第二个参数，而是第四个参数，所以需 要指定它的参数名称为encoding，根据open()函数的定义，encoding=”utf-8”会作为 open()函数的第四个参数使用。这种使用关键字作为函数的参数的方式，也被称作<strong>函数的关键字传参方式</strong>。</p>
<h3 id="with使用"><a href="#with使用" class="headerlink" title="with使用"></a>with使用</h3><p>with关键字下面的代码是缩进形式，和with关键字形成了一个语句块</p>
<p>在with语句 块结束之后，不必手动调用close()函数关闭文件，Python会自动将文件关闭。因此，你会看到我在程序中调用了open()函数打开文件，但是没有调用关闭文件的close()函数。</p>
<p>总的来说，相对于手动调用close()函数来关闭文件，使用with函数减少了打开过多文件造成系统资源浪费和数据丢失的风险。</p>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>正确使用了open()函数的两个参数以后，会返回一个表示文件的对象f, 只有设置了正确 的文件路径、文件名称和字符编码，才能继续进行文件读取操作。文件的读取操作使用的是 read()函数，read()函数会根据文件的对象f，按照open()函数定义好的打开方式进行逐个字 的读取操作。Python对文件的其他操作，全都需要通过文件操作函数调用对象f来完成。</p>
<h4 id="统计文件的字数"><a href="#统计文件的字数" class="headerlink" title="统计文件的字数"></a>统计文件的字数</h4><p>Python的内置函数**len()**来实现</p>
<p>len()函数在Python中最初设计的功能就是统计字符串的长度，即字符串中有多少字符。利用len()函数可以对字符串数据类型进行操作的特性，将文件一次性读入内存，放入字符串数据类型中。我在统计字数之前还增加了一个rstrip()函数，它会自动剔除出现在文件末尾的空行、空格，让你统计的结果更精确。</p>
<p>在进行文件字数统计的时候，需要注意，在代码中使用了read()函数实现了对文件内容的一<br>次性读取到内存的功能。如果你的文件较大，我建议你使用readline()函数按行读取，并逐行<br>统计字数，否则容易出现内存不足的问题。</p>
<h4 id="将统计结果写入文件"><a href="#将统计结果写入文件" class="headerlink" title="将统计结果写入文件"></a>将统计结果写入文件</h4><p>将统计结果写入文件，可以对<strong>open()函数</strong>打开文件方式进行简单的修改，就可以实现文件写入功能了，写入文件的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;total.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encodong=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	 f.write(<span class="string">&quot;15个字符&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>open()函数的第二个参数表示文件的打开方式，它默认值是“r”，代表了文件以读取方式进行打开。这时对象f只能进行文件读取操作，我们需要将第二个参数指定为”w”，就可以使用wirte()函数对文件进行写入操作了。而write()函数的第一个参数就是即将要写入文件的内容。</p>
<h3 id="怎么统计多个文件的次数"><a href="#怎么统计多个文件的次数" class="headerlink" title="怎么统计多个文件的次数"></a>怎么统计多个文件的次数</h3><p>对多个文件的字数统计，就可以使用for循环来实现批量读取多个文件的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Path(src_path)</span><br><span class="line">files = [x <span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath(x).match(<span class="string">&#x27;*.txt&#x27;</span>)]</span><br><span class="line"><span class="keyword">for</span> files <span class="keyword">in</span> files:</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(file,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">words = content.rstrip()</span><br><span class="line">    	number = <span class="built_in">len</span>(words)</span><br></pre></td></tr></table></figure>
<p>数字类型是一种非常适合进行整数、浮点数的转换和算数几何计算最常用的类型。在单文件字数统计的场景，用来储存每个文件的字数是最合适的类型。如果把场景扩展到统计多个文件的字数，使用一个数字类型的变量是不够的，你需要在循环中再增加一个新的数字类型的变量，对多个文件的统计结果进行依次累加就可以了。</p>
]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-长图拼接</title>
    <url>/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="Python自动化办公–长图拼接"><a href="#Python自动化办公–长图拼接" class="headerlink" title="Python自动化办公–长图拼接"></a>Python自动化办公–长图拼接</h1><h2 id="Python调用外部程序的原理"><a href="#Python调用外部程序的原理" class="headerlink" title="Python调用外部程序的原理"></a>Python调用外部程序的原理</h2><blockquote>
<p>导入函数库[对应的Python外部功能已经开发为库]</p>
</blockquote>
<p>例如：Python语言默认是不支持Excel的。那么通过导入函数库xlrd，Python就可以获得对Excel的操作能力。</p>
<blockquote>
<p>需要操作Python语言之外的功能，但这个功能没有人将它开发成函数库， 那如果我们想要使用这些功能，使用的途径就是调用外部命令了，而调用外部命令就需要 Python内部函数库的subprocess模块来实现。</p>
</blockquote>
<ul>
<li><p>实现机制</p>
<p>它的run()函数的参数可以指定一个可以运行的程序的路径，而 Python会根据这个路径来运行可执行文件，然后再根据运行结果，以及Python的逻辑判断去进行后续的自动化处理工作。</p>
</li>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> run,Popen,PIPE</span><br><span class="line"></span><br><span class="line">cmd = [<span class="string">&quot;dir&quot;</span>]</span><br><span class="line">returncode = run(cmd)</span><br><span class="line"><span class="comment"># returncode是dir命令的退出状态码，通常来说, 一个为 0 的退出码表示进程运行正常</span></span><br><span class="line">print(returncode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Popen(cmd,shell=<span class="literal">True</span>,stdout=PIPE,stderr=PIPE,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fs:</span><br><span class="line">    fs.wait(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    files = fs.communicate()[<span class="number">0</span>]</span><br><span class="line">print(files)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码中最核心的函数是run()函数和Popen类。subprocess模块就是通过这两个函数实现 的外部程序调用。</p>
</li>
</ul>
<img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image01.png" class>

<p>和import方式导入函数库的区别是，这种形式可以让你直接使用模块中的类和方法。 如果你使用 “import subprocess”方式导入subprocess库的话，在调用run()函数的时候， 就需要用 “库.函数”的形式在Python中使用库当中的函数，即“subprocess.run()”。在你 多次调用run()函数时，代码会较长，那么使用“from import”方式导入，就可以在当前代 码文件中直接使用run()函数，为代码的阅读带来更好的体验。</p>
 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image02.png" class>

 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image03.png" class>

<p>以上就是用subprocess库实现Python调用可执行程序的方法。Python之所以被我们称作最佳的“<strong>胶水语言</strong>”，就是因为它能轻易“粘合”可执行程序。利用Python灵活的逻辑判 断、循环语法可以实现程序的批量执行和流程管理。</p>
<h2 id="长图拼接"><a href="#长图拼接" class="headerlink" title="长图拼接"></a>长图拼接</h2><p>拼接图片的功能Python本身是不具备的，因此就需要引入外部命令来实现图片拼接功能。</p>
<p>以MacOS平台图像处理软件ImageMagick，它能对图片进行编辑、合并、切割、旋转等90多种操作， ImageMagick软件实现图片拼接的命令格式是这样的：</p>
 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image04.png" class>

<p>在这段命令格式中，composite命令的参数包含了多个图片文件，每个图片需要对照着文件 将图片的路径和文件名写在参数中。如果手工输入图片名称，不仅效率低，而且容易遗漏。 另外，如果需要大量重复使用composite，还需要精细调整合并结果，给composite程序增加很多参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Path(jpg_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加图片命令</span></span><br><span class="line">cmd = [<span class="string">&quot;composite&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加参数</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath.match(<span class="string">&#x27;*.jpg&#x27;</span>):</span><br><span class="line">    cmd.append(x)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 增加结果</span></span><br><span class="line">cmd.append(result_path)</span><br><span class="line"></span><br><span class="line">run(cmd)</span><br></pre></td></tr></table></figure>


<h2 id="视频的拆分与合并"><a href="#视频的拆分与合并" class="headerlink" title="视频的拆分与合并"></a>视频的拆分与合并</h2><p>如何使用 subprocess库调用可执行程序，来进行视频的拆分与合并。</p>
<p><strong>视频拆分的原理</strong></p>
<p>你在电脑本地经常见到的视频格式是MP4，但如果要把视频放在互联网上，为了减少首次播放的加载时间，你就必须把一个MP4切分成多个文件，而且切分之后还需要把格式转换为.TS 格式的视频文件。 </p>
<p>为什么不直接使用MP4格式，而是要把MP4格式改成.TS格式呢？这是因为.TS格式可以保证 多个文件之间的视频无缝播放，而且还会保证视频不会在播放下一个文件的时候，出现破音 或画面中断等影响用户体验的情况。 </p>
<p>当我们将一个视频切分成多个文件的时候，就要考虑文件的播放顺序问题了。为了记录顺序，我们需要在切分之后引入一个索引文件，这个索引文件不用手动编写，我们直接使 <strong>FFmpeg命令</strong>就行了，它可以实现视频格式的转换、合并和拆分。FFmpeg命令会在切分之 后，自动产生一个以.M3U8结尾的索引文件。 </p>
<p>我来解释一下这个索引文件。M3U8文件是指UDF-8编码格式下的M3U视频索引，播放器通 过这个索引文件就可以找到视频下所有的分段，并依次播放视频。</p>
<p>所以，想要使用Python进行视频拆分，我们首先需要FFmpeg命令， 然后通过Python设置FFmpeg的参数，最后再指定MP4文件和.TS文件的路径，这样就能实现拆分视频的功能了。</p>
<p>首先需要下载ffmpeg命令，用于把MP4切分成多段TS文件。</p>
<p>为了实现MP4文件格式的分割，需要使用ffmpeg非常多的参数。不过使用Python进行调用 的好处，就是你不用记住复杂的参数。我们把输入文件路径、切分大小、输出的M3U8和TS 文件指定为四个变量，这样只修改这四个变量，就可以实现拆分功能了。</p>
<blockquote>
<p>相比直接使用FFmpeg，subprocess调用FFmpeg的优势就在于两点，一是不用 记住复杂参数，二是对批量转换视频非常有利</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> run</span><br><span class="line"><span class="comment"># 拆分文件的路径</span></span><br><span class="line">input_video = <span class="string">&quot;/Users/edz/Desktop/05/xxx.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10秒分为一个文件</span></span><br><span class="line">segment_time = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># m3u8文件保存位置</span></span><br><span class="line"><span class="comment"># m3u8_list = &quot;/Users/edz/Desktop/05/xxx.m3u8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ts文件保存位置</span></span><br><span class="line">output_video = <span class="string">&quot;/Users/edz/Desktop/05/video-%04d.ts&quot;</span></span><br><span class="line"></span><br><span class="line">cmd1 = [<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-i&quot;</span>, input_video, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;segment&quot;</span>, <span class="string">&quot;-segment_time&quot;</span>, <span class="built_in">str</span>(segment_time), <span class="string">&quot;-segment_format&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mpegts&quot;</span>, <span class="string">&quot;-segment_list&quot;</span>, m3u8_list, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;copy&quot;</span>, <span class="string">&quot;-bsf:v&quot;</span>, <span class="string">&quot;h264_mp4toannexb&quot;</span>, <span class="string">&quot;-map&quot;</span>, <span class="string">&quot;0&quot;</span>, output_video]</span><br><span class="line"></span><br><span class="line">run(cmd1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line"><span class="comment"># ffmpeg -allowed_extensions ALL -protocol_whitelist &quot;file,http,crypto,tcp,https&quot; -i index.m3u8 -c copy out.mp4</span></span><br></pre></td></tr></table></figure>




























]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/2021/02/03/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断使得硬件得以发出通知给处理器，是一种变内核主动为硬件主动的方式。中断本质上是一种特殊的电信号。硬件在生成中断的时候并不需要考虑与处理器的时钟同步，即中断可以随时产生，<strong>内核随时可能因为新到来的中断而被打断</strong>。</p>
<img data-src="/2021/02/03/%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD1.png" class>

<p>不同的设备对应的中断不同，而每个中断都通过唯一的数字标识，这样，操作系统才能给不同的中断提供对应的中断处理程序。硬件发出中断，就是在提醒内核，有新的请求需要读取并处理。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>异常与中断不同之处就是在于异常在产生时必须要考虑处理器与时钟同步，所以其经常被称为同步中。</p>
<p>异常的产生原因：</p>
<blockquote>
<p>1.处理器由于执行到编程失误而导致的错误指令（如被0除）</p>
</blockquote>
<blockquote>
<p>2.执行期间出现特殊情况，例如缺页</p>
</blockquote>
<blockquote>
<p>3.系统调用陷入内核—–引起了系统调用处理程序异常</p>
</blockquote>
<p>以上，产生异常，都需要内核处理。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>内核通过执行中断处理程序(interrupt handler)来对某一特定的中断进行响应，产生中断的每一个设备都有一个相应的中断处理程序。一个设备的中断处理程序是其设备驱动程序的一部分—–设备驱动程序是<strong>用于对设备进行管理的内核代码</strong>。</p>
<p>中断处理程序被内核调用，运行于中断上下文，该上下文的执行代码不可阻塞。</p>
<h3 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h3><p>将中断处理分为两个部分。</p>
<blockquote>
<p>中断处理程序是上半部分（top half），接收到一个中断会被立即执行，只做有严格时限的工作。</p>
</blockquote>
<blockquote>
<p>能够被允许稍后完成的工作会被推迟到下半部去执行。即处理和操作中断的非即时完成请求会在随后的下半部中执行。</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><p>当执行一个中断处理程序时，内核处于中断上下文中(interrupt context)。</p>
<p>注意：</p>
<ul>
<li>中断上下文没有后备进程，所以其不可以睡眠。如果一个函数要进行睡眠，就不能出现在中断处理程序中。</li>
<li>中断处理程序实际上打断了其他的代码，这种异步执行的特性，要求所有的中断处理程序必须尽可能的快速、简单。尽量将工作从中断处理程序中分离出来，放在中断下半部执行。</li>
<li>中断处理程序栈是一个配置选项。在内核早期版本中，中断处理程序是共享别人的堆栈，获取空间时非常节约。后期，中断处理程序有了自己的栈（中断栈），但无论无何，在内核中还是要尽可能的节省空间的使用，因为内核栈本身就是有限的。</li>
<li><strong>进程上下文是可以睡眠的</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数现代硬件都通过中断来与操作系统进行通信。对给定的硬件进行管理的驱动程序注册中断处理程序，是为了响应并处理来自相关硬件的中断。中断过程所作的工作包括应答并重新设置硬件，从设备拷贝数据到内存以及反之，处理硬件请求，并发送新的硬件请求。</p>
<p>内核提供的接口包括注册和注销中断处理程序、禁止中断、屏蔽中断线以及检查中断系统的状态。</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公</title>
    <url>/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/</url>
    <content><![CDATA[<h1 id="任务场景一：拆分与合并–快速的批量处理内容相似的Excel"><a href="#任务场景一：拆分与合并–快速的批量处理内容相似的Excel" class="headerlink" title="任务场景一：拆分与合并–快速的批量处理内容相似的Excel"></a>任务场景一：拆分与合并–快速的批量处理内容相似的Excel</h1><blockquote>
<p>批量合并</p>
<p>假设你需要对某些工作内容进行问卷调查，这时你用Excel做了调查问卷模版。 我想你会这样做：先把Excel通过工作群分发给所有员工，再把群里收集到的反馈附件汇总 成一个文件。</p>
<p>批量拆分</p>
<p>假设你是公司的财务人员，你需要使用Excel对员工工资进行核算，之后再打印 出来。但是公司要求员工薪水保密，所以每个员工的工资需要拆分成一个独立的文件，最 后还需要打印出来。</p>
</blockquote>
<ul>
<li>解决方案：使用Python实现自动化批量处理。<ul>
<li>安装扩展库：支持Excel读取的扩展库叫做xlrd库，支持Excel写入的扩展库叫做xlwt库</li>
<li>找到整个工作过程当中重复操作的部分；</li>
<li> 将重复操作的部分需要哪些手工操作找出来，使用Python编写程序代替手工操作的部分；</li>
<li> 对重复的部分，使用循环语句进行批量处理。</li>
<li>可以使用绘制时序图来实现手工操作到Python程序的过渡</li>
</ul>
</li>
</ul>
<img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/image.png" class>





<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="Merge-py"><a href="#Merge-py" class="headerlink" title="Merge.py"></a>Merge.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入Excel和文件操作库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要合并excel的路径</span></span><br><span class="line">src_path = <span class="string">&#x27;D:/Python自动化办公/Day01/调查问卷&#x27;</span></span><br><span class="line"><span class="comment"># 指定合并完成的路径</span></span><br><span class="line">dst_file = <span class="string">&#x27;D:/Python自动化办公/Day01/result/结果.xls&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得给目录下所有的xlsx格式文件</span></span><br><span class="line">p = Path(src_path)</span><br><span class="line">files = [x <span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath(x).match(<span class="string">&#x27;*.xls&#x27;</span>)]</span><br><span class="line">print(files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备列表存放读取结果</span></span><br><span class="line">content = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个文件进行重复处理</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="comment"># 用文件作为每个用户的标识</span></span><br><span class="line">    username = file.stem</span><br><span class="line">    data = xlrd.open_workbook(file)</span><br><span class="line">    table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得每一项的结果</span></span><br><span class="line">    answer1 = table.cell_value(rowx=<span class="number">4</span>, colx=<span class="number">4</span>)</span><br><span class="line">    answer2 = table.cell_value(rowx=<span class="number">10</span>, colx=<span class="number">4</span>)</span><br><span class="line">    temp = <span class="string">f&#x27;<span class="subst">&#123;username&#125;</span>,<span class="subst">&#123;answer1&#125;</span>,<span class="subst">&#123;answer2&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并为一行存储</span></span><br><span class="line">    content.append(temp.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    print(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    print(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备写入文件的表头</span></span><br><span class="line">table_header = [<span class="string">&#x27;员工姓名&#x27;</span>, <span class="string">&#x27;第一题&#x27;</span>, <span class="string">&#x27;第二题&#x27;</span>]</span><br><span class="line"></span><br><span class="line">workbook = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">x1sheet = workbook.add_sheet(<span class="string">&quot;统计结果&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入表头</span></span><br><span class="line">row = <span class="number">0</span></span><br><span class="line">col = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> cell_header <span class="keyword">in</span> table_header:</span><br><span class="line">    x1sheet.write(row, col, cell_header)</span><br><span class="line">    col += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向下移动一行</span></span><br><span class="line">row += <span class="number">1</span></span><br><span class="line"><span class="comment"># 取出每一行的内容</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">    col = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 取出每个单元格内容</span></span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> line:</span><br><span class="line">        <span class="comment"># 写入内容</span></span><br><span class="line">        x1sheet.write(row, col, cell)</span><br><span class="line">        <span class="comment"># 向右移动一个单元格</span></span><br><span class="line">        col += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 向下移动一行</span></span><br><span class="line">    row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存最终结果</span></span><br><span class="line">workbook.save(dst_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Split-py"><a href="#Split-py" class="headerlink" title="Split.py"></a>Split.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工资单文件</span></span><br><span class="line">salary_file = <span class="string">&#x27;D:/Python自动化办公/Day01/工资单/工资单.xls&#x27;</span></span><br><span class="line"><span class="comment"># 拆分文件保存路径</span></span><br><span class="line">dst_path = <span class="string">&#x27;D:/Python自动化办公/Day01/工资单&#x27;</span></span><br><span class="line"></span><br><span class="line">data = xlrd.open_workbook(salary_file)</span><br><span class="line">table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 取得表头</span></span><br><span class="line">salary_header = table.row_values(rowx=<span class="number">0</span>, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义写入文件的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span>(<span class="params">filename, cnt</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    filename : 写入的文件名</span></span><br><span class="line"><span class="string">    cnt      : 写入的内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    workbook = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    xlsheet = workbook.add_sheet(<span class="string">&quot;本月工资&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> cnt:</span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> line:</span><br><span class="line">            xlsheet.write(row, col, cell)</span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    workbook.save(PurePath(salary_file).with_name(filename).with_suffix(<span class="string">&#x27;.xls&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得员工数量</span></span><br><span class="line">employee_number = table.nrows</span><br><span class="line"><span class="comment"># 取得每一行,并用第二个单元格作为新的文件名</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,employee_number):</span><br><span class="line">    content = table.row_values(rowx=line, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 将表头和员工数量重新组成一个新的文件 </span></span><br><span class="line">    new_content = []</span><br><span class="line">    <span class="comment"># 增加表头到要写入的内容中</span></span><br><span class="line">    new_content.append(salary_header)</span><br><span class="line">    <span class="comment"># 增加员工工资到要写入的内容中</span></span><br><span class="line">    new_content.append(content)</span><br><span class="line">    <span class="comment"># 调用自定义函数write_to_file()写入新的文件</span></span><br><span class="line">    write_to_file(filename = content[<span class="number">1</span>], cnt = new_content)</span><br></pre></td></tr></table></figure>


<h2 id="Python与Excel交互模块学习"><a href="#Python与Excel交互模块学习" class="headerlink" title="Python与Excel交互模块学习"></a>Python与Excel交互模块学习</h2>]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>创建高性能索引</title>
    <url>/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库索引</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>系统调用是内核与用户进程进行交互的一组接口，这些接口让应用程序受限制的访问硬件设备，提供了创建新进程并与已有进程进行交互通信的机制，也提供了申请操作系统其他资源的能力。</p>
<p>系统调用在Linux系统中的地位如下图所示：</p>
<img data-src="/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/OIP1.jpg" class>

<h3 id="2-与内核通信"><a href="#2-与内核通信" class="headerlink" title="2.与内核通信"></a>2.与内核通信</h3><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。这样的中间层有如下作用：</p>
<blockquote>
<p>1.为用户空间提供了一种硬件的抽象接口。</p>
</blockquote>
<blockquote>
<p>2.系统调用确保了系统的稳定与安全。内核可以作为硬件设备与用户空间之间的中间人，基于权限、用户类型和一些其他的规则对需要进行的访问做出裁决。</p>
</blockquote>
<blockquote>
<p>3.避免用户空间的应用程序对硬件资源随意访问而内核一无所知，这样既无法实现多任务和虚拟内存，也不能确保良好的稳定性和安全性。</p>
</blockquote>
<p><strong>Linux中：系统调用是用户空间访问内核的唯一手段—-除了异常和陷入外，它们是内核唯一的合法入口</strong></p>
<h3 id="3-API、POSIX、C库"><a href="#3-API、POSIX、C库" class="headerlink" title="3.API、POSIX、C库"></a>3.API、POSIX、C库</h3><p>应用程序通过在用户空间实现的应用编程接口（API）而不是直接通过系统调用。</p>
<blockquote>
<p>1.API实际上并不需要与内核提供的系统调用一一对应，程序员只跟API打交道。</p>
<p>2.内核只跟系统调用打交道，库函数以及应用程序如何使用系统调用不是内核所关心的。</p>
<p>3.API可以实现成一个系统调用，也可以实现多个系统调用，甚至也可以不实现系统调用。</p>
</blockquote>
<p>在UNIX中，最流行的应用编程接口是基于POSIX标准的。</p>
<p>Linux系统调用作为C库的一部分提供。C库实现了Unix系统的主要API，包括标准C库函数和系统调用接口，此外，C库提供了POSIX的绝大部分API。</p>
<h3 id="4-系统调用-syscall"><a href="#4-系统调用-syscall" class="headerlink" title="4.系统调用(syscall)"></a>4.系统调用(syscall)</h3><p><strong>通过在C库中定义的函数调用来执行</strong></p>
<p>系统调用在出现错误的时候C库会将错误码写入errno全局变量。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<p>为了保证32为操作系统和64位操作系统的兼容，系统调用在用户空间和内核空间有着不同的返回值类型。用户空间为int，内核空间为long。系统调用在内核中前面会加上sys_。例如：返回当前进程PID的系统调用get_pid（）在内核中被定义为sys_getpid()。</p>
<h4 id="4-1系统调用号"><a href="#4-1系统调用号" class="headerlink" title="4.1系统调用号"></a>4.1系统调用号</h4><p>在Linux中，每个系统调用都会被赋予一个系统调用号（独一无二的）。进程在执行系统调用时，不需要提及系统调用的名称，只需要使用系统调用号即可。</p>
<p><strong>系统调用号相当重要，一旦分配好就不能再更改，因为会导致之前编译好的应用程序崩溃。</strong>即使这个系统调用被删除，它所占用的系统调用号也不允许被回收利用。</p>
<p>内核记录了系统调用表中的所有已经注册过的系统调用的列表，存储在sys_call_table中，这个表为每一个有效的</p>
<p>系统调用指定了唯一的系统调用号。</p>
<h4 id="4-2系统调用的性能"><a href="#4-2系统调用的性能" class="headerlink" title="4.2系统调用的性能"></a>4.2系统调用的性能</h4><p>Linux系统调用比其他许多的操作系统执行要快。原因如下：</p>
<blockquote>
<p>1.Linux很短的上下文切换时间，进出内核都被优化的极为高效。</p>
<p>2.系统调用处理程序和每个系统调用本身非常简洁。</p>
</blockquote>
<h3 id="5-系统调用处理程序"><a href="#5-系统调用处理程序" class="headerlink" title="5.系统调用处理程序"></a>5.系统调用处理程序</h3><p>应用程序通过<strong>软中断</strong>的方式来告诉内核自己期望执行一个系统调用，希望系统当前可以从用户态切换到内核态，这样内核就可以代表应用程序在内核空间中执行系统调用。</p>
<p><strong>软中断</strong>：通过引起一个异常来促使系统切换到内核态前去执行异常处理程序。此时的异常处理程序其实就是<strong>系统调用处理程序</strong>。</p>
<p>在X86系统中预定义的软中断是中断号128，通过int $0x80来触发中断。这条指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序（系统调用处理程序）。</p>
<h4 id="5-1指定恰当的系统调用"><a href="#5-1指定恰当的系统调用" class="headerlink" title="5.1指定恰当的系统调用"></a>5.1指定恰当的系统调用</h4><p>在陷入内核空间时，要将系统调用号传给内核空间。X86系统，系统调用号是通过eax寄存器传递给内核的。system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。大于或者等于NR_syscalls，函数就返回-ENOSYS,否则，执行相应的系统调用。</p>
<p>系统调用表中的表项是以64位类型存放的，所以内核需要将给定的系统调用号乘4，然后用所得结果在表中查询位置。</p>
<h4 id="5-2参数传递"><a href="#5-2参数传递" class="headerlink" title="5.2参数传递"></a>5.2参数传递</h4><p>部分系统调用除了系统调用号之外，还需要传入一些外部参数，在发生陷入的时候，一并传给内核，同样是放在寄存器中。<strong>给用户空间的返回值同样是通过寄存器来传递的</strong></p>
<h3 id="6-系统调用的实现"><a href="#6-系统调用的实现" class="headerlink" title="6.系统调用的实现"></a>6.系统调用的实现</h3><h4 id="6-1实现系统调用"><a href="#6-1实现系统调用" class="headerlink" title="6.1实现系统调用"></a>6.1实现系统调用</h4><p>要求：</p>
<ul>
<li>Linux中不提倡采用多用途的系统调用（一个系统调用通过传递不同的参数值来完成选择的工作）</li>
<li>系统调用的接口应该力求简洁，参数尽量少。提供标志参数以确保向前兼容。</li>
<li>系统调用的设计越通用越好。</li>
</ul>
<h4 id="6-2参数验证"><a href="#6-2参数验证" class="headerlink" title="6.2参数验证"></a>6.2参数验证</h4><p>系统调用必须检查参数是否合法有效。系统调用在内核空间中执行，任由用户将不合法的输入传递给内核，系统大的安全和稳定性将面临考验。进程不能让内核访问那些他没有权限访问的数据。</p>
<ul>
<li>与文件IO有关的系统调用需要检查文件描述符是否有效，与进程有关的函数必须检查提供的PID是否有效。</li>
<li>检查用户提供的指针是否有效<ul>
<li>指针指向的内存区域只能属于用户空间，进程不能告诉内核去读内核空间中的数据。</li>
<li>指针指向的内存区域在自己的进程中，不能让内核去读其他进程中的数据。</li>
<li>进程不能越过内存访问限制（可读、可写、可执行）</li>
</ul>
</li>
<li>检查是否有合法权限</li>
</ul>
<p>内核提供了两个方法来完成必须的检查和内核空间与用户空间之间的数据来回拷贝</p>
<ul>
<li>写入：copy_to_user()</li>
<li>读取：copy_from_user()</li>
</ul>
<p>这两个方法可能会引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，进程会休眠，直到缺页处理程序将该页从硬盘从新换回物理内存。</p>
<h3 id="7-系统调用上下文"><a href="#7-系统调用上下文" class="headerlink" title="7.系统调用上下文"></a>7.系统调用上下文</h3><p>在进程调用系统调用时，会有进程上下文。既可以被抢占也可以休眠。</p>
<p>可以休眠说明系统调用可以利用内核提供的绝大部分功能。可以被抢占说明该系统调用时可重入的（新的进程同样可以使用相同的系统调用）。</p>
<p>系统调用返回时，控制权仍然在system_call()中，它最终会负责切换到内核工作空间，并让用户进程继续执行下去。</p>
<h4 id="7-1绑定一个系统调用的最后步骤"><a href="#7-1绑定一个系统调用的最后步骤" class="headerlink" title="7.1绑定一个系统调用的最后步骤"></a>7.1绑定一个系统调用的最后步骤</h4><blockquote>
<p>1.在系统调用表中的最后加入一个表项。从0开始算起，系统调用在表中的位置就是他的系统调用号。</p>
</blockquote>
<blockquote>
<p>2.系统调用必须被编译进内核映像（不能被编译成模块）</p>
</blockquote>
<h4 id="7-2从用户空间访问系统调用"><a href="#7-2从用户空间访问系统调用" class="headerlink" title="7.2从用户空间访问系统调用"></a>7.2从用户空间访问系统调用</h4><p>系统调用靠的时C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用。</p>
<p><strong>Linux新系统调用增添频率很低，说明Linux系统是一个相对较为稳定并且功能已经较为完善的操作系统</strong></p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>Linux系统内核设计</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网刷题-操作系统2</title>
    <url>/2022/02/18/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/2022/02/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Process</title>
    <url>/2022/02/16/Process/</url>
    <content><![CDATA[<h1 id="Unix-Process"><a href="#Unix-Process" class="headerlink" title="Unix Process"></a>Unix Process</h1><img data-src="/2022/02/16/Process/image16.png" class>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>进程就是处于执行期的程序(目标码存放在某种存储介质上)。但进程并不仅仅局限于一段可执行程序代码(Unix称其为代码段，text section)，通常<strong>进程还要包含其他资源</strong>，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程(thread of execution),当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明地管理所有细节。</p>
<blockquote>
<p>所以说，程序本身并不是进程，<strong>进程是处于执行期的程序以及相关资源的总称</strong></p>
</blockquote>
<h3 id="进程的两种虚拟机制"><a href="#进程的两种虚拟机制" class="headerlink" title="进程的两种虚拟机制"></a>进程的两种虚拟机制</h3><ul>
<li><p>虚拟处理器</p>
<p>虽然实际上可能是 许多进程正在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器</p>
</li>
<li><p>虚拟内存</p>
<p>虚拟内存让进程在分配和管理内存时觉得自己拥有整个 系统的所有内存资源。</p>
</li>
</ul>
<h2 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h2><p>内核把<strong>进程的列表</strong>存放在叫做<strong>任务队列(task list©)的双向循环链表</strong>中。链表中的每一 项都是类型为task_struct、称为<strong>进程描述符</strong>(process descriptor)的结构，该结构定义在＜linux/ sched.h＞文件中。<strong>进程描述符中包含一个具体进程的所有信息</strong>。</p>
<p>进程描述符中包含的数据能完整 地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有其他更多信息</p>
 <img data-src="/2022/02/16/Process/image01.png" class>

<h3 id="分配进程描述符-slab-thread-info"><a href="#分配进程描述符-slab-thread-info" class="headerlink" title="分配进程描述符(slab+thread_info)"></a>分配进程描述符(slab+thread_info)</h3><p>Linux通过<strong>slab分配器</strong>分配task_struct结构，这样能达到<strong>对象复用</strong>和<strong>缓存着色</strong>（cache coloring）</p>
<p>在2.6以前的内核中，各个进程的task_struct存放在它们 内核栈的尾端。这样做是为了让那些像x86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，而避免使用额外的寄存器专门记录。由于现在用slab分配器动态生成task_ struct,所以只需在栈底（对于向下增长的栈来说）或栈顶（对于向上增长的栈来说）创建一个 新的结构 struct thread_info 。</p>
  <img data-src="/2022/02/16/Process/image02.png" class>



 <img data-src="/2022/02/16/Process/image03.png" class>

<p>每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任 务实际task_struct的指针。</p>
<h3 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h3><p>内核通过一个唯一的进程标识值（process identification value）或<strong>PID</strong>来标识每个进程。PID是 一个数，表示为pid_t隐含类型,实际上就是一个int类型。为了与老版本的Unix和Linux兼容， PID的最大值默认设置为32768 （short int短整型的最大值,），这个最大值很重要，因为它实际上就是系统中允许同时存在的进程的最大数目。尽管这个值也可以增加到高达400万 （这受&lt;linux/threads.h＞中所定义PID最大值的限制）。内核把每个进程的PID存放在它们各自的进程描述符中。 </p>
<p>在内核中，<strong>访问任务通常需要获得指向其task_struct的指针</strong>。实际上，内核中大部分处理进程的代码都是直接通过task_struct进行的。因此，通过<strong>current宏査找到当前正在运行进程</strong>的进程描述符的速度就显得尤为重要。硬件体系结构不同，该宏的实现也不同，它必须针对专门的硬件体系结构做处理。</p>
<ul>
<li>有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程task_struct 的指针，用于加快访问速度。</li>
<li>像x86这样的体系结构（其寄存器并不富余），就只能在内 核栈的尾端创建thread_info结构，通过计算偏移间接地查找task_struct结构。 </li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程描述符中的state域描述了进程的当前状态，系统中的每个进程都必然处于五种进程状态中的一种。该域的值也必为下列五种状态标志之一:</p>
<ul>
<li><p><strong>TASK_RUNNING</strong> （运行）— 进程是可执行的；它或者正在执行，或者在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态； 这种状态也可以应用到内核空间中正在执行的进程。</p>
</li>
<li><p>**TASK_INTERRUPTIBLE **（可中断）— 进程正在睡眠（也就是说它被阻塞），等待某些条 件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会 因为接收到信号而提前被唤醒并随时准备投入运行</p>
</li>
<li><p>**TASK_UNINTERRUPTIBLE **（不可中断）— 除了就算是接收到信号也不会被唤醒或准备 投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须在等待时不受干扰或 等待事件很快就会发生时出现。由于处于此状态的任务对信号不做响应，所以较之可中断 状态e,使用得较少。</p>
</li>
<li><p><strong>_TASK_TRACED</strong>—被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。</p>
</li>
<li><p>**_TASK_STOPPED **（停止）— 进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP, SIGTTIN, SIGTTOU等信号的时候。此外, 在调试期间接收到任何信号，都会使进程进入这种状态。</p>
<img data-src="/2022/02/16/Process/image04.png" class>

</li>
</ul>
<h3 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h3> <img data-src="/2022/02/16/Process/image05.png" class>



<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间 执行。一般程序在用户空间执行。当一个程序调执行了系统调用或者触发了某个 异常，它就<strong>陷入了内核空间</strong>。此时，我们称内核“代表进程执行”并<strong>处于进程上下文</strong>中。在此上下文中current宏是有效的°。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间会继续执行。 系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核 执行— 对内核的所有访问都必须通过这些接口。</p>
<p>​    </p>
<h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>Unix系统的进程之间存在一个明显的继承关系，在Linux系统中也是如此。所有的进程都 是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初 始化脚本(initscript)并执行其他的相关程序，最终完成系统启动的整个过程</p>
<p>系统中的每个进程必有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。拥 有同一个父进程的所有进程被称为兄弟。<strong>进程间的关系存放在进程描述符中</strong>。每个task_struct都 包含一个指向其<strong>父进程tast_struct</strong>、叫做<strong>parent</strong>的指针，还包含一个称为<strong>children的子进程链表</strong>。 所以。</p>
<ul>
<li>对于当前进程，通过下面的代码获得其父进程的进程描述符：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span>  current-&gt;parent;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过以下方式访问子进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>,&amp;current-&gt;children)&#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>,struct task_struct,sibling); <span class="comment">//task指向当前的某个子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
 <img data-src="/2022/02/16/Process/image06.png" class>

<h2 id="进程创建（fork-exec）"><a href="#进程创建（fork-exec）" class="headerlink" title="进程创建（fork+exec）"></a>进程创建（fork+exec）</h2><p>在新的地址空间创建线程，读入可执行文件，最后开始执行。</p>
<blockquote>
<p>fork</p>
</blockquote>
<p><strong>拷贝当前进程创建一个子进程</strong>。子进程与父进程的区别仅仅在于PID (每个进程唯一)、PPID (父进程的进程号，子进程将其设置为被拷贝进程的PID)和某些资源和统计量(例如，挂起的信号，它没有必要被继承)。</p>
<blockquote>
<p>exec</p>
</blockquote>
<p><strong>exec()函数负责读取可执行文件并将其载入地址空间开始运行</strong>。把这两个函数组合起来使用的效果跟其他系统使用的单一函数的效果相似。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>传统的fork()系统调用<strong>直接把所有的资源复制给新创建的进程</strong></p>
<p>Linux的fbrk()使用写时拷贝(copy-on-write)页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。</p>
<p><strong>只有在需要写入的时候</strong>，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资 源的复制只有在需要写入的时候才进行，在此之前，<strong>只是以只读方式共享</strong>。这种技术使地址空间 上的页的拷贝被推迟到实际发生写入的时候才进行。在页根本不会被写入的情况下(举例来说， fork。后立即调用exec())它们就无须复制了</p>
<p><strong>fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符</strong>。在一般情况 下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据(地址空间里常常包含数十兆的数据)。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。</p>
<h3 id="frok-函数"><a href="#frok-函数" class="headerlink" title="frok()函数"></a>frok()函数</h3><p>Linux通过<strong>clone()系统调用</strong>实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源</p>
<blockquote>
<p>fbrk()、▼fork和_clone () 库函数都<strong>根据各自需要的参数</strong>标志去调用clone(),然后由clone()去调用do_fork().</p>
</blockquote>
<p>do_fork完成了创建中的大部分工作，它的定义在kernel/fork.c文件中。该函数调用copy_ process()函数，然后让进程开始运行。</p>
<p>**copy_process()**函数流程如下：</p>
 <img data-src="/2022/02/16/Process/image07.png" class>

 <img data-src="/2022/02/16/Process/image08.png" class>

<p>再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其 投入运行。<strong>内核有意选择子进程首先执行</strong>°。因为一般子进程都会马上调用exec()函数，这样可 以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<h3 id="vfork-函数"><a href="#vfork-函数" class="headerlink" title="vfork()函数"></a>vfork()函数</h3> <img data-src="/2022/02/16/Process/image09.png" class>

<h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>线程机制是现代编程技术中常用的一种抽象概念。该机制提供了在同一程序内共享内存地址 空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。线程机制<strong>支持并发</strong>程序设计 技术(concurrentprogramming),在多处理器系统上，它也能<strong>保证真正的并行处理</strong>(parallelism)。</p>
<p>Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。<strong>Linux把所有的线程都当做进程来实现</strong>。<strong>内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程</strong>。相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自 己的task_struct,所以在内核中，它看起来就像是一个普通的进程(只是线程和其他一些进程共 享某些资源，如地址空间)。</p>
<p>上述线程机制的实现与Microsoft Windows或是Sun Solaris等操作系统的实现差异非常 大。这些系统都在内核中提供了专门支持线程的机制(这些系统常常把线程称作轻量级进程 (lightweight processes))o “轻量级进程”这种叫法本身就概括了 Linux在此处与其他系统的差 异。在其他的系统中，相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于**<em>Linux来说，它只是一种进程间共享资源的手段(**</em>Linux的进程本身就够轻量级了)°。 举个例子来说，假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有 一个包含指向四个不同线程的指针的进程描述符。该描述符负责描述像地址空间、打开的文件这 样的共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅<strong>创建四个进程并分配四个普通的task_sturct结构</strong>。建立这四个进程时指定他们共享某些资源，这是相当高雅的做法。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS |CLONE_FILES |CLONE_SIGHAND,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>传递给clone()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。</p>
 <img data-src="/2022/02/16/Process/image10.png" class>

 <img data-src="/2022/02/16/Process/image11.png" class>



<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程(kernel thread)完成— 独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程**<em>没有独立的地址空间**</em>(实际上指向地址空间的mm指针被设置为NULL).它们<strong>只在内核空间运行</strong>，<strong>从来不切到用户空间</strong>去。内核进程和普通进程一样，可以被调度，也可以被抢占。</p>
<p>在装有Linux系统的机子上运行<strong>ps -ef</strong>命令，你可以看到内核线程，有很多！这些线程在系统启 动时由另外一些内核线程创建。实际上，内核线程也只能由其他内核线程创建。<strong>内核是通过从 kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的</strong>。创建的进程处于不可运行状态，如果不通过调用<strong>wake_up_process()</strong> 明确地唤醒它，它不会主动运行。创建一个进程并让它运行起来，可以通过调用<strong>kthread_run()</strong> 来达到</p>
 <img data-src="/2022/02/16/Process/image12.png" class>

<p><strong>kthread_run()</strong> 宏实现</p>
 <img data-src="/2022/02/16/Process/image13.png" class>

<p>内核线程启动后就一直运行直到调用do_exit()退出，或者内核的其他部分调用kthread_ stop()退出，传递给kthread_stop()的参数为kthread_create()函数返回的task struct结构的地址：</p>
<blockquote>
<p>int kthread_stop(struct task_struct *k)</p>
</blockquote>
<h2 id="进程的终结"><a href="#进程的终结" class="headerlink" title="进程的终结"></a>进程的终结</h2><blockquote>
<p>当一个进程终结时，内核必须释放它所占有的资源 并把这一不幸告知其父进程。</p>
</blockquote>
<p>进程的析构是自身引起的。它发生在进程<strong>调用exit()系统调用</strong>时，</p>
<ul>
<li><p>既可能显式地调用这个系统调用</p>
</li>
<li><p>也可能隐式地从某个程序的主函数返回(其实C语言编译器会在main() 函数的返回点后面放置调用exit()的代码)。</p>
</li>
<li><p>当进程接受到它既不能处理也不能忽略的信号或异 常时，它还可能被动地终结。</p>
<p>不管进程是怎么终结的，该任务大部分都要靠<strong>do_exit()</strong>(定义于 kemel/exitx)来完成，</p>
</li>
</ul>
<p>do_exit完成的工作</p>
 <img data-src="/2022/02/16/Process/image14.png" class>

<p>的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。</p>
<p>与进程相关联的<strong>所有资源都被释放掉了</strong>(假设该进程是这些资源的唯一使用者)。进程<strong>不可运行</strong>(实际上也没有地址空间让它运行)并处于<strong>EXIT_ZOMBIE</strong>退出状态。它占用的所 有内存就是内核栈、thread_infb结构和tast_struct结构。此时<strong>进程存在的唯一目的就是向它的父进程提供信息</strong>。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内 存被释放，归还给系统使用。</p>
<h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p>在调用了 do_exit()之后，尽管线程已经僵死不能再运行了，但是系统还<strong>保留了它的进程描述符</strong>。这样做可以让系统有办法在子进程终结后仍能获得它的信息。因此，**<em>进程终结时所需的清理工作和进程描述符的删除被分开执行**</em>。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。 </p>
 <img data-src="/2022/02/16/Process/image15.png" class>

<h3 id="孤儿进程（父进程在子进程之前推出）"><a href="#孤儿进程（父进程在子进程之前推出）" class="headerlink" title="孤儿进程（父进程在子进程之前推出）"></a>孤儿进程（父进程在子进程之前推出）</h3><p>如果<strong>父进程在子进程之前退出</strong>，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。</p>
<p><strong>解决方法</strong>给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。在do_exit()中会调用exit_notify(),该函数会调用fbrget_original_parent(),而后者会调用find_new_reaper()来执行寻父过程：</p>
<p>一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。 init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。</p>
<p>父进程通过wait()系统调用族来收集其后代信息</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网刷题-操作系统1</title>
    <url>/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/</url>
    <content><![CDATA[<ul>
<li><p>Windows 操作系统具有较强的存储管理功能，当主存容量不够时系统可以自动地扩充，为应用程序提供一个容量比实际物理主存大得多的存储空间。这种存储管理技术称为**<em>虚拟缓存器技术**</em></p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image01.png" class>

<ul>
<li><p>详细解释</p>
<ul>
<li><p>缓冲区技术，是为了协调吞吐速度相差很大的设置之间数据传送而采用的技术；</p>
</li>
<li><p>虚拟存储器技术，是为应用程序提供一个容量比实际物理主存大得多的存储空间，使当主存容量不够时系统可以自动地扩充的技术；</p>
</li>
<li><p>SPOOLing技术，是低速输入输出设备与主机交换的一种技术，也称为“假脱机真联机”技术</p>
</li>
<li><p>进程调度技术，是负责决定哪个进程投入运行，何时运行以及运行多长时间的技术</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>一个多道批处理系统中仅有 P1 和 P2 两个作业， P2 比 P1 晚 5ms 到达，它们的计算和 I/O 操作顺序如下：</p>
<p>P1 ：计算 60ms ， I/O 80ms ，计算 20ms</p>
<p>P2 ：计算 120ms ， I/O 40ms ，计算 40ms</p>
<p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是 。**<em>（260ms）**</em></p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image02.png" class>



</li>
</ul>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image03.png" class>



<ul>
<li><p>​    在下列文件的物理结构中，不便于增删文件内容的是 <strong><em>连续文件</em></strong></p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image04.png" class>

<ul>
<li><p>详细解释</p>
<ul>
<li><p><strong>连续文件</strong>类似于<strong>数组</strong>，顺序访问速度快，但是增删数据时要移动其他数据块，所以速度很慢；</p>
</li>
<li><p><strong>链接文件</strong>类似于<strong>链表</strong>，随机访问速度慢，增删数据很快，不需要移动数据块，只需要改变指针指向即可；</p>
</li>
<li><p><strong>索引文件</strong>糅合了连续文件和链接文件，但更适合大文件；</p>
</li>
<li><p><strong>Windows使用显式链接文件</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>为提高操作系统自身的可适应性和可扩展性，现代操作系统通过引入和实现( <strong><em>逻辑设备</em></strong>) 的概念而实现了设备独立性。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image05.png" class>
</li>
<li><p>在操作系统中，用户程序申请使用 I/O 设备时，通常采用（ ）。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image06.png" class>

</li>
</ul>
<p>现代操作系统为了提高系统的可适应性和可扩展性，都实现了设备独立性或设备无关性。基本含义是**<em>应用程序独立于具体使用的物理设备，应用程序以逻辑设备名请求使用某类设备**</em>。实现了设备独立性功能可带来两方面的好处：</p>
<p>（1）设备分配时的灵活性；</p>
<p>（2）易于实现I/O 重定向。为了实现设备的独立性，应引入逻辑设备和物理设备概念。在应用程序中，使用逻辑设备名请求使用某类设备；系统执行时是使用物理设备名。鉴于驱动程序是与硬件或设备紧密相关的软件，必须在驱动程序之上设置一层设备独立性软件，<strong>执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换</strong>（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。</p>
<blockquote>
<p>虚拟设备名</p>
</blockquote>
<p>通过<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/4968684">虚拟技术</a>将一台独占设备虚拟成多台逻辑设备，供多个进程同时使用的设备的名字。</p>
<p>虚拟设备技术的作用是提高慢速独占设备的利用率，采用了假脱机技术后—个程序对慢速独占设备的占用时间短了(因为连续了)。</p>
<blockquote>
<p>独占设备名</p>
</blockquote>
<p>独占设备：进程应互斥地访问这类设备，即系统一旦把这类设备分配给了某进程后，便由该进程独占，直到用完释放。典型的独占设备有打印机、磁带机等。系统在分配时，还应考虑到安全性</p>
<ul>
<li><p>现代OS具有并发性和共享性，是由（**<em>多道程序**</em>）的引入而导致的。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image07.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image44.png" class>



</li>
</ul>
<ul>
<li><p>下面的叙述中，（ <strong>节省系统内存</strong>）不是设备管理中引入缓冲机制的主要原因。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image08.png" class>



</li>
</ul>
<ul>
<li><p>若有 4 个进程共享同一程序段，而且每次最多允许 3 个进程进入该程序段，则信号量的变化范围是？</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image09.png" class>

</li>
</ul>
<p>最多允许3个进程进入，所以信号量初值为3，当程序段进入了三个进程后信号量变为0，第四个进程进入时，信号量减为-1。</p>
<ul>
<li><p>下列选项中，不属于进程关键要素的是________。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image10.png" class>

</li>
</ul>
<p>一般来说Linux系统中的进程都具备下列诸要素：</p>
<p>（1）有一段程序供其执行。（程序）</p>
<p>（2）有进程专用的系统堆栈空间。（数据和栈）</p>
<p>（3）在内核有task_struct数据结构。（进程控制块）</p>
<p>（4）有独立的存储空间，拥有专有的用户空间。</p>
<p>如果只具备前面三条而缺第四条，那就称为“线程”。如果完全没有用户空间，就称为“内核线程”；而如果共享用户空间则就称为“用户线程”。</p>
<ul>
<li>临界区是（） </li>
</ul>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image11.png" class>

<p>临界区：每个进程中访问临界资源的那段<strong>程序</strong>叫做临界区。进程对临界区的访问必须互斥，每次只允许一个进程进去临界区，其他进程等待</p>
<ul>
<li><p>在一单处理机系统中，若有4 个用户进程，在某一时刻，处于阻塞状态的用户进程最多有</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image12.png" class>

</li>
</ul>
<p>处于死锁的情况下。</p>
<ul>
<li><p>关于多线程和多线程编程，以下哪些说法正确的（）</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image13.png" class>





</li>
</ul>
<ul>
<li><p>计算机操作系统出现死锁的原因是什么?</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image14.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image15.png" class>





</li>
</ul>
<ul>
<li>同一文件系统中不允许文件同名 , 否则会引起混乱，这种说法正确吗？[<strong><em>错误</em></strong>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件目录结构一般有一级目录结构、二级目录结构和多级目录结构。 一级目录结构的优点是简单，缺点是文件不能重名，限制了用户对文件的命名。 二级目录结构实现了文件从名字空间到外存地址空间的映射：用户名—&gt;文件名à文件内容。其优点是有利于文件的管理、共享和保护；适用于　 多用户系统；不同的用户可以命名相同文件名的文件，不会产生混淆，解决了命名冲突问题。缺点是不能对文件分类；当用文件较多时查找速度慢。</span><br><span class="line">多级目录结构的优点是便于文件分类，可为每类文件建立一个子目录；查找速度快，因为每个目录下的文件数目较少；可以实现文件共享；缺点是比较复杂。</span><br></pre></td></tr></table></figure>


<ul>
<li><p>死锁与安全状态的的关系是</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image16.png" class>

</li>
</ul>
<blockquote>
<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p>
</blockquote>
<ul>
<li><p>一般用户更喜欢使用的系统是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image17.png" class>



</li>
</ul>
<blockquote>
<p>批处理系统</p>
</blockquote>
<p>  处理系统，又名批处理操作系统。<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86/1448600">批处理</a>是指<strong>用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行</strong>。这种采用<a href="https://baike.baidu.com/item/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86/4973973">批量处理</a>作业技术的操作系统称为批处理操作系统。批处理操作系统分为<strong>单道批处理系统和<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/3792844">多道批处理系统</a>**。批处理操作系统</strong>不具有交互性**，它是为了提高CPU的利用率而提出的一种操作系统。</p>
  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">所谓批处理(batch processing )就是将作业按照它们的性质分组（或分批），然后再成组（或成批）地提交给计算机系统，由计算机自动完成后再输出结果，从而减少作业建立和结束过程中的时间浪费。根据在内存中允许存放的作业数，批处理系统又分为单道批处理系统和多道批处理系统。早期的批处理系统属于单道批处理系统，其目的是减少作业间转换时的人工操作，从而减少CPU的等待时间。它的特征是内存中只允许存放一个作业，即当前正在运行的作业才能驻留内存，作业的执行顺序是先进先出，即按顺序执行。</span><br><span class="line">由于在单道批处理系统中，一个作业单独进入内存并独占系统资源，直到运行结束后下一个作业才能进入内存，当作业进行I/O操作时，CPU只能处于等待状态，因此，CPU利用率较低，尤其是对于I/O操作时间较长的作业。为了提高CPU的利用率，在单道批处理系统的基础上引入了多道程序设计（multiprogramming）技术，这就形成了多道批处理系统，即在内存中可同时存在若干道作业，作业执行的次序与进入内存的次序无严格的对应关系，因为这些作业是通过一定的作业调度算法来使用CPU的，一个作业在等待I/O处理时，CPU调度另外一个作业运行，因此CPU的利用率显著地提高了。</span><br><span class="line">批处理系统主要指多道批处理系统，它通常用在以科学计算为主的大中型计算机上，由于多道程序能交替使用CPU，提高了CPU及其他系统资源的利用率，同时也提高了系统的效率。多道批处理系统的缺点是延长了作业的周转时间，用户不能进行直接干预，缺少交互性，不利于程序的开发与调试。</span><br></pre></td></tr></table></figure>
<p>  <strong>操作系统的分类</strong></p>
   <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image18.png" class>



<ul>
<li>我们熟知的Windows XP、Linux、Mac OS X等都是<strong>多用户多任务分时操作系统</strong>，可见这个概念一直延续到了今天。它们最显著的特点就是可以让多个人使用同一台电脑而且不能互相窥探对方的秘密。当你使用电脑的时候可以边听音乐边看新闻，同时还能跟朋友聊天。只要你觉得你的大脑还能处理得过来，你还能让这台电脑同时干更多的事情。其实这类操作系统我们完全可以只用“<strong>分时</strong>”二字简要概述下来。因为“分时”就像它最初的定义那样：将电脑的时间资源适当分配给所有使用者身上，让所有使用者有独占机器的感觉。但是如果把“使者”进行抽象，就不仅可以代表人，还可以将任务也理解为电脑时间资源的使用者，那么<strong>“分时”就是多用户和多任务的基础和前提</strong>。所以，既然是“分时”的，一般都会支持多用户和多任务</li>
</ul>
<ul>
<li><p>能实现紧凑技术的存储管理（ ）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image19.png" class>

</li>
</ul>
<blockquote>
<p>—- 动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，<strong>添加了紧凑功能</strong> <strong>。</strong></p>
<p>—- 通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。</p>
</blockquote>
<blockquote>
<p>存储器管理的对象是主存，也称内存。它的主要功能包括分配和回收主存空间、提高主存利用率、扩充主存、对主存信息实现有效保护。</p>
<p>存储管理方案的主要目的是解决多个用户使用主存的问题，其存储管理方案主要包括<strong>分区存储管理</strong>、<strong>分页存储管理</strong>、<strong>分段存储管理</strong>、<strong>段页式存储管理</strong>以及<strong>虚拟存储管理</strong>。</p>
<p>分区存储管理又有三种不同的方式：<strong>静态分区、可变分区、可重定位分区</strong> 。</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image20.png" class>



<ul>
<li><p>为实现设备分配，应为每一类设备配置一张 。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image21.png" class>

</li>
</ul>
<p>逻辑设备表（LUT）功能是完成逻辑名到物理设备名的映射。</p>
<p>设备分配表（DCT）是，系统为每一个设备配置了一张设备控制表，记录设备的特性以及与设备控制器的连接情况，其中有字段“设备状态”用来表示设备是忙还是闲，“COCT指针”指向与该设备相连接的设备控制器。</p>
<ul>
<li>当计算机系统没有用户执行时，处理机完全处于空闲状态。[<strong><em>错</em></strong>]</li>
</ul>
<blockquote>
<p><strong>系统本身也会有很多状态要维护，会一直处于监听状态。</strong></p>
</blockquote>
<p>​                            </p>
<ul>
<li><p>下列关于总线的说法中正确的是(  )</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image22.png" class>



</li>
</ul>
<ul>
<li><p>A：总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及其控制电路。如果不特别指出，总线一般指代内总线。<br>B：内部总线位于CPU内部，连接各个寄存器和运算器。<br>C：I/O总线是用于连接主机和I/O设备的总线。<br>D：计算机总线中包含内部总线、系统总线（前端总线）、I/O总线。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image23.png" class>





</li>
</ul>
<ul>
<li><p>一个进程执行过程中不可能对应()。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image24.png" class>

</li>
</ul>
<blockquote>
<p>PCB:  Process Control Block 进程控制块</p>
<p>了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97/7205297">进程控制块</a>（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image25.png" class>

<p><strong>进程（Process）和作业（Job）是一个意思，不同书中表述不同，JCB就相当于是PCB。一个进程一个PCB，所以不会对应到多个PCB</strong></p>
<ul>
<li>进程申请不到CPU 时，其状态将变为阻塞状态，这样的说法正确吗 【**<em>错误**</em>】</li>
</ul>
<p>也可能是就绪，其他都准备好了，只差CPU</p>
<ul>
<li><p>“进程一次性申请全部所需资源”通过防止( )条件的出现实现死锁预防</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image26.png" class>

</li>
</ul>
<p><img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220217164051506.png" alt="image-20220217164051506"></p>
<ul>
<li><p>在分时系统中，若当前运行的进程连续获得了两个时间片，原因可能是（ ）</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image27.png" class>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就绪队列为空 </span><br><span class="line">无其他进程需要使用CUP,所以连续分配时间片</span><br></pre></td></tr></table></figure>


<ul>
<li><p>在 段页式存储管理中 ，每个进程拥有多个段表，但只有一张页表。[<strong><em>错误</em></strong>]</p>
</li>
<li><p>需要周期刷新的存储器是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image28.png" class>

<p>考察的是不同<strong>存储器</strong>的功能特点。</p>
<ul>
<li>A选项为<strong>静态随机存取存储器</strong>（Static Random-Access Memory，SRAM）是随机存取存储器的一种。是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。</li>
<li>B选项为<strong>动态随机存取存储器</strong>(Dynamic Random Access Memory，DRAM)最为常见的系统内存。<strong>DRAM的存储位元是基于电容器的电荷量存储，这个电荷量会随着时间和温度而减少，因此必须定期的刷新，以保持它们原来记忆的正确信息。对DRAM的所有存储单元恢复一次原状态的时间间隔，叫做刷新周期。</strong></li>
<li>C选项<strong>只读存储器</strong>(Read-Only Memory，ROM)所存数据稳定 ，断电后所存数据也不会改变；其结构较简单，读出较方便，因而常用于存储各种固定程序和数据。</li>
<li>D选项属于<strong>静态存储器的原理</strong>，即靠双稳态触发器的两个稳定状态保存信息</li>
</ul>
</li>
</ul>
<ul>
<li><p>实现虚拟存储的目的是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image29.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image30.png" class>



</li>
</ul>
<ul>
<li>解决死锁问题通常意味着牺牲资源的效率   【**<em>正确**</em>】</li>
</ul>
<blockquote>
<p>解决死锁通常是释放部分进程资源，故牺牲了资源的效率</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">破坏死锁的方法包括： 1. 破坏互斥条件，如果系统资源都能共享，则不会死锁--但由于打印机等资源显然不能被共享，该方法不好。 2. 破坏请求并保持条件，预先分配全部资源，运行时才投入使用，并一直独享，系统资源被浪费。 3. 破坏不可剥夺条件，保持不可剥夺资源的进程，在请求新资源未被满足时，必须先释放保持的资源，需要时重新申请，反复申请和释放增加了开销。 4. 破坏循环等待条件，采用顺序资源分配，用编号分配资源，按次序操作会造成浪费。</span><br></pre></td></tr></table></figure>


<ul>
<li><p>存放在磁盘上的文件</p>
<blockquote>
<p>即可随机访问，又可顺序访问</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>位示图可用于()</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image31.png" class>

</li>
</ul>
<p>操作系统管理空闲存储空间的方法：位示图法【**<em>0表示空闲，1表示已经分配**</em>】、空闲区表法、空闲链表法以及成组链接法</p>
<ul>
<li><p>在 Word 中，执行打开文件 C:\a.doc 操作，是将 <strong><strong>____</strong></strong></p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image32.png" class>

</li>
</ul>
<blockquote>
<p>C盘是硬盘，A盘和B盘都是软盘；我们现在说的内存一般都是RAM，而ROM也可以做内存，只不过是Read Only的(只能写一次)，通常用来存储BIOS程序，断电后内容还在。</p>
</blockquote>
<ul>
<li><p>单道程序系统中程序的执行也需要同步和互斥 【**<em>错**</em>】</p>
<ul>
<li><p>详细解释</p>
<ul>
<li><p><strong>1. 资源独占性</strong></p>
<p>任何时候，位于内存中的程序可以使用系统中的一切资源，不可能有其他程序与之竞争</p>
<p><strong>2. 执行的顺序性</strong></p>
<p>内存中只有一个程序，各个程序是按次序执行的。在做完一个程序的过程中，不可能夹杂进另一个程序执行</p>
<p> <strong>3. 结果的可再现性</strong></p>
<p>只要执行环境和初始条件相同，重复执行一个程序，获得的结果总是一样的</p>
<p> <strong>4. 运行结果的无关性</strong></p>
<p>程序的运行结果与程序执行的速度无关。系统中的作业以串行的方式被处理，无法提高CPU、内存的利用率</p>
<p>本来就是有序的，故不需要同步互斥</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>目录在linux文件系统中是以怎样的形式存在的？</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image33.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image34.png" class>







</li>
</ul>
<ul>
<li><p>使用下面那些存储管理方法可以实现虚拟存储？【**<em>BCD**</em>】</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image35.png" class>

</li>
</ul>
<blockquote>
<p>虚拟存储器的实现方法：<br>1、分页请求系统<br>2、分段请求系统<br>3、两种方式的结合</p>
</blockquote>
<p>而分区分配是指为如何用户程序分配内存空间的策略</p>
<p>分区是为用户程序<strong>分配内存</strong>的策略，不是<strong>虚拟存储</strong>的实现方法。</p>
<ul>
<li><p>假设某系统共有10台磁带机，有三个进程P1，P2，P3对磁带机的需求量分别是8，6，4台。设在T0时刻P1，P2，P3已分别获得3，4，1台，于是在T0时刻后存在的安全序列为（ **?**）。</p>
</li>
<li><p>```<br>（P1，P2，P3）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  （P3，P2，P1）</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>（P2，P3，P1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  （P2，P1，P3）</span><br></pre></td></tr></table></figure></li>
<li><pre><code>（P1，P3，P2）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 关于进程和线程，下列说法正确的是____</span><br><span class="line"></span><br><span class="line"> &#123;%asset_image image36.png%&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;txt</span><br><span class="line">A：进程是资源分配和拥有的单位</span><br><span class="line">C：线程是处理机调度和分配的单位</span><br><span class="line">B：进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</span><br><span class="line">E：每个线程拥有自己的堆栈，和自己的寄存器上下文</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<ul>
<li>两个线程并发执行以下代码，假设a是全局变量，初始值是1，那么以下输出中（）是可能的。</li>
</ul>
<blockquote>
<p>void<code> </code>foo ( )<br>{<br><code>++a; </code>printf<code>(</code>“%d”``,a);<br>}</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image37.png" class>

<blockquote>
<p>假设线程x和y同时执行，x和y可随时被抢占，a的初始值为1</p>
<p>A：3, 2<br>y先执行++a，a为2;<br>y再执行printf，a入栈，在打印到终端之前切换到x<br>x执行＋＋a，a为3;<br>x执行printf，输出3;再切换到y<br>y执行打印，输出2</p>
<p>B：2 3<br>x先执行＋＋a，a为2;<br>x再执行printf，输出2;切换到y<br>y执行＋＋a，a为3;<br>y执行printf，输出3;</p>
<p>C：3 3<br>x先执行＋＋a，a为2;切换到y<br>y执行＋＋a，a为3;<br>y执行printf，输出3;切换到x<br>x执行printf，输出3</p>
<p>D：2 2<br>类似C， 执行++a操作但没有写回到内存</p>
<p>这里关键有两点：<br>（1)两个线程可*<strong>随时被抢占***<br>（2)＋＋a和printf<strong>不是原子指令</strong>，可随时被打断；特别注意函数printf，a作为参数压栈后，*</strong>a再变化则不会影响输出*<strong>（printf实际打印的是压栈的参数，是值**<em>拷贝</em></strong>的栈变量）</p>
</blockquote>
<ul>
<li><p>以下关于Linux操作系统内存的描述中，正确的有（)</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image38.png" class>

<ul>
<li><p>A.<a href="%E8%8B%A5%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%BA2GB%EF%BC%8C%E5%88%99%E5%9C%A8%E8%AF%A5%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8BA%E5%92%8C%E8%BF%9B%E7%A8%8BB%E6%89%80%E5%8D%A0%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B9%8B%E5%92%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E5%A4%A7%E4%BA%8E2GB">点击访问</a>   32位下windows大概2g，而Linux3G，其余的都是给了内核【**<em>注意题中说是用户态地址空间**</em>】</p>
</li>
<li><p>B. [ <strong><em>?</em></strong> ]</p>
<blockquote>
<p>进程A和B都有自己的虚拟地址，程序在运行的时候在一个特定的时候并不会把所有需要的数据都加载到内存中，当前不使用的数据会被置换到硬盘上，只有在使用的时候才会被置换到内存中。因此，两个进程所占的物理存储之和完全有可能大于2GB。例如当进程A和B同时运行的时候，都只有部分数据被加载到内存中，假设在某一时刻A和B进程占用内存之和为2GB，如果此时A所需的数据不在内存中，此时系统采用特定的算法把进程A与B当前可能不使用的数据置换到硬盘上。因此，选项B正确。</p>
</blockquote>
</li>
<li><p>申请了1GB的内存，不一定会全部占用</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>下列软件中，属于系统软件的是（）。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image39.png" class>

</li>
</ul>
<blockquote>
<p>软件系统主要包括系统软件和应用软件。办公自动化软件、管理信息系统、指挥信息系统都是属于应用软件， Windows XP 属于系统软件，因此答案选择 B 。</p>
</blockquote>
<ul>
<li><p>进程A、B共享变量x，需要互斥执行；进程B、C共享变量y，B、C也需要互斥执行，因此进程A、C必须互斥执行    【错】</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在操作系统中，互斥没有传递性。在题目中，AC不存在资源竞争，以为着不需要互斥</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>( ) 被称为文本文件或 ACSII 文件。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image40.png" class>

</li>
</ul>
<blockquote>
<p>exe 可执行文件  软件一般有这样的应用程序</p>
<p>txt  文本文件 </p>
<p>doc  word 文本格式</p>
<p>com  可执行文件的内存映像</p>
</blockquote>
<ul>
<li><p>从执行状态挂起的进程解除挂起时进入()状态。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image41.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image42.png" class>



</li>
</ul>
<ul>
<li><p>采用动态重定位方式装入作业，在执行中允许（）将其移走</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image43.png" class>

</li>
</ul>
<blockquote>
<p><strong>动态重定位装入方式</strong>：</p>
<p>其运行环境：多道程序环境；</p>
<p>程序在运行过程中在内存的位置可能变动，装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正执行时才进行。说白了，动态重定位装入方式，是在程序执行时由CPU硬件进行地址重定位。</p>
<p>特点：程序在内存中可以浮动，不要求整个应用程序占用连续控件；为使地址转换不影响指令的执行速度，需要一个重定位寄存器的支持。</p>
<p>动态重定位分区分配是 内存为程序分配空间的一种分配方式。 可以将内存块进行搬移，将小块拼成大块，将小空闲“紧凑”成大空闲，腾出较大的内存以容纳新的程序进程。可以减少“碎片”，当然这种条件是**<em>系统完成的，并不是用户**</em>。</p>
</blockquote>
<blockquote>
<p><strong>可重定位装入方式</strong>：</p>
<p>运行环境：多道程序环境</p>
<p>程序目标模块的起始地址通常是从0开始的，程序中的其他地址也都是相对于起始地址计算的；根据内存的当前情况，将装入模块装入到内幕才能的适当位子；地址变换通常是装入时一次完成的，以后不再改变，所以是静态重定位。</p>
<p>特点：无需硬件支持；程序不能在内存中移动；要求程序的存储空间是连续的，不能把程序放在若干不连续区域</p>
<p><strong>绝对装入方式</strong>：</p>
<p>环境：使用单批道程序环境</p>
<p>绝对装入需要实现知道程序驻留在内存的位置，程序按照装入模块中的地址，将程序和数据装入内存。所以程序中的逻辑地址与实际地址完全相同，当操作系统把程序装入内存时，不需要对程序和数据进行地址修改；</p>
<p>特点：是CPU执行目标代码块，由于内存大小的限制，能装入内存并发执行的进程数大大减少。</p>
</blockquote>
<ul>
<li>在请求式分页系统中，缺页的中断率与程序结构无关。最短 CPU 执行期优先算法一定是剥夺式的。 【 <strong><em>false</em></strong> 】</li>
</ul>
<blockquote>
<p>第一个问题：false</p>
<p><strong>请求式分页</strong>也称虚拟页式存储管理，在进程开始运行之前不是装入全部页面，而是装入一个或零个页面之后根据进程运行的需要动态装入其他页面。</p>
<p>查页表时，当状态位指示该页不在主存时，则引起一个<strong>缺页中断</strong>发生，相应的中断程序把控制转向缺页中断子程序。————–<strong><em>缺页的中断率与程序结构有关</em></strong></p>
<h4 id="缺页中断率的因素有："><a href="#缺页中断率的因素有：" class="headerlink" title="缺页中断率的因素有："></a><strong>缺页中断率的因素有</strong>：</h4><p>①分配给作业的主存块数多则缺页率低，反之缺页中断率就高。<br>②页面大，缺页中断率低；页面小缺页中断率高。<br>③程序编制方法。以数组运算为例，如果每一行元素存放在一页中，则按行处理各元素缺页中断率低；反之，按列处理各元素，则缺页中断率高。<br>④页面调度算法对缺页中断率影响很大，但不可能找到一种最佳算法。</p>
<h4 id="第二个问题：false"><a href="#第二个问题：false" class="headerlink" title="第二个问题：false"></a><strong>第二个问题：false</strong></h4><h3 id="短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式"><a href="#短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式" class="headerlink" title="短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式"></a>短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式</h3><ul>
<li><strong>非抢占式（非剥夺式）调度</strong>：一旦进程拥有了CPU，只有当该CPU脉冲时间结束才会让出CPU的控制权。</li>
<li><strong>抢占式（剥夺式）调度</strong>：当有比当前进程剩余时间片更短的进程到来时，新来的进程抢占当前进程获得CPU运行。这种方式也被称为最短剩余时间优先调度（SRTF）。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
