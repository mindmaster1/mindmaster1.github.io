<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AOP</title>
    <url>/2021/03/14/AOP/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Ajax异步传输</title>
    <url>/2021/02/25/Ajax%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN</title>
    <url>/2021/03/14/CDN/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Docker虚拟容器入门</title>
    <url>/2021/03/14/Docker%E8%99%9A%E6%8B%9F%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Cookie</title>
    <url>/2021/02/25/Cookie/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Cookie</tag>
      </tags>
  </entry>
  <entry>
    <title>Druid数据库连接池</title>
    <url>/2021/03/14/Druid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Filter</title>
    <url>/2021/02/25/Filter/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP代理</title>
    <url>/2021/02/03/HTTP%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HTTP报文</title>
    <url>/2021/03/14/HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HTTP缓存</title>
    <url>/2021/02/03/HTTP%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>HTTP认证机制</title>
    <url>/2021/03/03/HTTP%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h2><p>认证就是给出一些身份证明，当然，不论哪一种认证策略都不是绝对有效的，但每种证据都有助于构建合理的信任。</p>
<h3 id="HTTP的质询-响应认证框架"><a href="#HTTP的质询-响应认证框架" class="headerlink" title="HTTP的质询/响应认证框架"></a>HTTP的质询/响应认证框架</h3><p>HTTP提供了一个原生的质询/响应框架（challenge/response），简化了对用户的认证过程。</p>
<h4 id="认证协议与首部"><a href="#认证协议与首部" class="headerlink" title="认证协议与首部"></a>认证协议与首部</h4><p>HTTP通过一组可定制的控制首部，为不同的认证协议提供了一个可扩展框架，认证协议也是在HTTP认证首部中指定的。</p>
<p>HTTP定义了两个官方的认证协议：</p>
<blockquote>
<p>基本认证</p>
</blockquote>
<blockquote>
<p>摘要认证</p>
</blockquote>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB存储引擎</title>
    <url>/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114112823026.png" alt="image-20210114112823026"></p>
<p>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池</p>
<p>后台线程的主要作用就是负责刷新内存池中的数据，保证缓存池中的内存缓存的是最近的数据。此外，还将已经修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下，InnoDB可以恢复运行到最佳状态。</p>
<h4 id="后台线程（InnDB是一个多线程模型"><a href="#后台线程（InnDB是一个多线程模型" class="headerlink" title="后台线程（InnDB是一个多线程模型)"></a>后台线程（InnDB是一个多线程模型)</h4><p>#####Master Thread</p>
<p><strong>作用：</strong></p>
<p>​    一个非常核心的后台进程，负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓存、UNDO页的回收等。</p>
<h5 id="IO-Therad"><a href="#IO-Therad" class="headerlink" title="IO Therad"></a>IO Therad</h5><p>  在InnoDB存储引擎中大量使用了AIO（Async IO）—异步时间非阻塞IO，这样可以极大程度上提高数据库的性能。IO Thread的主要工作就是负责这些IO请求的回调</p>
<p>共有四个IO Thread:write 、read、insert buffer、log IO thread</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114114130216.png" alt="image-20210114114130216"></p>
<p>通过命令SHOW ENGINE INNODB STASTUS\G来观察IO Thread</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114114405936.png" alt="image-20210114114405936"></p>
<p>有四个write和read IO Thread</p>
<p>通过innodb_read_io_threads和innodb_write_io_threads参数来进行设置</p>
<h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p><strong>作用</strong>：</p>
<p>​    Purge Thread回收已经使用并且已经分配的undo页（事务提交之后，其所使用的Undolog可能就不再需要）</p>
<p>用户需要在<strong>MySQL数据库的配置文件</strong>中添加如下命令来启用独立的Purge Thread: </p>
<p>​        innodb_purge_threads=1</p>
<h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p><strong>作用</strong>：</p>
<p>​    将脏页的刷新操作放在单独的线程中完成。减轻Master Thread的工作以及对于用户查询线程的阻塞</p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h5><p>Innodb存储引擎是基于磁盘存储的（Disk-base Database），将其中的记录按照页来管理。</p>
<p>缓存池的出现，就是为了解决CPU速度和磁盘速度之间的差异，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。读取文件时，首先判断给文件是否在缓存池中（没有就去磁盘上找）。</p>
<p>在修改缓存池中的页时，先以一定频率刷新到缓存池上，然后通过Checkpoint刷新回磁盘。</p>
<p>数据库服务器最好采用64位操作系统，可以使用更多的内存（512GB），32位（只有64GB）。</p>
<p>缓存池的配置通过参数innodb_buffer_pool_size来设置。</p>
<h6 id="缓存池中缓存的数据页类型："><a href="#缓存池中缓存的数据页类型：" class="headerlink" title="缓存池中缓存的数据页类型："></a>缓存池中缓存的数据页类型：</h6><p>​    索引页、数据页、Undo页、插入缓存页、自适应哈希索引页（adaptive hash index）、InnoDB存储的锁信息、数据字典信息等。</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114131120313.png" alt="image-20210114131120313"></p>
<p><strong>允许有多个缓存池实例</strong>：每个页根据hashcode平均分配到不同的缓存池实例中，减少数据库内部资源的竞争，增加数据库的并发能力。可以通过inodb_buffer_pool_instances来进行配置，通过命令SHOW ENGINE INNODB STATUS可以观察到每个缓存池实例对象运行的状态，还可以通过查看表InnoDB_BUFFER_POOL_STATS来观察缓存的状态(要求在information_schema架构下)</p>
<h5 id="LRU-LIST-、FREE-LIST-、FLUSH-LIST"><a href="#LRU-LIST-、FREE-LIST-、FLUSH-LIST" class="headerlink" title="LRU LIST 、FREE LIST 、FLUSH LIST"></a>LRU LIST 、FREE LIST 、FLUSH LIST</h5><p><strong>LRU</strong>算法用来管理已经读取的页</p>
<p>数据库中的缓存池是通过LRU（Latest Recent Used,最近最少使用）算法来管理内部的各种类型的页。</p>
<p><strong>LRU解释</strong>：将最频繁使用的页放在LRU列表的前端，最少使用的页放在LRU列表的尾端。当缓存池不能存放新读取到的页时，将优先删除列表尾端的页（默认大小为16KB）。</p>
<p><strong>改进</strong>：</p>
<p>1、（midpoint insertion strategy）：InnoDB中在LRU中加入了midpoint位置，将新读取到的页放在midpoint，而不是直接放在LRU列表首部。<strong>默认位置在LRU列表长度63%处</strong>（可以通过innodb_old_blocks_pct来控制）</p>
<p>2、设置了参数innodb_old_blocks_time,用于表示页读取到mid位置后需要等待多久才会加入到LRU列表的热端</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114133522544.png" alt="image-20210114133522544"></p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114133412580.png" alt="image-20210114133412580"></p>
<p><strong>为什么要对朴素的LRU算法进行改良</strong>？</p>
<h5 id="重做日志缓存"><a href="#重做日志缓存" class="headerlink" title="重做日志缓存"></a>重做日志缓存</h5><h5 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h5>]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>InnoDB存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC创建对象</title>
    <url>/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制反转（<strong>IoC，Inversion of Control</strong>），是一个概念，是一种思想。指将传统上由程序代 码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对 象控制权的转移，从程序代码本身反转到了外部容器。通过容器实现对象的创建，属性赋值， 依赖的管理。</p>
<p>IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式是依赖 注入。应用广泛。</p>
<blockquote>
<p>依赖注入</p>
</blockquote>
<p><strong>依赖</strong>：classA 类中含有 classB 的实例，在 classA 中调用 classB 的方法完成功能，即 classA 对 classB 有依赖。</p>
<blockquote>
<p>Ioc 的实现：</p>
</blockquote>
<p> ➢ 依赖注入：DI(Dependency Injection)，程序代码不做定位查询，这些工作由容器自行 完成。</p>
<p>依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，<u>由外部容器创建后传递给程序</u>。</p>
<p>Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持对象之间依赖关 的管理。</p>
<p>Spring 容器是一个超级大工厂，负责创建、管理所有的 Java 对象，这些 Java 对象被称为 Bean。Spring 容器管理着容器中 Bean 之间的依赖关系，Spring 使用“依赖注入”的方式 来管理 Bean 之间的依赖关系。使用 IoC 实现对象之间的解耦和。</p>
<h3 id="开发工具准备"><a href="#开发工具准备" class="headerlink" title="开发工具准备"></a>开发工具准备</h3><blockquote>
<p>开发工具：idea2017 以上  依赖管理：maven3 以上     jdk:1.8 以上</p>
</blockquote>
<p>需要设置maven本机仓库</p>
 <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/01.png" class>



<h3 id="Spring的第一个程序"><a href="#Spring的第一个程序" class="headerlink" title="Spring的第一个程序"></a>Spring的第一个程序</h3><h4 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h4> <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/02.png" class>



<h4 id="引入maven依赖pom-xml"><a href="#引入maven依赖pom-xml" class="headerlink" title="引入maven依赖pom.xml"></a>引入maven依赖pom.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="定义接口与实体类"><a href="#定义接口与实体类" class="headerlink" title="定义接口与实体类"></a>定义接口与实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SomeServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;SomeServiceImpl无参数构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;====业务方法doSome()===&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="创建spring配置文件"><a href="#创建spring配置文件" class="headerlink" title="创建spring配置文件"></a>创建spring配置文件</h4><p>在 src/main/resources/目录现创建一个 xml 文件，文件名可以随意，但 Spring 建议的名称为applicationContext.xml。</p>
<p>spring 配置中需要加入约束文件才能正常使用，约束文件是 xsd 扩展名。</p>
 <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/03.png" class>

<img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/04.png" class>

<p><bean>：用于定义一个实例对象。一个实例对应一个 bean 元素</bean></p>
<p><strong>id</strong>：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依 赖关系也是通过 id 属性关联的。</p>
<p><strong>class</strong>：指定该 Bean 所属的类，注意这里只能是类，不能是接口。</p>
<h4 id="定义测试类"><a href="#定义测试类" class="headerlink" title="定义测试类"></a>定义测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//spring创建对象默认调用的是类的无参数构造方法</span></span><br><span class="line"> <span class="comment">//使用spring创建好的对象</span></span><br><span class="line"> <span class="comment">//指定spring配置文件的名称</span></span><br><span class="line">     String config = <span class="string">&quot;beans.xml&quot;</span>;</span><br><span class="line"> <span class="comment">//创建表示spring容器的对象，ApplicationContext,表示spring容器，通过容器加载对象</span></span><br><span class="line">     <span class="comment">//ClassPathXmlApplicationContext:表示从类路径中加载spring的配置文件</span></span><br><span class="line">     ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(config);  <span class="comment">//Spring创建对象时机：在创建spring容器时，创建spring配置文件中的所有对象</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//从容器中获取对象，需要调用对象的方法</span></span><br><span class="line">     <span class="comment">//getbean(&quot;配置文件中的bean的id值&quot;),返回的是object类型，需要强转一下</span></span><br><span class="line">     SomeService service = (SomeService) ac.getBean(<span class="string">&quot;someService&quot;</span>);</span><br><span class="line"></span><br><span class="line">     service.dosome();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用spring创建非自定义类对象"><a href="#使用spring创建非自定义类对象" class="headerlink" title="使用spring创建非自定义类对象"></a>使用spring创建非自定义类对象</h4><p>spring 配置文件加入 java.util.Date 定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>MyTest 测试类中： 调用 getBean(“myDate”); 获取日期类对象。</p>
<h4 id="容器接口和实现类"><a href="#容器接口和实现类" class="headerlink" title="容器接口和实现类"></a>容器接口和实现类</h4><blockquote>
<p>ApplicationContext接口（容器）</p>
</blockquote>
<p>ApplicationContext 用于加载 Spring 的配置文件，在程序中充当“容器”的角色。其实现类有两个。</p>
 <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/05.png" class>



<ul>
<li><p>配置文件在类路径下</p>
<p>若 Spring 配置文件存放在项目的类路径下，则使用 ClassPathXmlApplicationContext 实现 类进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//spring配置文件在类路径下(classpath)</span></span><br><span class="line">    String resource = <span class="string">&quot;applicationContext.xml&quot;</span>;</span><br><span class="line">    ApplicationContext ac = ClassPathXmlApplicationContext(resource);</span><br><span class="line">    SomeService service = (SomeService) ac.getbean(<span class="string">&quot;someService&quot;</span>);</span><br><span class="line">    service.dosome();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>ApplicationContext容器中对象的装配时机</p>
<p>ApplicationContext 容器，会在容器对象初始化时，将其中的所有对象一次性全部装配好。 以后代码中若要使用到这些对象，只需从内存中直接获取即可。执行效率较高。但占用内存。</p>
</li>
<li><p>使用spring容器创建的Java对象</p>
<img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/06.png" class>



</li>
</ul>
<ul>
<li><p>使用spring提供的方法获取对象信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Spring容器中Java对象的信息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String config = <span class="string">&quot;beans.xml&quot;</span>;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(config); <span class="comment">//这里的参数传入不能加双引号</span></span><br><span class="line">        <span class="comment">//使用spring提供的方法，获取容器中定义的对象的数量与名称</span></span><br><span class="line">        <span class="keyword">int</span> nums = ac.getBeanDefinitionCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中定义的对象数量&quot;</span>+nums);</span><br><span class="line"></span><br><span class="line">        String[] beanDefinitionNames = ac.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span>(String name:beanDefinitionNames)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
















</li>
</ul>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB文件</title>
    <url>/2021/03/14/InnoDB%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>InnoDB表</title>
    <url>/2021/03/14/InnoDB%E8%A1%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>JVM虚拟机栈</title>
    <url>/2021/03/14/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java高并发JUC</title>
    <url>/2021/02/25/Java%E9%AB%98%E5%B9%B6%E5%8F%91JUC/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <url>/2021/02/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="1-内存管理那些事"><a href="#1-内存管理那些事" class="headerlink" title="1.内存管理那些事"></a>1.内存管理那些事</h3><p>C、C++：在内存管理领域，没有所谓的内存动态分配机制和垃圾收集技术，他们即拥有每一个对象的所有权，又担负着每一个对象从开始到终结的维护责任。</p>
<p>Java：在虚拟机自动内存管理机制的帮助下，不再需要为每一个new的对象写相配对的delete和free代码，也不容易出现内存泄漏和内存溢出的问题。</p>
<p>关于这两者之间对于内存管理之间的区别，从语言本身来说，指针的使用就可以表明二者在内存管理、使用、维护上的巨大差异。</p>
<h3 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2.运行时数据区域"></a>2.运行时数据区域</h3><p>Java虚拟机在执行Java程序的同时会把他创建的内存分为若干个不同的数据区域，如下图所示：</p>
<img data-src="/2021/02/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/%E6%95%B0%E6%8D%AE%E5%8C%BA.png" class>

<h4 id="2-1程序计数器-Program-Counter-Register"><a href="#2-1程序计数器-Program-Counter-Register" class="headerlink" title="2.1程序计数器(Program Counter Register)"></a>2.1程序计数器(Program Counter Register)</h4><p>这是一块较小的内存区域。可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，包括分支、循环、判断、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成。</p>
<p>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，在任何一个时刻，一个处理器指挥执行一条线程中的指令。<strong>为了线程切换后可以恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，且各个线程之间计数器互相不影响，独立存储</strong>。所以说程序计数器是线程私有的一块内存。</p>
<p><em>这是一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</em></p>
<ul>
<li><p>如果线程执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</p>
</li>
<li><p>如果正在执行的是Native方法，这个计数器值为空(Undefined)。</p>
</li>
</ul>
<h4 id="2-2Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#2-2Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="2.2Java虚拟机栈(Java Virtual Machine Stacks)"></a>2.2Java虚拟机栈(Java Virtual Machine Stacks)</h4><p>Java虚拟机栈是线程私有的，生命周期与线程相同。</p>
<blockquote>
<p>虚拟机栈描述的是**<em>Java方法**</em>执行的内存模型：每个方法在执行的同时会创建一个栈桢(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中从出栈到入栈。</p>
</blockquote>
<p>局部变量表存放了：</p>
<ul>
<li><p>编译时期可知的各种基本数据类型（boolean\byte\char\short\int\float\long\duoble）</p>
</li>
<li><p>对象引用（reference类型，不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄和其他与此对象相关的位置）</p>
</li>
<li><p>returnAddress类型(指向了一条字节码指令的地址)。</p>
</li>
</ul>
<p>该区域可能会出现的异常情况：</p>
<p>1.StackOverFlowError:线程请求的栈深度大于虚拟机所允许的深度</p>
<p>2.OutOfMemoryError: 如果虚拟机可以实现动态扩展，但是在扩展时无法申请到足够的内存。</p>
<p>####2.3本地方法栈(Native Method Stack)</p>
<p>本地方法栈与虚拟机栈发挥的作用很相似，区别就是虚拟机栈为虚拟机执行Java方法（也就是字节码服务），而本地方法作为虚拟机使用到的Native方法服务。具体的虚拟机可以自由实现。HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。它的异常类型同样是上述两种。</p>
<h4 id="2-4Java堆"><a href="#2-4Java堆" class="headerlink" title="2.4Java堆"></a>2.4Java堆</h4><p>Java堆(Java Heap)是Java虚拟机管理内存区域中最大的一块。Java堆是被所有线程共享的一块儿内存区域，在虚拟机启动时被创建。</p>
<p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong></p>
<p>Java堆是垃圾收集器管理的主要区域，被称为GC堆(Garbage Collected Heap)。</p>
<blockquote>
<p>从内存回收的角度来看，基于现在收集器基本上都采用分代收集算法，Java堆可以细分为新生代和老年代；再细致一点有Eden空间、From Survivor空间、To Survivor空间</p>
</blockquote>
<blockquote>
<p>从内存分配的角度来看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区(<strong>Thread Local Allocation Buffer   TLAB</strong>)。</p>
</blockquote>
<p><strong><em>不论如何划分，都与存放内容无关无论哪个区域，存放的都是对象实例</em></strong>，进一步划分的目的是为了更好的回收内存，或者更快的分配内存</p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续的即可。</p>
<p>在实现时，既可以实现成固定大小的，也可以是可扩展的，不过主流的虚拟机都是按照可扩展来实现的（控制参数：-Xmx和-Xms控制）。如果堆中没有内存可以完成实例分配，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。</p>
<h4 id="2-5方法区-Method-Area"><a href="#2-5方法区-Method-Area" class="headerlink" title="2.5方法区(Method Area)"></a>2.5方法区(Method Area)</h4><p>方法区与Java堆一样，是各个线程所共享的内存区域，<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述成为堆的一个逻辑部分，但是方法区还有一个别名叫做Non-Heap，目的就是与堆区分开。</p>
<p>Java虚拟机堆方法区的限制十分宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。但并非意味着数据进入了方法去就永久存在，这个区域的回收目标主要是针对常量池的回收和对类型的卸载，而回收的成绩难以令人满意，尤其是类型的卸载，条件更是相当苛刻，但是，<strong>这个区域的回收确实是必要的</strong>，可以一定程度上避免内存泄漏。</p>
<p>当方法区无法满足内存分配要求时，会报出OutOfMemoryError异常。</p>
<h4 id="2-6运行时常量池-Runtime-Constant-Pool"><a href="#2-6运行时常量池-Runtime-Constant-Pool" class="headerlink" title="2.6运行时常量池(Runtime Constant Pool)"></a>2.6运行时常量池(Runtime Constant Pool)</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项就是常量池(Constant Pool Table），用于存放<strong>编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<ul>
<li><p>对于运行时常量池，Java虚拟机规范并没有做任何细节的要求，不同的虚拟机提供厂商实现的虚拟机可以按站自己的需要来实现这个内存区域。除了保存Class文件中描述的符号引用外，还会将翻译的直接引用也存储在运行时常量池中。</p>
</li>
<li><p>运行时常量池相对于class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是说并非预置于Class文件中常量池的内容才可以进入方法去运行时常量池，运行期间也可能将新的常量放入池中。例如String类的intern()方法。</p>
</li>
<li><p>运行时常量池会受到方法区内存的限制，当常量池无法申请到内存是会报OutOfMemoryError异常。</p>
</li>
</ul>
<h4 id="2-7直接内存"><a href="#2-7直接内存" class="headerlink" title="2.7直接内存"></a>2.7直接内存</h4><p>直接内存就是本机的物理内存，服务器管理员在配置虚拟机参数时，要根据实际内存设置-Xmx等参数信息，避免使得各个内存区域大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>Java内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins自动化部署工具</title>
    <url>/2021/03/14/Jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>LVS负载均衡</title>
    <url>/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Leetcode树刷题总结</title>
    <url>/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h2><h3 id="题目说明："><a href="#题目说明：" class="headerlink" title="题目说明："></a>题目说明：</h3><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<p>示例:<br>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>      0 
     / \ 
   -3   9 
   /   / 
 -10  5 </code></pre>
<h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">在这道题中，left和right并不代表左右结点的值，而是相应节点在数组nums中的位置，这个在编写递归开始前的判断是很重要的。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//最小高度树的实现，在于找到中间节点来作为整棵树的根节点，这样构建的二叉树高度差是最小的。</span></span><br><span class="line">         <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;   </span><br><span class="line">         <span class="keyword">return</span> CreateMinitree(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">CreateMinitree</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要在递归的开始处增加必要的判断，防止数组越界和外节点</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right||right&gt;nums.length||left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入中间值作为父节点，随后插入左右子树</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">       TreeNode n = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        n.left = CreateMinitree(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        n.right = CreateMinitree(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h3 id="题目说明：-1"><a href="#题目说明：-1" class="headerlink" title="题目说明："></a>题目说明：</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]， </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h3 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeftHeight = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> maxRightHeight = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(maxLeftHeight,maxRightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="剑指offer27-二叉树的镜像"><a href="#剑指offer27-二叉树的镜像" class="headerlink" title="剑指offer27.二叉树的镜像"></a>剑指offer27.二叉树的镜像</h2><h3 id="题目说明：-2"><a href="#题目说明：-2" class="headerlink" title="题目说明："></a>题目说明：</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
 <img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/01.png" class>

<img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/02.png" class>



<h3 id="解法一：DFS递归"><a href="#解法一：DFS递归" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><ul>
<li>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</li>
</ul>
<h4 id="递归解析："><a href="#递归解析：" class="headerlink" title="递归解析："></a>递归解析：</h4><ul>
<li>**终止条件 **:当节点 root 为空时（即越过叶节点），则返回 null ；</li>
<li><strong>递推工作</strong>：<ul>
<li>初始化节点 tmp ，用于暂存 root 的左子节点；</li>
<li>开启递归右子节点mirrorTree(root,right)，并将返回值作为root的左子节点。</li>
<li>开启递归右子节点mirrorTree(root,left)，并将返回值作为root的右子节点。</li>
</ul>
</li>
<li><strong>返回值</strong>: 返回新构建的树的root结点。</li>
</ul>
<blockquote>
<p>Q：为何需要暂存root的左子节点？</p>
<p>A：在递归完成root的右子节点后，此时root.left的值已经发生改变，此时再进行递归左子树就会出现问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在暂时存储左子树的时候，一定要注意传入的是root.left，即左子树的第一个节点。不要再new TreeNode了；</span></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right  = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解法二：辅助栈"><a href="#解法二：辅助栈" class="headerlink" title="解法二：辅助栈"></a>解法二：辅助栈</h3><blockquote>
<ul>
<li>利用栈（或队列）遍历树的所有节点 node<em>n<strong>o</strong>d**e</em> ，并交换每个 node的左 / 右子节点。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="合并两棵二叉树"><a href="#合并两棵二叉树" class="headerlink" title="合并两棵二叉树"></a>合并两棵二叉树</h2><h3 id="题目概述："><a href="#题目概述：" class="headerlink" title="题目概述："></a>题目概述：</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="解法一：DFS深度优先搜索"><a href="#解法一：DFS深度优先搜索" class="headerlink" title="解法一：DFS深度优先搜索"></a>解法一：DFS深度优先搜索</h3><p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>
<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>
<p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p>
<p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p>
<p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p>
<p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对两棵树先进行判空</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将合并二叉树的根节点构造出来,并且开始递归，每合并完一个节点，还要递归的合并其左右子树。</span></span><br><span class="line">        TreeNode merged = <span class="keyword">new</span> TreeNode(root1.val+root2.val);</span><br><span class="line">        merged.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        merged.right = mergeTrees(root2.right ,root1.right );</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/03.png" class>



<h3 id="解法二：广度优先搜索BFS"><a href="#解法二：广度优先搜索BFS" class="headerlink" title="解法二：广度优先搜索BFS"></a>解法二：广度优先搜索BFS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</span><br><span class="line"></span><br><span class="line">如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</span><br><span class="line"></span><br><span class="line">使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</span><br><span class="line"></span><br><span class="line">如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</span><br><span class="line"></span><br><span class="line">如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</span><br><span class="line"></span><br><span class="line">如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</span><br><span class="line"></span><br><span class="line">对于右子节点和右子树，处理方法与左子节点和左子树相同。</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode merged = <span class="keyword">new</span> TreeNode(root1.val+root2.val);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向队列中添加元素</span></span><br><span class="line">        queue.offer(merged);</span><br><span class="line">        queue1.offer(root1);</span><br><span class="line">        queue2.offer(root2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty()&amp;&amp;!queue2.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue1.poll();</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            TreeNode node2 = queue2.poll();</span><br><span class="line"></span><br><span class="line">            TreeNode left1 = node1.left,left2 = node2.left,right1 = node1.right,right2 = node2.right;</span><br><span class="line">            <span class="keyword">if</span>(left1!=<span class="keyword">null</span> || left2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left1!=<span class="keyword">null</span>&amp;&amp;left2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    TreeNode left = <span class="keyword">new</span> TreeNode(left1.val+left2.val);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                    queue1.offer(left1);</span><br><span class="line">                    queue2.offer(left2);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.left = left1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.left = left2;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span>(right1!=<span class="keyword">null</span> || right2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right1!=<span class="keyword">null</span>&amp;&amp;right2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    TreeNode right = <span class="keyword">new</span> TreeNode(right1.val+right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                    queue1.offer(right1);</span><br><span class="line">                    queue2.offer(right2);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.right = right1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.right = right2;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/04.png" class>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程管理</title>
    <url>/2021/03/14/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Linux进程调度</title>
    <url>/2021/03/14/Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>MVC框架</title>
    <url>/2021/03/02/MVC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="MVC的定义"><a href="#MVC的定义" class="headerlink" title="MVC的定义"></a>MVC的定义</h2><p><strong>MVC模式</strong>（Model–view–controller）是软件工程中的一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">软件架构</a>模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<p><strong>MVC模式</strong>的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式透过对复杂度的简化，使程序结构更加直观。软件系统透过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。专业人员可以依据自身的专长分组。</p>
<ul>
<li><p>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</p>
</li>
<li><p>视图（View） - 界面设计人员进行图形界面设计。</p>
</li>
<li><p>控制器（Controller）- 负责转发请求，对请求进行处理。</p>






</li>
</ul>
<h2 id="MVC三者之间详细说明与联系"><a href="#MVC三者之间详细说明与联系" class="headerlink" title="MVC三者之间详细说明与联系"></a>MVC三者之间详细说明与联系</h2><p>###详细说明</p>
<p>MVC模式在概念上强调 Model, View, Controller 的分离，各个模块也遵循着由 Controller 来处理消息，Model 掌管数据源，View 负责资料显示的职责分离原则，因此在实现上，MVC 模式的 Framework 通常会将 MVC 三个部分分离实现：</p>
<blockquote>
<p>Model 负责资料访问，较现代的 Framework 都会建议使用独立的资料对象 (DTO, POCO, POJO 等) 来替代弱类型的集合对象。资料访问的代码会使用 Data Access 的代码或是 ORM-based Framework，也可以进一步使用 Repository Pattern 与 Unit of Works Pattern 来切割数据源的相依性。</p>
</blockquote>
<blockquote>
<p>Controller 负责处理消息，较高端的 Framework 会有一个默认的实现来作为 Controller 的基础，例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等，在职责分离原则的基础上，每个 Controller 负责的部分不同，因此会将各个 Controller 切割成不同的文件以利维护</p>
</blockquote>
<blockquote>
<p>View 负责显示资料，这个部分多为前端应用，而 Controller 会有一个机制将处理的结果 (可能是 Model, 集合或是状态等) 交给 View，然后由 View 来决定怎么显示。例如 Spring Framework 使用 JSP 或相应技术，ASP.NET MVC 则使用 Razor 处理资料的显示。</p>
</blockquote>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
<li>所有通信都是单向的。View和Model之间的通信是通过Controller来作为桥梁的，也就是说View和Model并不是直接通信；</li>
<li>需要服务器端配合，JavaScript可以在前端修改服务器渲染后的数据，所有通信都是单向的，提交一次反馈一次，通信一次相互制约。</li>
</ul>
<h2 id="MVC的优点与缺点"><a href="#MVC的优点与缺点" class="headerlink" title="MVC的优点与缺点"></a>MVC的优点与缺点</h2><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>多个 View 能共享一个 Model    <ul>
<li>同一个Web应用程序会提供多种用户界面，例如用户希望既能够通过浏览器来收发电子邮件 ，还希望通过手机来访问电子邮箱，这就要求Web网站同时能提供<a href="https://zh.wikipedia.org/wiki/Internet">Internet</a>界面和<a href="https://zh.wikipedia.org/wiki/WAP">WAP</a>界面。在MVC设计模式中， Model 响应用户请求并返回响应数据，View 负责格式化数据并把它们呈现给用户，业务逻辑和表示层分离，同一个 Model 可以被不同的 View 重用，所以大大提高了代码的可重用性。</li>
</ul>
</li>
<li>Controller 是自包含（self-contained,指高独立内聚）的对象，与 Model 和 View 保持相对独立，所以可以方便的改变应用程序的数据层和业务规则。<ul>
<li>把数据库从<a href="https://zh.wikipedia.org/wiki/MySQL">MySQL</a>移植到<a href="https://zh.wikipedia.org/wiki/Oracle">Oracle</a>，或者把<a href="https://zh.wikipedia.org/wiki/RDBMS">RDBMS</a>数据源改变成<a href="https://zh.wikipedia.org/wiki/LDAP">LDAP</a>数据源，只需改变 Model 即可。一旦正确地实现了控制器，不管数据来自数据库还是<a href="https://zh.wikipedia.org/wiki/LDAP">LDAP</a>服务器，View 都会正确地显示它们。由于MVC模式的三个模块相互独立，改变其中一个不会影响其他两个，所以依据这种设计思想能构造良好的少互扰性的构件，<strong>降低了耦合度</strong></li>
</ul>
</li>
<li>Controller 提高了应用程序的灵活性和可配置性<ul>
<li>Controller 可以用来连接不同的 Model 和 View 去完成用户的需求，也可以构造应用程序提供强有力的手段。给定一些可重用的 Model 、 View 和Controller 可以根据用户的需求选择适当的 Model 进行处理，然后选择适当的的 View 将处理结果显示给用户。</li>
</ul>
</li>
<li>增强了软件工程所要求的可测试性(Testablity)<ul>
<li>MVC-based 的应用程序在良好的职责分离的设计下，各个部分可独立行使<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a>，有利于与企业内的自动化测试、<a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">持续集成</a> (Continuous Integration) 与<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8C%81%E7%BA%8C%E7%99%BC%E8%A1%8C&action=edit&redlink=1">持续发行</a> (Continuous Delivery) 流程集成，减少应用程序改版部署所需的时间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>不适合小型中等规模的应用程序；</li>
<li>增加了系统结果和实现的复杂性；</li>
<li>View和Model之间不匹配，用户界面和流程要考虑易用性，用户体验优化同时考虑业务流程的精确和无错。</li>
<li>Controler和Model之间界线不清，什么样的逻辑是界面逻辑，什么样的逻辑是业务逻辑，很难定义清楚。没有明确的定义；</li>
<li>View的变化不能完全由Model控制，即Observer模式不足以支持复杂的用户交互。这其实要求VC之间要有依赖。牵一发而动全身，数据，显示不分离，Controller，Model联系过于紧密。</li>
</ul>
<h2 id="扩展：MVP"><a href="#扩展：MVP" class="headerlink" title="扩展：MVP"></a>扩展：MVP</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>MVP（Model-View-Presenter）是MVC的改良模式，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller/Presenter负责业务逻辑，Model管理数据，View负责显示。只不过是将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<h2 id="MVP的特点"><a href="#MVP的特点" class="headerlink" title="MVP的特点"></a>MVP的特点</h2><ul>
<li>M、V、P之间双向通信。</li>
<li>View 与 Model 不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
<li>Presenter与具体的View是没有直接关联的，而是通过<strong>定义好的接口</strong>进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。</li>
</ul>
<h3 id="MVP的优缺点"><a href="#MVP的优缺点" class="headerlink" title="MVP的优缺点"></a>MVP的优缺点</h3><blockquote>
<p>MVP的优点</p>
</blockquote>
<ul>
<li>模型与视图完全分离，我们可以修改视图而不影响模型；</li>
<li>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；</li>
<li>我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；</li>
<li>如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。</li>
</ul>
<blockquote>
<p>MVP的缺点</p>
</blockquote>
<p>视图和Presenter的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，presenter也要变更。</p>
]]></content>
      <categories>
        <category>项目架构</category>
      </categories>
      <tags>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Listener</title>
    <url>/2021/02/25/Listener/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Listener</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM框架</title>
    <url>/2021/03/02/MVVM%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>一个软件或者 APP都是服务于某种需求，这称之为“业务需求”。随着业务需求的增多、软件会变得越来越庞大，越来越复杂。所以就会设计一套完整的架构设计、研发流程以及质量管理体系来保证整个研发过程。“架构设计”是一个非常大的话题，它涉及到各方面，近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移，这里来谈谈——MVVM模式。</p>
<h2 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h2><blockquote>
<p>MVVM（Model–View–Viewmodel）是一种软件架构模式。<br>MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开，这是通过标记语言或GUI代码实现的。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/MVVM">想要了解更多关于MVVM的定义，点击访问维基百科</a></p>
<h2 id="MVVM涉及到的概念"><a href="#MVVM涉及到的概念" class="headerlink" title="MVVM涉及到的概念"></a>MVVM涉及到的概念</h2><ul>
<li>M(odel)层：模型，定义数据结构。</li>
<li>C(ontroller)层：实现业务逻辑，数据的增删改查。在MVVM模式中一般把C层算在M层中，（只有在理想的双向绑定模式下，Controller 才会完全的消失。这种理想状态一般不存在）</li>
<li>ViewModel层：顾名思义是视图View的模型、映射和显示逻辑（如if for等，非业务逻辑），另外绑定器也在此层。ViewModel是基于视图开发的一套模型，如果你的应用是给盲人用的，那么也可以开发一套基于Audio的模型AudioModel。</li>
<li>V(iew)层：将ViewModel通过特定的GUI展示出来，并在GUI控件上绑定视图交互事件，V(iew)一般由MVVM框架自动生成在浏览器中。</li>
</ul>
<h2 id="MVVM的工作机制"><a href="#MVVM的工作机制" class="headerlink" title="MVVM的工作机制"></a>MVVM的工作机制</h2><p>在MVVM架构下，View 和 Model 之间其实并没有直接的联系，而是通<strong>过ViewModel进行交互</strong>，Model 和 ViewModel 之间的交互是*<u>双向</u>*的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来。ViewModel里面包含DOM Listeners(数据监听)和Data Bindings(数据绑定)，DOM Listeners和Data Bindings是实现双向绑定的关键。</p>
<blockquote>
<p>DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；</p>
</blockquote>
<blockquote>
<p>Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</p>
</blockquote>
<img data-src="/2021/03/02/MVVM%E6%A1%86%E6%9E%B6/01.png" class>



<img data-src="/2021/03/02/MVVM%E6%A1%86%E6%9E%B6/02.png" class>



<h2 id="MVVM模式的优缺点"><a href="#MVVM模式的优缺点" class="headerlink" title="MVVM模式的优缺点"></a>MVVM模式的优缺点</h2><p>MVVM模式相较于原先的MVP模式至少省下30%编码量，甚至能省下70%DOM操作，因为用MVP模式的话主要是在进行DOM操作</p>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li><strong>低耦合</strong>。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>
<li><strong>可重用性</strong>。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。</li>
<li><strong>可测试性</strong>。可以针对ViewModel来对界面(View)进行测试</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>学习成本高。</li>
<li>DEBUG困难</li>
<li>实现MVVM的开销对于简单的UI操作是过度的。而对于更大的应用来说，推广ViewModel将变得更加困难，非常大的应用程序中的数据绑定会导致相当大的内存消耗。</li>
</ul>
<h2 id="MVVM应用场景"><a href="#MVVM应用场景" class="headerlink" title="MVVM应用场景"></a>MVVM应用场景</h2><ul>
<li>针对具有复杂交互逻辑的前端应用</li>
<li>提供基础的架构抽象</li>
<li>通过Ajax数据持久化，保证前端用户体验</li>
</ul>
<h2 id="常见的MVVM框架"><a href="#常见的MVVM框架" class="headerlink" title="常见的MVVM框架"></a>常见的MVVM框架</h2><p>Vue.js   AngularJs，ReactJs</p>
]]></content>
      <categories>
        <category>基础架构</category>
      </categories>
      <tags>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h2 id="IDEA编辑器集成maven环境"><a href="#IDEA编辑器集成maven环境" class="headerlink" title="IDEA编辑器集成maven环境"></a>IDEA编辑器集成maven环境</h2><p>###设置Maven版本</p>
<ul>
<li> 设置Maven版本–选择下载好的maven版本（⽬录选到bin⽬录的上⼀级⽬录）</li>
</ul>


 <img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven2.png" class>

<ul>
<li><p>设置settings.xml文件</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven3.png" class>

</li>
</ul>
<h3 id="Maven项目的创建"><a href="#Maven项目的创建" class="headerlink" title="Maven项目的创建"></a>Maven项目的创建</h3><ul>
<li><p>选择Maven,设置JDK版本，选择maven项目里的模板</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven4.png" class>
</li>
<li><p>设置项目里的GroupID和ArtifactID</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven5.png" class>
</li>
<li><p>检查项目的Maven环境</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven6.png" class>
</li>
<li><p>项目的目录结构</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven7.png" class>

</li>
</ul>
<p>###项目的编译</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven8.png" class>

<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven9.png" class>

<ul>
<li>执⾏编译命令，两个图标分别代表”普通模式”和”调试模式”</li>
</ul>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven10.png" class>

<h3 id="创建WEB项目"><a href="#创建WEB项目" class="headerlink" title="创建WEB项目"></a>创建WEB项目</h3><p>创建web项目与创建普通Java项目步骤基本一致，区别在于选择Maven模板（WEB项目选择webapp)</p>
<h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><ul>
<li><p>修改相关版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JDK的版本修改为1.8 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit的版本修改为4.12 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除pluginManagement标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将这个标签及标签中的内容全部删除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加web部署的插件</p>
<p>1.jetty插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置在plugins标签中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		 <span class="comment">&lt;!-- 热部署，每10秒扫描⼀次 --&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>10<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">		 <span class="comment">&lt;!-- 可指定当前项⽬的站点名 --&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">connectors</span>&gt;</span></span><br><span class="line">			 &lt;connector</span><br><span class="line">implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">port</span>&gt;</span>9090<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!-- 设置启动的端⼝号 --&gt;</span></span><br><span class="line"> 			 <span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">connectors</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  2.tomcat插件</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置在plugins标签中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!-- 启动端⼝ 默认:8080 --&gt;</span></span><br><span class="line"> 		 <span class="tag">&lt;<span class="name">path</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- 项⽬的站点名，即对外访问路径 --&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span> <span class="comment">&lt;!-- 字符集编码 默认：ISO-8859-1 --&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">server</span>&gt;</span>tomcat7<span class="tag">&lt;/<span class="name">server</span>&gt;</span> <span class="comment">&lt;!-- 服务器名称 --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven11.png" class>



<p>**maven依赖仓库：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a> **</p>
]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<h3 id="Maven仓库的基本概念"><a href="#Maven仓库的基本概念" class="headerlink" title="Maven仓库的基本概念"></a>Maven仓库的基本概念</h3><p> 当第⼀次运⾏Maven命令的时候， 你需要Internet链接， 因为它需要从⽹上下载⼀些⽂件。 那么它从 哪⾥下载呢？ 它是从Maven默认的远程库下载的。 这个远程仓库有Maven的核⼼插件和可供下载的jar⽂件。</p>
<p>对于Maven来说， 仓库只分为两类： 本地仓库和远程仓库。</p>
<p>当Maven根据坐标寻找构件的时候，它⾸先会查看本地仓库，如果本地仓库存在，则直接使⽤； 如果 本地没有，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使⽤。 如果本地仓库和远程仓库都没有，Maven就会报错。 </p>
<p>远程仓库分为三种： 中央仓库，私服， 其他公共库。</p>
<ul>
<li><p>中央仓库：默认配置下，Maven下载jar包的地⽅。</p>
<blockquote>
<p>由于原始的本地仓库是空的，maven必须知道⾄少⼀个可⽤的远程仓库，才能执⾏maven命令的时候 下载到需要的构件。中央仓库就是这样⼀个默认的远程仓库。 maven-model-builder-3.3.9.jar maven⾃动的 jar 中包含了⼀个 超级POM。定义了默认中央仓库的位 置。 中央仓库包含了2000多个开源项⽬，接收每天1亿次以上的访问</p>
</blockquote>
</li>
<li><p>私服：是另⼀种特殊的远程仓库，为了节省带宽和时间，应该在局域⽹内架设⼀个私有的仓库服务器， ⽤其代理所有外部的远程仓库。 内部的项⽬还能部署到私服上供其他项⽬使用</p>
<blockquote>
<p>私服是⼀种特殊的远程仓库，它是架设在局域⽹内的仓库服务， 私服代理⼴域⽹上的远程仓库，供局 域⽹内的maven⽤户使⽤。 当maven需要下载构件时， 它去私服当中找，如果私服没有， 则从外部远 程仓库下载，并缓存在私服上， 再为maven提供。 此外，⼀些⽆法从外部仓库下载的构件也能从本地上传到私服提供局域⽹中其他⼈使⽤</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.0.96:8081/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>getui-nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span>       				<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mvn.gt.igexin.com/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>公司内部为何需要建立私服：</p>
<blockquote>
<p>节省⾃⼰的外⽹带宽 加速maven构建 部署第三⽅控件 提⾼稳定性 降低中央仓库的负荷</p>
</blockquote>
<p>常用的阿里云仓库配置，需要修改settings.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p>⼀般来说，在Maven项⽬⽬录下，没有诸如lib/这样⽤来存放依赖⽂件的⽬录。 当Maven在执⾏编译或 测试时，如果需要使⽤依赖⽂件，它总是基于坐标使⽤本地仓库的依赖⽂件。</p>
<p>每个⽤户在⾃⼰的⽤户⽬录下都有⼀个路径名为.m2/repository/的仓库⽬录。 有时候， 因为某些原因（⽐如c盘空间不⾜）,需要修改本地仓库⽬录地址。</p>
<p>对于仓库路径的修改，可以通过maven 配置⽂件conf ⽬录下settings.xml来指定仓库路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置到指定⽬录中，路径的斜杆不要写反 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="Maven依赖的基本概念"><a href="#Maven依赖的基本概念" class="headerlink" title="Maven依赖的基本概念"></a>Maven依赖的基本概念</h3><p>根元素project下的dependencies可以包含多个 dependence元素，以声明多个依赖。每个依赖都应该包含以下元素：</p>
<ol>
<li><p>groupId, artifactId, version : 依赖的基本坐标， 对于任何⼀个依赖来说，基本坐标是最重要的， Maven根据坐标才能找到需要的依赖。</p>
</li>
<li><p>Type： 依赖的类型，⼤部分情况下不需要声明。 默认值为jar</p>
</li>
<li><p>Scope： 依赖范围（compile,test,provided,runtime,system）</p>
</li>
</ol>
<blockquote>
<p>compile：编译依赖范围</p>
</blockquote>
<p>如果没有指定，就会默认使⽤该依赖范围。使⽤此依赖范围的Maven依赖，对于编译、测 试、运⾏三种classpath都有效。</p>
<blockquote>
<p>test：测试依赖范围</p>
</blockquote>
<p>使⽤此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运⾏项⽬的使 ⽤时将⽆法使⽤此类依赖。典型的例⼦就是JUnit，它只有在编译测试代码及运⾏测试的时候才需要</p>
<blockquote>
<p>provided：已提供依赖范围</p>
</blockquote>
<p>使⽤此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运⾏时⽆效。典型的例 ⼦是servlet-api，编译和测试项⽬的时候需要该依赖，但在运⾏项⽬的时候，由于容器已经提供，就不需要Maven重复地引⼊⼀遍(如：servlet-api)。</p>
<blockquote>
<p>runtime：运行时依赖范围</p>
</blockquote>
<p>使⽤此依赖范围的Maven依赖，对于测试和运⾏classpath有效，但在编译主代码时⽆效。典 型的例⼦是JDBC驱动实现，项⽬主代码的编译只需要JDK提供的JDBC接⼝，只有在执⾏测 试或者运⾏项⽬的时候才需要实现上述接⼝的具体JDBC驱动。</p>
<blockquote>
<p>system：系统依赖范围</p>
</blockquote>
<p>该依赖与三种classpath的关系，和provided依赖范围完全⼀致。但是，使⽤system范围依赖 时必须通过systemPath元素显式地指定依赖⽂件的路径。由于此类依赖不是通过Maven仓库 解析的，⽽且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使⽤。</p>
<ol start="4">
<li><p>Optional：标记依赖是否可选</p>
</li>
<li><p>Exclusions： ⽤来排除传递性依赖。</p>
</li>
</ol>
<h3 id="Maven依赖的依赖范围"><a href="#Maven依赖的依赖范围" class="headerlink" title="Maven依赖的依赖范围"></a>Maven依赖的依赖范围</h3><p>⾸先需要知道，Maven在编译项⽬主代码的时候需要使⽤⼀套classpath。 ⽐如：编译项⽬代码的时候 需要⽤到spring-core, 该⽂件以依赖的⽅式被引⼊到classpath中。 其次， Maven在执⾏测试的时候会使 ⽤另外⼀套classpath。 如：junit。</p>
<p>最后在实际运⾏项⽬时，⼜会使⽤⼀套classpath， spring-core需要在该classpath中，⽽junit不需要。</p>
<p>那么依赖范围就是⽤来控制依赖与这三种classpath(编译classpath，测试classpath，运⾏时classpath)的 关系， Maven有以下⼏种依赖范围：<strong>（如上所述）</strong></p>
<h3 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h3><p>传递依赖机制， 让我们在使⽤某个jar的时候就不⽤去考虑它依赖了什么。也不⽤担⼼引⼊多余的依 赖。 Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引⼊到当前项⽬中。</p>
<p><strong>注意：传递依赖有可能产生冲突</strong></p>
<p>冲突场景”</p>
<blockquote>
<p>A–&gt;B—&gt;C (2.0) </p>
<p>A–&gt;E—&gt;C (1.0)</p>
</blockquote>
<p>如果A下同时存在两个不同version的C，冲突！！（选取同时适合A、B的版本）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis动态代理与传参</title>
    <url>/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="Mybatis动态代理实现CURD"><a href="#Mybatis动态代理实现CURD" class="headerlink" title="Mybatis动态代理实现CURD"></a>Mybatis动态代理实现CURD</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote>
<p>去掉Dao接口的实现类</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/01.png" class>

<blockquote>
<p>getMapper获取代理对象</p>
</blockquote>
<p>只需调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。该方法的参数为指定 Dao 接口类的 class 值。(<strong>反射原理</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = factory.openSession();</span><br><span class="line">StudentDao dao = session.getMapper(StudentDao.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用工具类获取session</span></span><br><span class="line">StudentDao studentDao =</span><br><span class="line">MyBatisUtil.getSqlSession().getMapper(StudentDao.class);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>使用Dao代理对象方法执行SQL语句</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s所有的方法必须都在StudentDao接口中有所定义</span></span><br><span class="line"><span class="comment">//select 方法:</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> List&lt;Student&gt; studentList = studentDao.selectStudents();</span><br><span class="line">     studentList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert 方法:</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1006</span>);</span><br><span class="line">     student.setName(<span class="string">&quot;林浩&quot;</span>);</span><br><span class="line">     student.setEmail(<span class="string">&quot;linhao@163.com&quot;</span>);</span><br><span class="line">     student.setAge(<span class="number">26</span>);</span><br><span class="line">     <span class="keyword">int</span> nums = studentDao.insertStudent(student);</span><br><span class="line">     System.out.println(<span class="string">&quot;使用 Dao 添加数据:&quot;</span>+nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//update 方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1006</span>);</span><br><span class="line">     student.setAge(<span class="number">28</span>);</span><br><span class="line">     <span class="keyword">int</span> nums = studentDao.updateStudent(student);</span><br><span class="line">     System.out.println(<span class="string">&quot;使用 Dao 修改数据:&quot;</span>+nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//delete 方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> nums = studentDao.deleteStudent(<span class="number">1006</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;使用 Dao 修改数据:&quot;</span>+nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="基于动态代理的原理分析"><a href="#基于动态代理的原理分析" class="headerlink" title="基于动态代理的原理分析"></a>基于动态代理的原理分析</h4><img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/02.png" class>



<blockquote>
<p>MapperProxy类定义</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/03.png" class>

<blockquote>
<p>invoke方法</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/04.png" class>



<blockquote>
<p>重点方法</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/05.png" class>





<h2 id="深入理解参数"><a href="#深入理解参数" class="headerlink" title="深入理解参数"></a>深入理解参数</h2><blockquote>
<p>parameterType</p>
</blockquote>
<p>parameterType: 接口中方法参数的类型， 值是类型的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以推断出具体传入语句的参数，默认值为未设置（unset）。接口中方法的参数从 java 代码传入到 mapper 文件的 sql 语句。</p>
<p>支持传入参数的类型与别名映射如表所示：</p>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/06.png" class>



<p> <select>、<insert>、<update>、<delete>都可以使用parameterType指定类型</delete></update></insert></select></p>
  <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/07.png" class>



<h3 id="Mybatis传递参数"><a href="#Mybatis传递参数" class="headerlink" title="Mybatis传递参数"></a>Mybatis传递参数</h3><h4 id="一个简单参数"><a href="#一个简单参数" class="headerlink" title="一个简单参数"></a>一个简单参数</h4><p>Dao 接口中方法的参数只有一个简单类型（java 基本类型和 String），占位符 #{ 任意字符 }，和方法的参数名无关。</p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectById&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line"> select id,name,email,age from student where id=#&#123;studentId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">#&#123;studentId&#125; , studentId 是自定义的变量名称，和方法参数名无关。#表示占位符</span><br></pre></td></tr></table></figure>


<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入了一个参数</span></span><br><span class="line">    Student student = studentDao.selectById(<span class="number">1005</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查询 id 是 1005 的学生：&quot;</span>+student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><h4 id="使用-Param"><a href="#使用-Param" class="headerlink" title="使用@Param"></a>使用@Param</h4><p>当 Dao 接口方法多个参数，需要通过名称使用参数。在方法形参前面加入@Param(“自定义参数名”)， mapper 文件使用#{自定义参数名}。</p>
<ul>
<li>接口方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">selectMultiParam</span><span class="params">(<span class="meta">@Param(&quot;personName&quot;)</span> String name, <span class="meta">@Param(&quot;personAge&quot;)</span> <span class="keyword">int</span> age)</span></span>; </span><br></pre></td></tr></table></figure>


<ul>
<li><p>mapper 文件： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select id,name,email,age from student where name=#&#123;personName&#125; or age =#&#123;personAge&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectMultiParam</span><span class="params">()</span></span>&#123; </span><br><span class="line">    List stuList = studentDao.selectMultiParam(<span class="string">&quot;李力&quot;</span>,<span class="number">20</span>); 					stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="多个参数–适用对象"><a href="#多个参数–适用对象" class="headerlink" title="多个参数–适用对象"></a>多个参数–适用对象</h4><p>使用 java 对象传递参数， java 的属性值就是 sql 需要的参数值。 每一个属性就是一个参数。 语法格式： #{ property,javaType=java 中数据类型名,jdbcType=数据类型名称 } javaType, jdbcType 的类型 MyBatis 可以检测出来，一般不需要设置。常用格式 #{ property }</p>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/08.png" class>

<blockquote>
<p>创建保存参数值的对象QueryParam</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.vo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryParam</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String queryName;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> queryAge;</span><br><span class="line"> <span class="comment">//set ，get 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectMultiObject</span><span class="params">(QueryParam queryParam)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件—-必须保证和对象的属性名相同</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectMultiObject&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line"> select id,name,email,age from student where name=#&#123;queryName&#125; or age=#&#123;queryAge&#125;</span><br><span class="line">&lt;/select</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectMultiObject&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line"> select id,name,email,age from student</span><br><span class="line"> where name=#&#123;queryName,javaType=string,jdbcType=VARCHAR&#125;</span><br><span class="line"> or age =#&#123;queryAge,javaType=int,jdbcType=INTEGER&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectMultiObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam qp = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     qp.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     qp.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectMultiObject(qp);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="多个参数–按照位置"><a href="#多个参数–按照位置" class="headerlink" title="多个参数–按照位置"></a>多个参数–按照位置</h4><p>参数位置从 0 开始， 引用参数语法 #{ arg 位置 } ， 第一个参数是#{arg0}, 第二个是#{arg1} 注意：mybatis-3.3 版本和之前的版本使用#{0},#{1}方式， 从 mybatis3.4 开始使用#{arg0}方式&gt;。</p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectByNameAndAge</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByNameAndAge&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">	 select id,name,email,age from student where name=#&#123;arg0&#125; or age =#&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByNameAndAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//按位置参数</span></span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectByNameAndAge(<span class="string">&quot;李力&quot;</span>,<span class="number">20</span>);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="多个参数–使用Map"><a href="#多个参数–使用Map" class="headerlink" title="多个参数–使用Map"></a>多个参数–使用Map</h4><p>Map 集合可以存储多个值，使用Map向 mapper 文件一次传入多个参数。Map 集合使用 String的 key， Object 类型的值存储参数。 mapper 文件使用 # { key } 引用参数值。</p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectMultiMap</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">	 select id,name,email,age from student where name=#&#123;myname&#125; or age =#&#123;myage&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">//通过key来传递参数</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectMultiMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Map&lt;String,Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     data.put(<span class="string">&quot;myname&quot;</span>,<span class="string">&quot;李力&quot;</span>);<span class="comment">// #&#123;myname&#125;</span></span><br><span class="line">     data.put(<span class="string">&quot;myage&quot;</span>,<span class="number">20</span>); <span class="comment">// #&#123;myage&#125;</span></span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectMultiMap(data);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储参数的类型是Object</span></span><br></pre></td></tr></table></figure>


<h3 id="占位符-和"><a href="#占位符-和" class="headerlink" title="占位符#和$"></a>占位符#和$</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>#：占位符，告诉 mybatis 使用实际的参数值代替。并使用 PrepareStatement 对象执行 sql 语句, #{…}代替 sql 语句的“?”。这样做更安全，更迅速，通常也是首选做法，</p>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">	 select id,name,email,age from student where id=#&#123;studentId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>转换为Mybatis的执行是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">String <span class="keyword">sql</span><span class="operator">=</span>” <span class="keyword">select</span> id,name,email,age <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">=</span>?”;</span><br><span class="line">PreparedStatement ps <span class="operator">=</span> conn.prepareStatement(<span class="keyword">sql</span>);</span><br><span class="line">ps.setInt(<span class="number">1</span>,<span class="number">1005</span>);</span><br></pre></td></tr></table></figure>


<h4 id="-1"><a href="#-1" class="headerlink" title="$"></a>$</h4><p> $ 字符串替换，告诉 mybatis 使用$包含的“字符串”替换所在位置。使用 Statement 把 sql 语句和${}的 内容连接起来。主要用在替换表名，列名，不同列排序等操作。</p>
<p><strong>因为存在拼接的操作，所以可能会存在SQL注入的安全隐患</strong></p>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/09.png" class>

 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/10.png" class>











]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记&lt;一&gt;</title>
    <url>/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Maven的简介"><a href="#Maven的简介" class="headerlink" title="Maven的简介"></a>Maven的简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> Maven【[ˈmevən]】这个词可以翻译为”专家”,”内⾏”。 作为Apache组织中的⼀个颇为成功的开源项⽬， Maven主要服务于基于java平台的项⽬构建，依赖管理和项⽬信息管理。 ⽆论是⼩型的开源类库项⽬，还是⼤型的企业级应⽤； ⽆论是传统的瀑布式开发，还是流⾏的敏捷开 发，Maven都能⼤显身⼿。</p>
<p>###项目构建</p>
<p>不管你是否意识到，构建（build）是每⼀位程序员每天都在做的⼯作。早上来到公司，我们做的第⼀ 件事就是从源码库签出最新的代码，然后进⾏单元测试，如果测试失败，会找相关的同事⼀起调试修复错误代码。 接着回到⾃⼰的⼯作上来，编写⾃⼰的单元测试及产品代码。</p>
<p>我们会发现，除了编写源代码，我们每天有相当⼀部分时间花在了编译，运⾏单元测 试，⽣成⽂档，打包和部署等繁琐且不起眼的⼯作上，这就是构建。 如果我们现在还⼿⼯这样做，那成 本也太⾼了，于是有⼈⽤软件的⽅法让这⼀系列⼯作完全⾃动化，使得软件的构建可以像全⾃动流⽔线 ⼀样，只需要⼀条简单的命令，w所有繁琐的步骤都能够⾃动完成，很快就能得到最终结果。</p>
<p>###项目构建工具</p>
<blockquote>
<p>Ant构建</p>
</blockquote>
<p>最早的构建⼯具，基于IDE, ⼤概是2000年有的，当时是最流⾏java构建⼯具，不过它的XML脚本编写格式让XML⽂件特别⼤。对⼯程构建过程中的过程控制特别好。</p>
<blockquote>
<p>Maven【Java】</p>
</blockquote>
<p>项⽬对象模型，通过其描述信息来管理项⽬的构建，报告和⽂档的软件项⽬管理⼯具。它填补了Ant缺 点，Maven第⼀次⽀持了从⽹络上下载的功能，仍然采⽤xml作为配置⽂件格式。Maven专注的是依赖管理，使⽤Java编写。</p>
<blockquote>
<p>Gradle</p>
</blockquote>
<p>属于结合以上两个的优点，它继承了Ant的灵活和Maven的⽣命周期管理，它最后被google作为了 Android御⽤管理⼯具。它最⼤的区别是不⽤XML作为配置⽂件格式，采⽤了DSL格式，使得脚本更加简洁。 ⽬前市⾯上Ant⽐较⽼, 所以⼀般是⼀些⽐较传统的软件企业公司使⽤, Maven使⽤Java编写, 是当下⼤多数互联⽹公司会使⽤的⼀个构建⼯具, 中⽂⽂档也⽐较⻬全, gradle是⽤groovy编写, ⽬前⽐较新型的构建⼯具⼀些初创互联⽹公司会使⽤, 以后会有很⼤的使⽤空间。</p>
<h3 id="Maven的四大特性"><a href="#Maven的四大特性" class="headerlink" title="Maven的四大特性"></a>Maven的四大特性</h3><h4 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h4><p> Maven为Java世界引⼊了⼀个新的依赖管理系统jar包管理 jar 升级时修改配置⽂件即可。在Java世界中，可以⽤<strong>groupId、artifactId、version</strong>组成的Coordination（坐标）<u>唯⼀标识⼀个依赖。</u></p>
<p>任何基于Maven构建的项⽬⾃身也必须定义这三项属性，⽣成的包可以是Jar包，也可以是war包或者 jar包。⼀个典型的依赖引⽤如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> com.baidu</span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> ueditor echarts</span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>坐标属性的理解</p>
</blockquote>
<ul>
<li><strong>groupId</strong></li>
</ul>
<p>定义当前Maven项⽬⾪属的实际项⽬-公司名称。(jar包所在仓库路径） 由于Maven中模块的概念，因 此⼀个实际项⽬往往会被划分为很多模块。 ⽐如spring是⼀个实际项⽬，其对应的Maven模块会有很 多，如spring-core,spring-webmvc等。</p>
<ul>
<li><strong>artifactId</strong></li>
</ul>
<p>该元素定义实际项⽬中的⼀个Maven模块-项⽬名， 推荐的做法是使⽤实际项⽬名称作为artifactId的前 缀。 ⽐如： spring-bean, spring-webmvc等。</p>
<ul>
<li><strong>version</strong></li>
</ul>
<p>该元素定义Maven当前所处的版本</p>
<h4 id="项目的多模块构建"><a href="#项目的多模块构建" class="headerlink" title="项目的多模块构建"></a>项目的多模块构建</h4><p>项⽬复查时 dao service controller 层分离将⼀个项⽬分解为多个模块已经是很通⽤的⼀种⽅式。 在Maven中需要定义⼀个parent POM作为⼀组module的聚合POM。在该POM中可以使⽤ 标签来定义⼀ 组⼦模块。parent POM不会有什么实际构建产出。⽽parent POM中的build配置以及依赖配置都会⾃动继承给⼦module。</p>
<h4 id="一致的构建模型和插件机制"><a href="#一致的构建模型和插件机制" class="headerlink" title="一致的构建模型和插件机制"></a>一致的构建模型和插件机制</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>10<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="Maven的安装配置和目录结构"><a href="#Maven的安装配置和目录结构" class="headerlink" title="Maven的安装配置和目录结构"></a>Maven的安装配置和目录结构</h2><h3 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h3><img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/createmaven.png" class>

<p>打开cmd窗口，通过命令查看maven是否安装成功</p>
<img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/maventest.png" class>

<h3 id="认识Maven的目录结构"><a href="#认识Maven的目录结构" class="headerlink" title="认识Maven的目录结构"></a>认识Maven的目录结构</h3> <img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mulu.png" class>

<h4 id="创建一个文件夹作为项目的根目录"><a href="#创建一个文件夹作为项目的根目录" class="headerlink" title="创建一个文件夹作为项目的根目录"></a>创建一个文件夹作为项目的根目录</h4><ul>
<li><p>在根目录中创建一个pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string"> http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xxxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven01<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>PS:标签定义解释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">根⽬录下的第⼀个⼦元素 ModelVersion指定当前Pom模型的版本，对于Maven3来说，它只能是4.0.0 。指定了当前Maven模型的版本号，对于Maven2和Maven3来说，它只能是4.0.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">groupId:定义了项目属于哪一个组，这个组通常和项目所在的组织和公司存在关联</span></span><br><span class="line"><span class="comment">比如：com.xxxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">artifactId 定义了当前Maven项⽬在组中唯⼀的ID。</span></span><br><span class="line"><span class="comment">Version X.X.X-⾥程碑</span></span><br><span class="line"><span class="comment">⽐如：1.0.0-SNAPSHOT</span></span><br><span class="line"><span class="comment">第⼀个X ⼤版本 有重⼤变⾰</span></span><br><span class="line"><span class="comment">第⼆个X ⼩版本 修复bug，增加功能</span></span><br><span class="line"><span class="comment">第三个X 更新</span></span><br><span class="line"><span class="comment">⾥程碑版本：</span></span><br><span class="line"><span class="comment">SNAPSHOT （快照，开发版）</span></span><br><span class="line"><span class="comment">alpha（内部测试）</span></span><br><span class="line"><span class="comment">beta（公开测试）</span></span><br><span class="line"><span class="comment">Release | RC（ 发布版）</span></span><br><span class="line"><span class="comment">GA（正常版本）</span></span><br><span class="line"><span class="comment">使⽤name标签声明⼀个对于⽤户更为友好的项⽬名称，虽然不是必须的，但还是推荐为每个Pom声明name，以⽅便信息交流。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>


<h4 id="编写主函数"><a href="#编写主函数" class="headerlink" title="编写主函数"></a>编写主函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxxx.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;hello maven&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="cmd下编译并且运行"><a href="#cmd下编译并且运行" class="headerlink" title="cmd下编译并且运行"></a>cmd下编译并且运行</h4><p>cmd下面，进入项目根目录</p>
<p>1.编译Java文件</p>
<p>mvn compile</p>
<p>2.执行main方法</p>
<p>mvn exec:java -Dexec.mainClass=”com.xxxx.demo.hello”</p>
<img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mavencreate.png" class>

<p><strong>注：第⼀次下载会⽐较慢，要修改maven解压之后的conf⽬录下的settings.xml。</strong></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.1.修改默认仓库位置</span><br><span class="line">打开maven⽬录 -&gt; conf -&gt; settings.xml</span><br><span class="line">添加仓库位置配置</span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>F:/m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">注：仓库位置改为⾃⼰本机的指定⽬录，&quot;/&quot;不要写反</span><br><span class="line">1.2.更换阿⾥镜像,加快依赖下载</span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果编译不成功，可能出现的问题</p>
<blockquote>
<p>1.不是使用管理员权限执行的dos命令</p>
</blockquote>
<blockquote>
<p>2.JDK环境配置有问题，重装JDK</p>
</blockquote>
<blockquote>
<p>3.代码编写时，类里面没有设置包名</p>
</blockquote>
<p>##Maven命令</p>
<p>作为开发利器的maven，为我们提供了⼗分丰富的命令，了解maven的命令⾏操作并熟练运⽤常⻅的 maven命令还是⼗分必要的，即使譬如IDEA等⼯具给我提供了图形界⾯化⼯具，但其底层还是依靠 maven命令来驱动的。</p>
<p>Maven的命令格式如下：</p>
<blockquote>
<p>maven [plugin-name] : [goal-name]</p>
</blockquote>
<p>命令代表的含义：执⾏ plugin-name 插件的 goal-name ⽬标</p>
<table>
<thead>
<tr>
<th align="left">maven命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mvn clean</td>
<td>清理项⽬⽣产的临时⽂件,⼀般是模块下的target⽬录</td>
</tr>
<tr>
<td align="left">mvn compile</td>
<td>编译源代码，⼀般编译模块下的src/main/java⽬录</td>
</tr>
<tr>
<td align="left">mvn package</td>
<td>项⽬打包⼯具,会在模块下的target⽬录⽣成jar或war等⽂件</td>
</tr>
<tr>
<td align="left">mvn test</td>
<td>测试命令,或执⾏src/test/java/下junit的测试⽤例</td>
</tr>
<tr>
<td align="left">mvn -version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td align="left">mvn install</td>
<td>将打包的jar/war⽂件复制到你的本地仓库中,供其他模块使⽤</td>
</tr>
<tr>
<td align="left">mvn deploy</td>
<td>将打包的⽂件发布到远程参考,提供其他⼈员进⾏下载依赖</td>
</tr>
<tr>
<td align="left">mvn site</td>
<td>生成项目相关信息的网站</td>
</tr>
<tr>
<td align="left">mvn eclipse:eclipse</td>
<td>将项目转换为Eclipse项目</td>
</tr>
<tr>
<td align="left">mvn dependency:tree</td>
<td>打印出整个项目的依赖树</td>
</tr>
<tr>
<td align="left">mvn archetype:generate</td>
<td>创建maven的普通Java项目</td>
</tr>
<tr>
<td align="left">mvn tomcat:run</td>
<td>在tomcat容器中运行web应用</td>
</tr>
<tr>
<td align="left">mvn jetty:run</td>
<td>调用jetty插件的Run目标在jetty servlet容器中启动web应用</td>
</tr>
</tbody></table>
<p>注意：运⾏maven命令的时候，⾸先需要定位到maven项⽬的⽬录，也就是项⽬的pom.xml⽂件所在的⽬录。否则， 必以通过参数来指定项⽬的⽬录。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p>上⾯列举的只是⽐较通⽤的命令，其实很多命令都可以携带参数以执⾏更精准的任务。</p>
<h4 id="D传入属性参数"><a href="#D传入属性参数" class="headerlink" title="-D传入属性参数"></a>-D传入属性参数</h4><p>例如： </p>
<blockquote>
<p>mvn package -Dmaven.test.skip=true </p>
</blockquote>
<p>以 -D 开头，将 maven.test.skip 的值设为 true ,就是告诉maven打包的时候跳过单元测试。同 理， mvn deploy-Dmaven.test.skip=true 代表部署项⽬并跳过单元测试。</p>
<h4 id="P使用指定的Profile配置"><a href="#P使用指定的Profile配置" class="headerlink" title="-P使用指定的Profile配置"></a>-P使用指定的Profile配置</h4><p>⽐如项⽬开发需要有多个环境，⼀般为开发，测试，预发，正式4个环境，在pom.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">env</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span>&gt;</span>qa<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">env</span>&gt;</span>qa<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span>&gt;</span>pre<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">env</span>&gt;</span>pre<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">env</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">filter</span>&gt;</span>config/$&#123;env&#125;.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"> ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>profiles 定义了各个环境的变量 id ， filters 中定义了变量配置⽂件的地址，其中地址中的环境 变量就是上⾯ profile 中定义的值， resources 中是定义哪些⽬录下的⽂件会被配置⽂件中定义的变量替换。 通过maven可以实现按不同环境进⾏打包部署，例如：</p>
<blockquote>
<p>mvn package -Pdev -Dmaven.test.skip=true</p>
</blockquote>
]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB数据库</title>
    <url>/2021/02/25/MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Mybatis框架</title>
    <url>/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6-1/</url>
    <content><![CDATA[<h2 id="Mybatis入门案例"><a href="#Mybatis入门案例" class="headerlink" title="Mybatis入门案例"></a>Mybatis入门案例</h2><h3 id="搭建Mybatis开发环境–基础CRUD操作实例"><a href="#搭建Mybatis开发环境–基础CRUD操作实例" class="headerlink" title="搭建Mybatis开发环境–基础CRUD操作实例"></a>搭建Mybatis开发环境–基础CRUD操作实例</h3><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><blockquote>
<p>创建MySQL数据库和表</p>
</blockquote>
<img data-src="/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6-1/01.png" class>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建Maven工程，并且在pom.xml中加入maven坐标</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   	 	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>加入maven插件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span><span class="comment">&lt;!--所在的目录--&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">includes</span>&gt;</span><span class="comment">&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;</span></span><br><span class="line"> 			 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>/&gt;</span> </span><br></pre></td></tr></table></figure>


<blockquote>
<p>编写Student实体类</p>
</blockquote>
<p>创建包com.bytedance.domain,包中创建Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.domain;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Description: 实体类 &lt;/p&gt;</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Company: http://www.bjpowernode.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"> <span class="comment">//属性名和列名一样</span></span><br><span class="line">     <span class="keyword">private</span> Integer id;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> String email;</span><br><span class="line">     <span class="keyword">private</span> Integer age;</span><br><span class="line">     <span class="comment">// set ,get , toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写Dao接口 StudentDao</p>
</blockquote>
<p>创建包com.bytedance.dao,创建StudentDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.dao;</span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.domain.Student;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Description: Dao 接口 &lt;/p&gt;</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Company: http://www.bjpowernode.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">	 <span class="comment">/*查询所有数据*/</span></span><br><span class="line">	 <span class="function">List&lt;Student&gt; <span class="title">selectStudents</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写Dao接口Mapper映射文件StudentDao.xml</p>
<p>要求：</p>
<ul>
<li> 在 dao 包中创建文件 StudentDao.xml </li>
<li>要 StudentDao.xml 文件名称和接口 StudentDao 一样，区分大小写的一样</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">     <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">     <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     namespace：必须有值，自定义的唯一字符串</span></span><br><span class="line"><span class="comment">     推荐使用：dao 接口的全限定名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.bytedance.dao.StudentDao&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 		&lt;select&gt;: 查询数据， 标签中必须是 select 语句</span></span><br><span class="line"><span class="comment"> 			id: sql 语句的自定义名称，推荐使用 dao 接口中方法名称，使用名称表示要执行的 sql 语句</span></span><br><span class="line"><span class="comment"> 		resultType: 查询语句的返回结果数据类型，使用全限定类名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bytedance.domain.Student&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--要执行的 sql 语句--&gt;</span></span><br><span class="line">         select id,name,email,age from student</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建Mybatis主配置文件</p>
</blockquote>
<p>项目 src/main 下创建 resources 目录，设置 resources 目录为 resources root 创建主配置文件：名称为 mybatis.xml 说明：主配置文件名称是自定义的，内容如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">     <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">     <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--配置 mybatis 环境--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--id:数据源的名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务类型：使用 JDBC 事务（使用 Connection 的提交和回滚）--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据源 dataSource：创建数据库 Connection 对象</span></span><br><span class="line"><span class="comment">        type: POOLED 使用数据库的连接池</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库的四个要素--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--告诉 mybatis 要执行的 sql 语句的位置--&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/bytedance/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建测试类</p>
</blockquote>
<p> src/test/java/com/bytedance/ 创建 MyBatisTest.java 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mybatis 入门</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStart</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象,目的是获取 SqlSession</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession,SqlSession 能执行 sql 语句</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.执行 SqlSession 的 selectList()</span></span><br><span class="line">     List&lt;Student&gt; studentList = 	session.selectList(<span class="string">&quot;com.bytedance.dao.StudentDao.selectStudents&quot;</span>);</span><br><span class="line">    <span class="comment">//6.循环输出查询结果</span></span><br><span class="line">	 studentList.forEach( student -&gt; System.out.println(student));</span><br><span class="line"> 	<span class="comment">//7.关闭 SqlSession，释放资源</span></span><br><span class="line">	 session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置日志功能</p>
</blockquote>
<p>mybatis.xml 文件加入日志配置，可以在控制台输出执行的 sql 语句和参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><ul>
<li><p>StudentDao 接口中增加方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int insertStudent(Student student);</span><br></pre></td></tr></table></figure></li>
<li><p>StudentDao.xml中加入SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">（<span class="number">2</span>） StudentDao.xml 加入 <span class="keyword">sql</span> 语句</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> id<span class="operator">=</span>&quot;insertStudent&quot;<span class="operator">&gt;</span></span><br><span class="line"> 	<span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,email,age)</span><br><span class="line">	values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;)</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">insert</span><span class="operator">&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>增加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.创建保存数据的对象</span></span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1005</span>);</span><br><span class="line">     student.setName(<span class="string">&quot;张丽&quot;</span>);</span><br><span class="line">     student.setEmail(<span class="string">&quot;zhangli@163.com&quot;</span>);</span><br><span class="line">     student.setAge(<span class="number">20</span>);</span><br><span class="line">     <span class="comment">//6.执行插入 insert</span></span><br><span class="line">     <span class="keyword">int</span> rows = session.insert(</span><br><span class="line">    <span class="string">&quot;com.bytedance.dao.StudentDao.insertStudent&quot;</span>,student);</span><br><span class="line">     <span class="comment">//7.提交事务</span></span><br><span class="line">     session.commit();</span><br><span class="line">     System.out.println(<span class="string">&quot;增加记录的行数:&quot;</span>+rows);</span><br><span class="line">     <span class="comment">//8.关闭 SqlSession</span></span><br><span class="line">     session.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><ul>
<li><p>StudentDao接口中增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateStudent</span><span class="params">(Student student)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>StudentDao.xml文件中增加SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> id<span class="operator">=</span>&quot;updateStudent&quot;<span class="operator">&gt;</span></span><br><span class="line"> 	update student set age = #&#123;age&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>增加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.创建保存数据的对象</span></span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1005</span>);<span class="comment">//要修改的 id</span></span><br><span class="line">     student.setAge(<span class="number">30</span>); <span class="comment">//要修改的年龄值</span></span><br><span class="line">     <span class="comment">//6.执行更新 update</span></span><br><span class="line">     <span class="keyword">int</span> rows = session.update(</span><br><span class="line">    <span class="string">&quot;com.bytedance.dao.StudentDao.updateStudent&quot;</span>,student);</span><br><span class="line">     <span class="comment">//7.提交事务</span></span><br><span class="line">     session.commit();</span><br><span class="line">     System.out.println(<span class="string">&quot;修改记录的行数:&quot;</span>+rows);</span><br><span class="line">     <span class="comment">//8.关闭 SqlSession</span></span><br><span class="line">     session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul>
<li><p>StudentDao接口中增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteStudent</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>StudentDao.xml文件中增加SQL语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteStudent&quot;</span>&gt;</span></span><br><span class="line"> delete from student where id=#&#123;studentId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>增加测试方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.删除的 id</span></span><br><span class="line">     <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">     <span class="comment">//6.执行删除 delete</span></span><br><span class="line">     <span class="keyword">int</span> rows = session.delete(</span><br><span class="line">    <span class="string">&quot;com.bytedance.dao.StudentDao.deleteStudent&quot;</span>,id);</span><br><span class="line">     <span class="comment">//7.提交事务</span></span><br><span class="line">     session.commit();</span><br><span class="line">     System.out.println(<span class="string">&quot;修改记录的行数:&quot;</span>+rows);</span><br><span class="line">    <span class="comment">//8.关闭SqlSession</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架概述</title>
    <url>/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="软件开发常用结构"><a href="#软件开发常用结构" class="headerlink" title="软件开发常用结构"></a>软件开发常用结构</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>三层架构包含的三层： 界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）</p>
<blockquote>
<p>三层的职责</p>
</blockquote>
<ul>
<li><p>1、界面层（表示层\视图层）：主要功能是接受用户的数据，显示请求的处理结果。使用 web 页面和 用户交互，手机 app 也就是表示层的，用户在 app 中操作，业务逻辑在服务器端处理。</p>
</li>
<li><p>2、业务逻辑层：接收表示传递过来的数据，检查数据，计算业务逻辑，调用数据访问层获取数据。</p>
</li>
<li><p>3、数据访问层（持久层）：与数据库打交道。主要实现对数据的增、删、改、查。将存储在数据库中的数据提交 给业务层，同时将业务层处理的数据保存到数据库。</p>
</li>
</ul>
<p>三层的处理请求的交互：</p>
<p>用户—&gt;界面层—&gt;业务逻辑层—&gt;数据访问层—&gt;DB数据库</p>
 <img data-src="/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6/01.png" class>



<blockquote>
<p>为什么使用三层？</p>
</blockquote>
<p>1，结构清晰、耦合度低, 各层分工明确 </p>
<p>2，可维护性高，可扩展性高</p>
<p> 3，有利于标准化 </p>
<p>4，开发人员可以只关注整个结构中的其中某一层的功能实现 </p>
<p>5，有利于各层逻辑的复用</p>
<h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><ul>
<li><p>Mybatis框架</p>
<p>MyBatis 是一个优秀的基于 java 的持久层框架，内部封装了 jdbc，开发者只需要关注 sql 语句本身，而不需要处理加载驱动、创建连接、创建 statement、关闭连接，资源等繁杂的过程。 MyBatis 通过 xml 或注解两种方式将要执行的各种 sql 语句配置起来，并通过 java 对象和 sql 的 动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p>
</li>
<li><p>Spring框架</p>
<p>Spring 框架为了解决软件开发的复杂性而创建的。Spring 使用的是基本的 JavaBean 来完成以前 非常复杂的企业级开发。Spring 解决了业务对象，功能模块之间的耦合，不仅在 javase,web 中使用， 大部分 Java 应用都可以从 Spring 中受益。 Spring 是一个轻量级控制反转(IoC)和面向切面(AOP)的容器。</p>
</li>
<li><p>SpringMVC框架</p>
<p>SpringMVC 框架 Spring MVC 属于 SpringFrameWork 3.0 版本加入的一个模块，为 Spring 框架提供了构建 Web 应用程序的能力。现在可以 Spring 框架提供的 SpringMVC 模块实现 web 应用开发，在 web 项目中 可以无缝使用 Spring 和 Spring MVC 框架。</p>
</li>
</ul>
<h2 id="框架的定义"><a href="#框架的定义" class="headerlink" title="框架的定义"></a>框架的定义</h2><h3 id="框架定义"><a href="#框架定义" class="headerlink" title="框架定义"></a>框架定义</h3><p>框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种认为，框架是可被应用开发者定制的应用骨架、模板。 简单的说，框架其实是半成品软件，就是一组组件，供你使用完成你自己的系统。从另一个角度来 说框架一个舞台，你在舞台上做表演。在框架基础上加入你要完成的功能。 框架安全的，可复用的，不断升级的软件。 </p>
<h3 id="框架解决的问题"><a href="#框架解决的问题" class="headerlink" title="框架解决的问题"></a>框架解决的问题</h3><p>框架要解决的最重要的一个问题是技术整合，在 J2EE 的 框架中，有着各种各样的技术，不同的应用，系统使用不同的技术解决问题。需要从 J2EE 中选择不同的技术，而技术自身的复杂性，有导致更大的风险。企业在开发软件项目时，主要目的是解决业务问题。 即要求企业负责技术本身，又要求解决业务问题。这是大多数企业不能完成的。框架把相关的技术融合在一起，企业开发可以集中在业务领域方面。 另一个方面可以提供开发的效率。</p>
<h2 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	Connection conn = <span class="keyword">null</span>;</span><br><span class="line"> 	Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> 		<span class="comment">//注册 mysql 驱动</span></span><br><span class="line">		 Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		 <span class="comment">//连接数据的基本信息 url ，username，password</span></span><br><span class="line">		 String url = <span class="string">&quot;jdbc:mysql://localhost:3306/springdb&quot;</span>;</span><br><span class="line">		 String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		 String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"> 		<span class="comment">//创建连接对象</span></span><br><span class="line">		 conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">		 <span class="comment">//保存查询结果</span></span><br><span class="line">		 List&lt;Student&gt; stuList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> 		<span class="comment">//创建 Statement, 用来执行 sql 语句</span></span><br><span class="line"> 		stmt = conn.createStatement();</span><br><span class="line"> 		<span class="comment">//执行查询，创建记录集，</span></span><br><span class="line"> 		rs = stmt.executeQuery(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">		 <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">			 Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">			 stu.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">			 stu.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">			 stu.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">			 <span class="comment">//从数据库取出数据转为 Student 对象，封装到 List 集合</span></span><br><span class="line">			 stuList.add(stu);</span><br><span class="line">			 &#125;</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			 e.printStackTrace();</span><br><span class="line">	    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;</span><br><span class="line">				 <span class="comment">//关闭资源</span></span><br><span class="line">                 <span class="keyword">if</span> (rs != <span class="keyword">null</span>) ;</span><br><span class="line"> 				&#123;</span><br><span class="line">					 rs.close();</span><br><span class="line">				 &#125;</span><br><span class="line"> 				<span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line"> 					stmt.close();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				<span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"> 					conn.close();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				 e.printStackTrace();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用JDBC的缺陷"><a href="#使用JDBC的缺陷" class="headerlink" title="使用JDBC的缺陷"></a>使用JDBC的缺陷</h3><ol>
<li>代码比较多，开发效率低 </li>
<li> 需要关注 Connection ,Statement, ResultSet 对象创建和销毁 </li>
<li> 对 ResultSet 查询的结果，需要自己封装为 List </li>
<li> 重复的代码比较多些 </li>
<li> 业务代码和数据库的操作混在一起</li>
</ol>
<h2 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h2><p>MyBatis 框架：</p>
<p> MyBatis 本是 apache 的一个开源项目 iBatis, 2010 年这个项目由 apache software foundation 迁 移到了 google code，并且改名为 MyBatis 。2013 年 11 月迁移到 Github。 iBATIS 一词来源于“internet”和“abatis”的组合，是一个基于 Java 的持久层框架。iBATIS 提供的 持久层框架包括 SQL Maps 和 Data Access Objects（DAOs） 当前，最新版本是 MyBatis 3.5.1 ，其发布时间是 2019 年 4 月 8 日。</p>
<h3 id="Mybatis框架解决的主要问题"><a href="#Mybatis框架解决的主要问题" class="headerlink" title="Mybatis框架解决的主要问题"></a>Mybatis框架解决的主要问题</h3><p>减轻使用 JDBC 的复杂性，不用编写重复的创建 Connetion , Statement ; 不用编写关闭资源代码。 直接使用 java 对象，表示结果数据。让开发者专注 SQL 的处理。 其他分心的工作MyBatis 代劳。</p>
<p> MyBatis 可以完成：  </p>
<ul>
<li>注册数据库的驱动，例如 Class.forName(“com.mysql.jdbc.Driver”))</li>
<li>创建 JDBC 中必须使用的 Connection ， Statement， ResultSet 对象</li>
<li>从 xml 中获取 sql，并执行 sql 语句，把 ResultSet 结果转换 java 对象</li>
<li>关闭资源 ResultSet.close() , Statement.close() , Conenection.close()</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis入门案例知识补充</title>
    <url>/2021/03/07/Mybatis%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h2 id="不使用XML构建SqlSessionFactory"><a href="#不使用XML构建SqlSessionFactory" class="headerlink" title="不使用XML构建SqlSessionFactory"></a>不使用XML构建SqlSessionFactory</h2><p>如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置建造器，MyBatis 也<strong>提供了完整的配置类</strong>，提供了所有与 XML 文件等价的配置项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line"><span class="comment">//指定事务类型</span></span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line"><span class="comment">//添加一个映射器类,相较于XML文件构建存在一定的局限性</span></span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line"><span class="comment">//构造SqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure>
<p>注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们**<u>包含 SQL 映射注解从而避免依赖 XML 文件</u>**。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 配置。有鉴于此，如果存在一个同名 XML 配置文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。</p>
<h2 id="从SqlSessionFactory中获取SqlSession"><a href="#从SqlSessionFactory中获取SqlSession" class="headerlink" title="从SqlSessionFactory中获取SqlSession"></a>从SqlSessionFactory中获取SqlSession</h2><p> 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(SqlSession session = SqlSessionFactory.opensession())&#123;</span><br><span class="line">	 Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种更加简洁的方式</p>
</blockquote>
<p>使用和指定语句的参数和返回值**<u>相匹配的接口</u>**（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">//传参的时候传了一个接口</span></span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="探究已经映射的SQL语句"><a href="#探究已经映射的SQL语句" class="headerlink" title="探究已经映射的SQL语句"></a>探究已经映射的SQL语句</h2><p>粗略的讨论一下SqlSession和Mapper到底执行了什么操作</p>
<p>一个语句既可以通过 XML 定义，也可以通过注解定义。我们先看看 XML 定义语句的方式，事实上 MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。下面是一个XML文件示例</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span><br><span class="line">  &lt;select id=<span class="string">&quot;selectBlog&quot;</span> resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<p>为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 XML 映射文件中，可以定义无数个映射语句，这样一来，XML 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句了，就像上面例子中那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：此时org.mybatis.example.BlogMapper应该是一个接口</li>
<li>selectBlog是接口中定义的一个方法</li>
</ul>
<p>你可能会注意到，这种方式和用全限定名调用 Java 对象的方法类似。这样，该命名就可以<strong>直接映射到在命名空间中同名的映射器类</strong>，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<p>第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在之前版本的 MyBatis 中，<strong>命名空间（Namespaces）</strong>的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。</p>
<p>命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p>
<p><strong>命名解析：</strong>为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ul>
<li>全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。</li>
<li>短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。</li>
</ul>
<hr>
<p>对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</p>
<p>选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。</p>
<h2 id="作用域和生命周期"><a href="#作用域和生命周期" class="headerlink" title="作用域和生命周期"></a>作用域和生命周期</h2><blockquote>
<p>对象生命周期和依赖注入框架</p>
</blockquote>
<p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。</p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h3 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h3><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat</title>
    <url>/2021/03/14/Mycat/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Nginx服务器的使用</title>
    <url>/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Nginx服务器使用"><a href="#Nginx服务器使用" class="headerlink" title="Nginx服务器使用"></a>Nginx服务器使用</h1><h2 id="内容概览"><a href="#内容概览" class="headerlink" title="内容概览"></a>内容概览</h2><h3 id="1、nginx简介"><a href="#1、nginx简介" class="headerlink" title="1、nginx简介"></a>1、nginx简介</h3><p>（1）介绍nginx的应用场景和具体可以做什么事情</p>
<p>（2）介绍什么是反向代理</p>
<p>（3）介绍什么是负载均衡</p>
<p>（4)介绍什么是动静分离</p>
<h3 id="nginx的安装"><a href="#nginx的安装" class="headerlink" title="nginx的安装"></a>nginx的安装</h3><p>1、介绍nginx在linux系统中如何安装</p>
<p>###nginx常用的命令和配置文件</p>
<p>（1）介绍nginx启动·、关闭、重新加载命令</p>
<p>（2）介绍nginx的配置文件</p>
<h3 id="nginx配置实例—反向代理"><a href="#nginx配置实例—反向代理" class="headerlink" title="nginx配置实例—反向代理"></a>nginx配置实例—反向代理</h3><h3 id="nginx配置实例—负载均衡"><a href="#nginx配置实例—负载均衡" class="headerlink" title="nginx配置实例—负载均衡"></a>nginx配置实例—负载均衡</h3><p>###nginx配置实例—动静分离</p>
<h3 id="nginx原理与优化参数配置"><a href="#nginx原理与优化参数配置" class="headerlink" title="nginx原理与优化参数配置"></a>nginx原理与优化参数配置</h3><h3 id="搭建nginx高可用集群"><a href="#搭建nginx高可用集群" class="headerlink" title="搭建nginx高可用集群"></a>搭建nginx高可用集群</h3><p>（1）搭建nginx高可用集群（主从模式）</p>
<p>（2）搭建nginx高可用集群（双主模式）</p>
<h2 id="PART1—Nginx简介"><a href="#PART1—Nginx简介" class="headerlink" title="PART1—Nginx简介"></a>PART1—Nginx简介</h2><h3 id="1-1-Nginx概述"><a href="#1-1-Nginx概述" class="headerlink" title="1.1  Nginx概述"></a>1.1  Nginx概述</h3><p>Nginx (“engine x”) 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能 力强，事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用 nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等</p>
<h3 id="1-2-Nginx作为Web服务器"><a href="#1-2-Nginx作为Web服务器" class="headerlink" title="1.2  Nginx作为Web服务器"></a>1.2  Nginx作为Web服务器</h3><p>Nginx 可以作为<strong>静态页面</strong>的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php 等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发， 性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高 达 50,000 个并发连接数。</p>
<h3 id="1-3-正向代理的概念"><a href="#1-3-正向代理的概念" class="headerlink" title="1.3 正向代理的概念"></a>1.3 正向代理的概念</h3><p>Nginx 不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117084318892.png" alt="image-20210117084318892"></p>
<h3 id="1-4-反向代理的概念"><a href="#1-4-反向代理的概念" class="headerlink" title="1.4 反向代理的概念"></a>1.4 反向代理的概念</h3><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117084508055.png" alt="image-20210117084508055"></p>
<h3 id="1-5-负载均衡"><a href="#1-5-负载均衡" class="headerlink" title="1.5  负载均衡"></a>1.5  负载均衡</h3><p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服 务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，<strong>并发请求相对较少的情况下</strong>是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂 度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易 造成服务器直接崩溃。很明显这是由于*<strong>服务器性能的瓶颈造成*<strong>的问题，那么如何解决这种情 况呢？ 我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机 器的物理性能来解决此问题，<u>但是我们知道摩尔定律的日益失效</u>，硬件的性能提升已经不能 满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量 是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能 够满足需求的。那么怎么办呢？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题 的办法行不通了，那么横向增加服务器的数量呢？这时候</strong>集群*<em>的概念产生了，单个服务器解 决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们 所说的</em></strong>负载均衡***</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117084802102.png" alt="image-20210117084802102"></p>
<h3 id="1-5-动静分离"><a href="#1-5-动静分离" class="headerlink" title="1.5   动静分离"></a>1.5   动静分离</h3><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。（所谓静态页面：html    css    javascript，动态页面：PHP   JSP   serverlet）</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117085005870.png" alt="image-20210117085005870"></p>
<h2 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h2><p>###1、Nginx官网下载</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117085204993.png" alt="image-20210117085204993"></p>
<p>###2.2 安装 nginx </p>
<p>第一步，安装 pcre wget <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz">http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</a></p>
<p>解压文件， ./configure 完成后，回到 pcre 目录下执行 make， 再执行 make install</p>
<p>第二步，安装 openssl </p>
<p>第三步，安装 zlib yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</p>
<p>第四步，安装 nginx </p>
<p>1、 解压缩 nginx-xx.tar.gz 包。 2、 进入解压缩目录，执行./configure。 3、 make &amp;&amp; make install</p>
<p>查看开放的端口号 firewall-cmd –list-all </p>
<p>设置开放的端口号 firewall-cmd –add-service=http –permanent sudo firewall-cmd –add-port=80/tcp –permanent</p>
<p> 重启防火墙 firewall-cmd –reload</p>
<h2 id="Nginx常用的命令和配置文件"><a href="#Nginx常用的命令和配置文件" class="headerlink" title="Nginx常用的命令和配置文件"></a>Nginx常用的命令和配置文件</h2><h3 id="3-1-Nginx常用命令"><a href="#3-1-Nginx常用命令" class="headerlink" title="3.1 Nginx常用命令"></a>3.1 Nginx常用命令</h3><p>（1）启动命令</p>
<p>在/usr/local/nginx/sbin 目录下执行 ./nginx </p>
<p>（2）关闭命令</p>
<p>在/usr/local/nginx/sbin 目录下执行 ./nginx -s stop </p>
<p>（3）重新加载命令</p>
<p>在/usr/local/nginx/sbin/目录下执行 ./nginx -s reload</p>
<h3 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h3><p>nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117085805608.png" alt="image-20210117085805608"></p>
<p>配置文件中有很多#， 开头的表示注释内容，我们去掉所有以 # 开头的段落，精简之后的 内容如下：</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117085856062.png" alt="image-20210117085856062"></p>
<p>根据上述文件，我们可以很明显的将 nginx.conf 配置文件分为三部分：</p>
<h4 id="第一部分：全局块"><a href="#第一部分：全局块" class="headerlink" title="第一部分：全局块"></a>第一部分：全局块</h4><p> 从配置文件开始到 events 块之间的内容，主要会设置一些影响 <strong>nginx 服务器整体运行的配置指令</strong>，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。 比如上面第一行配置的：</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117090005617.png" alt="image-20210117090005617"></p>
<p>这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约。</p>
<h3 id="第二部分：events块"><a href="#第二部分：events块" class="headerlink" title="第二部分：events块"></a>第二部分：events块</h3><p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117090054927.png" alt="image-20210117090054927"></p>
<p>events 块涉及的指令主要影响<strong>Nginx 服务器与用户的网络连接</strong>，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。 上述例子就表示每个 work process 支持的最大连接数为 1024. 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p>
<h3 id="第三部分：HTTP块"><a href="#第三部分：HTTP块" class="headerlink" title="第三部分：HTTP块"></a>第三部分：HTTP块</h3><p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117090239168.png" alt="image-20210117090239168"></p>
<p>这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 <strong>http 全局块、server 块。</strong></p>
<p>####http 全局块 </p>
<p>http 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</p>
<h4 id="server块"><a href="#server块" class="headerlink" title="server块"></a>server块</h4><p> 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而<strong>每个 server 块就相当于一个虚拟主机</strong>。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p>
<h5 id="全局server块"><a href="#全局server块" class="headerlink" title="全局server块"></a>全局server块</h5><p> 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。</p>
<h5 id="location块"><a href="#location块" class="headerlink" title="location块"></a>location块</h5><p>这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是 IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p>
<h2 id="Nginx配置实例—反向代理"><a href="#Nginx配置实例—反向代理" class="headerlink" title="Nginx配置实例—反向代理"></a>Nginx配置实例—反向代理</h2><h3 id="反向代理示例一："><a href="#反向代理示例一：" class="headerlink" title="反向代理示例一："></a>反向代理示例一：</h3><p>实现效果：使用 nginx 反向代理，访问 <a href="http://www.123.com/">www.123.com</a> 直接跳转到 127.0.0.1:8080</p>
<h4 id="实验代码："><a href="#实验代码：" class="headerlink" title="实验代码："></a>实验代码：</h4><p> （1）启动一个 tomcat，浏览器地址栏输入 127.0.0.1:8080，出现如下界面</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117090834021.png" alt="image-20210117090834021"></p>
<p>2） 通过修改本地 host 文件，将 <a href="http://www.123.com/">www.123.com</a> 映射到 127.0.0.1（<strong>不需要做DNS解析，直接通过本地host文件做解析即可</strong>）</p>
<p><img data-src="/2021/01/17/Nginx%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210117090914344.png" alt="image-20210117090914344"></p>
]]></content>
      <categories>
        <category>Java EE</category>
      </categories>
      <tags>
        <tag>Nginx服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>PC寄存器</title>
    <url>/2021/03/14/PC%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SVN版本控制系统</title>
    <url>/2021/02/06/SVN%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3>]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据库</title>
    <url>/2021/02/25/Redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Servlet规范一</title>
    <url>/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/</url>
    <content><![CDATA[<h2 id="Servlet规范（一）"><a href="#Servlet规范（一）" class="headerlink" title="Servlet规范（一）"></a>Servlet规范（一）</h2><h3 id="一、Servlet基础"><a href="#一、Servlet基础" class="headerlink" title="一、Servlet基础"></a>一、Servlet基础</h3><p>宏观地讲，Servlet 是连接 Web 服务器与服务端 Java 程序的协议，是一种通信规范。这个规范是以一套接口的形式体现的。 通常来说，Servlet 是宏观上 Servlet 规范中的一个具体的接口，Servlet 规范中包含一套接口。而 Servlet 接口仅仅是其中之一。 微观地讲，Servlet 是 Servlet 接口实现类的一个实例对象，是运行在服务器上的一段 Java 小程序，即 Server Applet，也就是 Servlet 这个单词的来历。Servlet 的主要功能是根据客户 端提交的请求，调用服务器端相关 Java 代码，完成对请求的处理与运算。</p>
 <img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/01.png" class>

<h4 id="1-Servlet生命周期"><a href="#1-Servlet生命周期" class="headerlink" title="1.Servlet生命周期"></a>1.Servlet生命周期</h4><p>所谓 Servlet 生命周期是指，Servlet 对象的创建、Servlet 对象的初始化、Servlet 对象服 务的执行，及最终 Servlet 对象被销毁的整个过程。</p>
 <img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/02.png" class>

<p>Servlet 的整个生命周期过程的执行，均由 Web 服务器负责管理。即 Servlet 从创建到服 务到销毁的整个过程中方法的调用，都是由 Web 服务器负责调用执行，程序员无法控制其 执行流程。 但程序员可以获取到 Servlet 的这些生命周期时间点，并可以指定让 Servlet 做一些具体 业务相关的事情。</p>
<p>#####1.1Servlet生命周期执行流程</p>
 <img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/03.png" class>

<p>Servlet 生命周期方法的执行流程： </p>
<p>（1）当请求发送到 Web 容器后，Web 容器会解析请求 URL，并从中分离出 Servlet 对应的 URI。 </p>
<p>（2）根据分离出的 URI，通过 web.xml 中配置的 URI 与 Servlet 的映射关系，找到要执行的 Servlet，即找到用于处理该请求的 Servlet。 </p>
<p>（3）若该 Servlet 不存在，则调用该 Servlet 的无参构造器、init()方法，实例化该 Servlet。 然后执行 service()方法。 </p>
<p>（4）若该 Servlet 已经被创建，则直接调用 service()方法。 </p>
<p>（5）当 Web 容器被关闭，或该应用被关闭，则调用执行 destroy()方法，销毁 Servlet 实例。</p>
<img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/04.png" class>

<p>对于以上代码的运行，注意以下几个时间点： </p>
<p>（1）项目部署后启动服务器，发现并没有执行 Servlet 的无参构造器方法，说明在 Web 容 器启动时并没有创建             Servlet 对象。 </p>
<p>（2）用户提交请求后，马上可以看到无参构造器、init()方法、service()方法均执行。 </p>
<p>（3）刷新页面，发现只会执行 service()方法，每刷新一次，即每提交一次请求，就会执行 一次 service()方法。 （4）让另外一个浏览器也发出同样的请求，会发现只执行 service()方法，而无参构造器、init() 方法均未执行。 （5）正常关闭 Tomcat（使用 stop server 关闭，不能使用 Terminate 关闭），发现 destroy()方 法也会执行。</p>
<h5 id="1-2Servlet特征"><a href="#1-2Servlet特征" class="headerlink" title="1.2Servlet特征"></a>1.2Servlet特征</h5><p>（1）Servlet 是单例多线程的。 </p>
<p>（2）一个 Servlet 实例只会执行一次无参构造器与 init()方法，并且是在第一次访问时执行。 </p>
<p>（3）用户每提交一次对当前 Servlet 的请求，就会执行一次 service()方法。 </p>
<p>（4）一个 Servlet 实例只会执行一次 destroy()方法，在应用停止时执行。</p>
<p>（5）由于 Servlet 是单例多线程的，所以为了保证其线程安全性，一般情况下是不为 Servlet 类定义可修改的成员         变量的。因为每个线程均可修改这个成员变量，会出现线程安全问题。 </p>
<p>（6）默认情况下，Servlet 在 Web 容器启动时是不会被实例化的。</p>
<h5 id="1-3Web-容器启动时创建-Servlet-实例"><a href="#1-3Web-容器启动时创建-Servlet-实例" class="headerlink" title="1.3Web 容器启动时创建 Servlet 实例"></a>1.3Web 容器启动时创建 Servlet 实例</h5><img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/05.png" class>

<p>在中添加的<load-on-startup>作用是，标记是否在Web服务器（这里是Tomcat） 启动时创建并初始化这个 Servlet 实例，即是否在 Web 服务器启动时调用执行该 Servlet 的无 参构造器方法与 init()方法，而不是在真正访问时才创建。 它的值必须是一个整数。</load-on-startup></p>
<ul>
<li><p>当值大于等于 0 时，表示容器在启动时就加载并初始化这个 Servlet，数值越小，该 Servlet 的优先级就越高，其被创建的也就越早；</p>
</li>
<li><p>当值小于 0 或者没有指定时，则表示该 Servlet 在真正被使用时才会去创建。</p>
</li>
<li><p>当值相同时，容器会自己选择创建顺序。</p>
</li>
</ul>
<p>#####1.4Web容器中的两个Map方法</p>
<p>当 Servlet 实例被创建好后被放在了哪里？web.xml 中 URI 与 Servlet 的映射关系反映到 内存中是以什么形式存在呢？ 当 Servlet 实例被创建好后，会将该 Servlet 实例的引用存放到一个 Map 集合中。该 Map 集合的 key 为 URI，而 value 则为 Servlet 实例的引用，即 Map&lt;String,value&gt;。当 Web 容器 从用户请求中分离出 URI 后，会首先到这个 Map 中查找是否存在其所对应的 value。若存在， 则直接调用其 service()方法。若不存在，则需要创建该 Servlet 实例。</p>
<p> 若请求的 Servlet 实例不存在，Web 容器又是根据什么创建这个 Servlet 实例的呢？在 Web 容器的内存中，还存在一个 Map 集合。该 Map 集合的 key 为 URI，而 value 则为 web.xml 中配置的与之对应的 Servlet 的全限定性类名，即 Map&lt;String,value&gt;。 当Web容器从用户请求中分离出URI后，到第一个Map中又没有找到其所对应的Servlet 实例，则会马上查找这第二个 Map，从中找到其所对应的类名，再根据反射机制，创建这 个 Servlet 实例。然后再将这个创建好的 Servlet 的引用放入到第一个 Map 中</p>
<p>#####1.5关于getServletInfo方法</p>
<p>Servlet 接口中的方法 getServletInfo()，是由程序没自己定义的有关当前 Servlet 的一些基本信息，不属于Servlet 生命周期中的方法。对程序的运行没有任何影响与作用。仅仅是返 回一些让他人阅读的信息而已。</p>
<h4 id="2-ServletConfig"><a href="#2-ServletConfig" class="headerlink" title="2.ServletConfig"></a>2.ServletConfig</h4><h5 id="2-1什么是ServletConfig"><a href="#2-1什么是ServletConfig" class="headerlink" title="2.1什么是ServletConfig"></a>2.1什么是ServletConfig</h5><p>在 Servlet 接口的 init()方法中具有唯一的一个参数 ServletConfig。ServletConfig 是个接口， 顾名思义，就是 Servlet 配置，即在 web.xml 中对当前 Servlet 类的配置信息。Servlet 规范将 Servlet 的配置信息全部封装到了 ServletConfig 接口对象中。 在 Web 容器调用 init()方法时，Web 容器首先会将 web.xml 中当前 Servlet 类的配置信息 封装为一个对象。这个对象的类型实现了 ServletConfig 接口，Web 容器会将这个对象传递给 init()方法中的 ServletConfig 参数。</p>
<h5 id="2-2获取ServletConfig对象"><a href="#2-2获取ServletConfig对象" class="headerlink" title="2.2获取ServletConfig对象"></a>2.2获取ServletConfig对象</h5><p>由于 ServletConfig 中可以获取到 Servlet 的初始化参数，获取到 ServletContext 对象，而 这些参数与对象在进行业务逻辑处理时，即执行 service()方法时需要经常访问，很重要，所 以 ServletConfig 对象也就显得很重要了。 由于 ServletConfig 对象是 Web 容器通过 init()方法传递给当前 Servlet 类的，而 init()方法 只会在 Servlet 对象初始化时调用一次。所以，需要在 init()方法中将 ServletConfig 对象传递 给 Servlet 的 ServletConfig 成员变量，这样 service()方法即可使用 ServletConfig 对象了。也就 是说，我们需要在 Servlet 中声明一个 ServletConfig 成员变量。 若在 Servlet 中声明一个 ServletConfig 成员变量，是否会存在线程安全问题呢？因为 Servlet 是单例多线程的。只要在 Servlet 中不为 ServletConfig 对象提供其它修改方法，其值 只能由 Web 容器通过 init()方法进行赋值，那么 ServletConfig 对象就不存在线程安全问题。 因为对于所有线程来说，ServletConfig 对象是只读的，不能修改。</p>
<h5 id="2-3ServletConfig中的方法"><a href="#2-3ServletConfig中的方法" class="headerlink" title="2.3ServletConfig中的方法"></a>2.3ServletConfig中的方法</h5><img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/06.png" class>

<img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/07.png" class>

<ul>
<li><p>getInitParameter()：获取指定名称的初始化参数值。例如 getInitParameter(“myDBDriver”); 会返回字符串“com.mysql.jdbc.Driver”。 </p>
</li>
<li><p>getInitParameterNames()：获取当前 Servlet 所有的初始化参数名称。其返回值为枚举类 型 Enumeration。</p>
</li>
<li><p>getServletName()：获取当前 Servlet 的中指定的 Servlet 名 称。如上图中的 ServletName 为“hello-servlet”。  </p>
</li>
<li><p>getServletContext()：获取到当前 Servlet 的上下文对象 ServletContext。这是个非常重要 的对象。</p>
</li>
</ul>
<p>#####2.4ServletConfig的特征</p>
<p>对于不同的Servlet，Tomcat会为其创建不同的ServletConfig，用于封装各自的配置信息。 也就是说，一个 Servlet 就会有其对应的一个 ServletConfig 对象；有几个 Servlet，将会产生 几个 ServletConfig 对象。</p>
<h5 id="2-5项目部署"><a href="#2-5项目部署" class="headerlink" title="2.5项目部署"></a>2.5项目部署</h5><img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/08.png" class>

<img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/09.png" class>

<img data-src="/2021/02/02/Servlet%E8%A7%84%E8%8C%83%E4%B8%80/10.png" class>

<p><strong>运行结论</strong>：<br>从对 ServletConfig 对象的输出结果可以看出，Tomcat 容器对 ServletConfig 接口的实现类为 org.apache.catalina.core.StandardWrapperFacade。当然，这个实现类是谁不重要，重要的是要理解，不同的 Web 容器，对该 ServletConfig 的实现类是不同的。但它们的共同特点是， 均实现了 Servlet 规范，实现了 ServletConfig 接口。</p>
]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Servlet规范</tag>
      </tags>
  </entry>
  <entry>
    <title>Session</title>
    <url>/2021/02/25/Session/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot入门一</title>
    <url>/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/</url>
    <content><![CDATA[<h2 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h2><p>先通过来一些概念，会让我们对技术有着更加清晰的理解。J2EE笨重的开发、繁多的配置、低下的开发效率、复杂的部署流程、第三方技术集成难度大，如果开发过SpringMVC或者单纯使用过SSH、SSM框架的同学，肯定是体验过被很多配置文件支配的恐惧，很难受吧，不过不用担心，我们有了SpringBoot。Spring Boot用来简化Spring应用开发，约定大于配置，去繁从简，just run就能创建一个独立的，产品级别的应用。随着Spring全家桶时代的到来，SpringBoot给我们带来了J2EE一站式解决方案，SpringCloud给我们带来了分布式整体解决方案。从此我们可以使用 SpringBoot 快速的开发基于 Spring 框架的项目，由于围绕 SpringBoot 存在很多开箱即用的 Starter 依赖，使得我们在开发业务代码时能够非常方便的、不需要过多关注框架的配置，而只需要关注业务即可。</p>
<h2 id="SpringBoot优点"><a href="#SpringBoot优点" class="headerlink" title="SpringBoot优点"></a>SpringBoot优点</h2><ul>
<li>快速创建独立运行的Spring项目以及与主流框架集成</li>
<li>使用嵌入式的Servlet容器，应用无需打成WAR包</li>
<li>starters自动依赖与版本控制</li>
<li>大量的自动配置，简化开发，也可以修改默认值</li>
<li>无需配置XML，无代码生成，开箱即用</li>
<li>准生产环境的运行时应用监控</li>
<li>与云计算的天然集成</li>
</ul>
<p>看到SpringBoot这么多优点，是不是很想立刻上手呢，先不急。这里还是要提一下的，SpringBoot入门很容易，不过想要精通还是有难度的，因为毕竟自动化帮我们把Spring全家桶集成的这么好，我们想要深入精通的话，必须要了解Spring全家桶的技术，当然难呀，不过既然好上手，我们完全可以先学会怎么使用，然后后面熟练了再去研究底层代码原理，这样才有那种豁然开让的感觉。</p>
<h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>说到SpringBoot，就不得不提一下微服务，微服务是一种架构风格，可以理解成小型服务，这些服务通过HTTP的方式进行互通。微服务并没有一个官方的定义，想要直接描述微服务比较困难，我们可以通过对比传统WEB应用，来理解什么是微服务，传统的应用成为“单体应用”</p>
<p>单体应用就是那种，核心分为业务逻辑、适配器以及API或通过UI访问的WEB界面。业务逻辑定义业务流程、业务规则以及领域实体。适配器包括数据库访问组件、消息组件以及访问接口等，所有的这些东西都集成在一起，看着很强大，其实很乱。</p>
<p>而微服务架构有很多重要的优点，它解决的就是复杂性问题。它将单体应用分解为一组服务。虽然功能总量不变，但应用程序已被分解为可管理的模块或服务。这些服务定义了明确的RPC或消息驱动的API边界。微服务架构强化了应用模块化的水平，而这通过单体代码库很难实现。因此，微服务开发的速度要快很多，更容易理解和维护。</p>
<h2 id="实现一个HelloWord应用"><a href="#实现一个HelloWord应用" class="headerlink" title="实现一个HelloWord应用"></a>实现一个HelloWord应用</h2><p>说了这么多SprigBoot多好多好，不直接上手一个简单的项目说不过去，那我们就来创建运行一个HelloWord应用，体验一些从创建到访问<a href="http://localhost:8080/hello%E6%9C%89%E5%A4%9A%E4%B9%88%E7%9A%84%E7%AE%80%E5%8D%95%EF%BC%8C%E4%BD%A0%E5%B0%B1%E4%BC%9A%E6%84%8F%E8%AF%86%E5%88%B0%E5%8E%9F%E5%85%88%E7%9A%84SpringMVC%E4%BB%A5%E5%8F%8ASSH%E4%BB%80%E4%B9%88%E7%9A%84%E6%9C%89%E5%A4%9A%E4%B9%88%E7%B9%81%E7%90%90%E3%80%82">http://localhost:8080/hello有多么的简单，你就会意识到原先的SpringMVC以及SSH什么的有多么繁琐。</a><br>这里说一下，我们先上手一个简单的应用，然后我会基于这个简单的应用说明一些SpringBoot的配置和使用，正所谓先要尝到甜头，才有学习的动力嘛，废话不多说，上手。</p>
<h3 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h3><p>环境啥的其实，也不用多说，因为和我使用的不同版本其实也不会有太大影响，只是可能一些问题是因为版本引起的。</p>
<pre><code>JDK1.8：1.8的版本很好用，目前大部分公司生产环境的项目也都是1.8
SpringBoot1.7以上：我这里使用的SpringBoot2.2.4
Maven3.3以上：我这里使用的是3.5.4
IDE使用的Idea（用eclipse也可以，不过我使用的是Idea演示）</code></pre>
<p>这里特别说明一下的是Maven，我们如果使用Idea内置的Maven也可以，不过我喜欢用自己想要的版本，所以就自己给Idea配置我想要的Maven版本，而且还能学到东西，Maven也是我们必须要了解的一项工具。</p>
<p>我使用的是Idea2018，里面内置的Maven是3.3的，我自己改成了3.5</p>
<p>安装好了Maven以后，记得把Maven默认的JDK改成1.8，就是在Maven的安装位置的conf文件夹中，打开setting.xml，在里面改成如下配置<br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/01.png" class><br>为了方便，我就直接把内容粘贴出来，你们就不用一个一个打了，如下</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.targer</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.targer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>完成了上述操作之后，现在我教你用Idea配置自己的Maven，具体操作如下图：</p>
 <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/02.png" class>

<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/03.png" class>

<p>选择好了之后，点击Apply就可以了。</p>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>一个功能，浏览器发送hello请求，服务器接受请求并处理，相应HelloWorld字符串</p>
<h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>首先我们使用Idea创建Maven工程</p>
<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/04.png" class>

<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/05.png" class>

<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/06.png" class>

<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/07.png" class>

<p>然后点击Finish就创建成功了，我们的Maven项目也就创建好了，这里要提一下，我们刚创建Maven项目的时候，Idea给我的一些Tip，我们把这个勾选了，以后我们修改pom.xml的时候，就会自动帮我们加载依赖了。</p>
<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/08.png" class>

<p>当然啦，如果你没有对Maven进行生命配置的话，你会发现Maven加载相关依赖的时候非常的慢，因为Maven中央库在国外，所以自然比较慢，我们可以配置Maven为阿里源，这里就快很多了，具体操作看我另一篇文章带你了解Maven，并搞定安装和配置，里面有讲解如何配置阿里源</p>
<h3 id="导入依赖SpringBoot相关的依赖"><a href="#导入依赖SpringBoot相关的依赖" class="headerlink" title="导入依赖SpringBoot相关的依赖"></a>导入依赖SpringBoot相关的依赖</h3><p>接下来，我们来使用pom加载相关依赖，加载我们的SpringBoot项目，那我们应该是用什么依赖呢，哈哈，不要慌，这里我教你怎么使用官网的例子，首先打开Spring官网，然后我们根据我们需要的相关版本，进行勾选生成即可，SpringBoot的版本一般选择最新的release版本就可以了，具体如下图<br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/09.png" class><br>然后我们就可以把生成的pom.xml依赖拷贝到我们项目的pom.xml里面，注意了，不要全部拷贝，基本把我圈出来的换成你自己的，如下图<br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/10.png" class></p>
<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/11.png" class>

<p>到这里我们就加载完成了一个SpringBoot项目吧，是不是很简单，不过你可能会说，我加载SpringMVC之类的也很简单，不过不要急，我们接着编写一个代码，你就发现我们什么都不用配置。</p>
<h3 id="编写一个主程序，启动SpringBoot应用"><a href="#编写一个主程序，启动SpringBoot应用" class="headerlink" title="编写一个主程序，启动SpringBoot应用"></a>编写一个主程序，启动SpringBoot应用</h3><p>现在创建一个包，在包下创建一个java类，命名随便，我这里命名为DemoApplication ，如下图，编写的代码如下：</p>
<img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/12.png" class>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="meta">@RequestParam(value = &quot;name&quot;, defaultValue = &quot;World&quot;)</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;Hello %s!&quot;</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>}</p>
<p>代码写好了就直接运行吧，你没听错，啥都不用做，直接运行就好了，运行了之后，直接在浏览器中访问，你就会发现成功了，舒不舒服。<br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/13.png" class></p>
<h2 id="SpringBoot简化部署"><a href="#SpringBoot简化部署" class="headerlink" title="SpringBoot简化部署"></a>SpringBoot简化部署</h2><p>从创建到运行就是这么方便简单，非常舒服，在进行代码分析讲解之前，我在多说点SpringBoot的甜头，就是打包部署。这个时候会发出疑问，哎，我刚刚创建的时候，好像像Tomcat之类的都没有安装配置，war包也没有打，怎么就运行了呢，更何谈部署。哈哈哈这个时候就能体现SpringBoot的小甜头了，SpringBoot项目可以打成jar包，然后在不需要安装运行环境的情况下，就能直接运行jar包，启动程序，可以移植性非常强。我们可以使用Maven命令打包，也可以直接借助Idea打包，Maven命令自己直接网上查找就可以了，这里我演示使用Idea打包方便，具体操作如下，在Idea侧边栏有Maven Projects，点击打开：<br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/14.png" class><br>等待运行结束，在日志那里，如下图<br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/15.png" class><br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/16.png" class><br>把打包好的jar包粘贴到桌面，然后打开命令行，执行指令就可以运行了。<br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/17.png" class><br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/18.png" class><br> <img data-src="/2021/03/19/SpringBoot%E5%85%A5%E9%97%A8%E4%B8%80/19.png" class><br>运行成功，然后直接在浏览器访问一样可以成功访问，是不是很有意思。</p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot框架</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot入门二</title>
    <url>/2021/03/21/SpringBoot%E5%85%A5%E9%97%A8%E4%BA%8C/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring学习第一跳</title>
    <url>/2021/02/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%B7%B3/</url>
    <content><![CDATA[<h2 id="初识Spring"><a href="#初识Spring" class="headerlink" title="初识Spring"></a>初识Spring</h2><h3 id="Spring框架概述"><a href="#Spring框架概述" class="headerlink" title="Spring框架概述"></a>Spring框架概述</h3><p>Spring 是于 2003 年兴起的一个轻量级的 Java 开发框架，它是为了解决企业应用开发的复杂性而创建的。Spring 的核心是控制反转（IoC）和面向切面编程（AOP）。Spring 是可 以在 Java SE/EE 中使用的轻量级开源框架。</p>
<p>Spring 的主要作用就是为代码<strong>“解耦”</strong>，降低代码间的耦合度。就是让对象和对象（模 块和模块）之间关系不是使用代码关联，而是<u>通过配置</u>来说明。即在 Spring 中说明对象（模块）的关系。 </p>
<p>Spring 根据代码的功能特点，使用 Ioc 降低业务对象之间耦合度。IoC 使得主业务在相互 调用过程中，不用再自己维护关系了，即不用再自己创建要使用的对象了。而是由 Spring 容器统一管理，自动“注入”,注入即赋值。 而 AOP 使得系统级服务得到了最大复用，且不用再由程序员手工将系统级服务“混杂”到主业务逻辑中了，而是由 Spring 容器统一完成 “织入”。</p>
<h3 id="Spring的优点"><a href="#Spring的优点" class="headerlink" title="Spring的优点"></a>Spring的优点</h3><p>Spring 是一个框架，是一个半成品的软件。有 20 个模块组成。它是一个容器管理对象， 容器是装东西的，Spring 容器不装文本，数字。装的是对象。Spring 是存储对象的容器。</p>
<ul>
<li><p>轻量</p>
<p>Spring 框架使用的 jar 都比较小，一般在 1M 以下或者几百 kb。Spring 核心功能的所需 的 jar 总共在 3M 左右。 Spring 框架运行占用的资源少，运行效率高。不依赖其他 jar</p>
</li>
<li><p>针对接口编程，解耦合</p>
<p>Spring 提供了 Ioc 控制反转，由容器管理对象，对象的依赖关系。原来在程序代码中的 对象创建方式，现在由容器完成。对象之间的依赖解耦合。</p>
</li>
<li><p>AOP编程的支持</p>
<p>通过 Spring 提供的 AOP 功能，方便进行面向切面的编程，许多不容易用传统 OOP 实现 的功能可以通过 AOP 轻松应付 。</p>
<p>在 Spring 中，开发人员可以从繁杂的事务管理代码中解脱出来，通过声明方式灵活地进行事务的管理，提高开发效率和质量。</p>
</li>
<li><p>方便集成各种优秀框架</p>
<p>Spring 不排斥各种优秀的开源框架，相反 Spring 可以降低各种框架的使用难度，Spring 提供了对各种优秀框架（如 Struts,Hibernate、MyBatis）等的直接支持。简化框架的使用。 Spring 像插线板一样，其他框架是插头，可以容易的组合到一起。需要使用哪个框架，就把 这个插头放入插线板。不需要可以轻易的移除。</p>
</li>
</ul>
<h3 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h3><img data-src="/2021/02/03/Spring%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E8%B7%B3/image.png" class>

<p>Spring 由 20 多个模块组成，它们可以分为数据访问/集成（Data Access/Integration）、 Web、面向切面编程（AOP, Aspects）、提供JVM的代理（Instrumentation）、消息发送（Messaging）、 核心容器（Core Container）和测试（Test）。</p>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger-UI</title>
    <url>/2021/03/14/Swagger-UI/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Stack</title>
    <url>/2021/03/11/Stack/</url>
    <content><![CDATA[<h2 id="栈刷题总结"><a href="#栈刷题总结" class="headerlink" title="栈刷题总结"></a>栈刷题总结</h2><h3 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1.有效的括号"></a>1.有效的括号</h3><h4 id="知识点补充："><a href="#知识点补充：" class="headerlink" title="知识点补充："></a>知识点补充：</h4><blockquote>
<p>stack.pop()和stack.peek的区别：</p>
<p>相同点：大家都返回栈顶元素</p>
<p>不同点：satck.pop()返回栈顶元素后会将栈顶元素删除，而stack.peek()只返回不删除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈+哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character,Character&gt;();</span><br><span class="line">        pairs.put(<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(pairs.containsKey(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()||stack.peek()!=pairs.get(ch))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-比较含退格的两个字符串"><a href="#2-比较含退格的两个字符串" class="headerlink" title="2.比较含退格的两个字符串"></a>2.比较含退格的两个字符串</h3><p>####2.1方法一：重构字符串(利用StringBuffer的可扩展性)</p>
<p>用栈处理字符串，如果是需要删除的元素，就将其出栈，如果是需要压入栈的元素，就使其入栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iii Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(S).equals(build(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                ret.append(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ret.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ret.deleteCharAt(ret.length()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//不是String类型的想转换为String类型直接引用toString()方法就行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间和空间度均为O(M+N)。</p>
<h4 id="2-2双指针"><a href="#2-2双指针" class="headerlink" title="2.2双指针"></a>2.2双指针</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暂时不懂，后期可以再看一下官方题解</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(M+N),空间复杂度为O(1)。</p>
<h4 id="2-3栈"><a href="#2-3栈" class="headerlink" title="2.3栈"></a>2.3栈</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(S).equals(build(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack  = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            Character C = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(C!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                stack.push(C);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!stack.isEmpty())&#123;        <span class="comment">//要考虑到栈不为空的条件</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-化栈为队"><a href="#3-化栈为队" class="headerlink" title="3.化栈为队"></a>3.化栈为队</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty()&amp;&amp;stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h3 id="4-用两个栈实现队列"><a href="#4-用两个栈实现队列" class="headerlink" title="4.用两个栈实现队列"></a>4.用两个栈实现队列</h3><p>#####实现队列最直观的方式是链表，但是用栈stack也可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.isEmpty() ? -<span class="number">1</span> : stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h3 id="5-用栈实现队列"><a href="#5-用栈实现队列" class="headerlink" title="5.用栈实现队列"></a>5.用栈实现队列</h3><p>为了满足队列的 <strong>FIFO</strong> 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：使用两个栈来执行入队O(n)和出队O(1)操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">            front = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> s =  stack1.pop();</span><br><span class="line">        <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            front = stack1.peek();    <span class="comment">//j将新的栈顶元素赋值给front</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二：使用两个栈来执行入队O(1)和出队O(1)操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">            front = x;   <span class="comment">//代表每次stack1空了之后，再压入的队首元素会更新。</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">              stack2.push(stack1.pop());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty()&amp;&amp;stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用front来保存队首元素，确保在peek()操作时，如果stack2是空的，可以直接返回之前保存的队首元素。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="/2021/03/11/Stack/Users\xinghaodong\AppData\Roaming\Typora\typora-user-images\image-20210223121515059.png" alt="image-20210223121515059"></p>
<h3 id="6-用队列实现栈"><a href="#6-用队列实现栈" class="headerlink" title="6.用队列实现栈"></a>6.用队列实现栈</h3><h4 id="6-1使用两个队列"><a href="#6-1使用两个队列" class="headerlink" title="6.1使用两个队列"></a>6.1使用两个队列</h4><p>一个队列用于存储栈内元素，另一个队列作为辅助栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();   <span class="comment">//queue1此时就是按照栈的顺序来存储元素的，所以直接poll即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="6-2LinkedList作为堆栈和链表使用的总结"><a href="#6-2LinkedList作为堆栈和链表使用的总结" class="headerlink" title="6.2LinkedList作为堆栈和链表使用的总结"></a>6.2LinkedList作为堆栈和链表使用的总结</h4><p>ava里的LinkedList可以同时作为堆栈和队列使用，因此在使用的时候总是会弄混他们的方法，此文就简单总结一下作为不同数据结构使用时的用法。</p>
<h5 id="作为队列"><a href="#作为队列" class="headerlink" title="作为队列"></a>作为队列</h5><p><img data-src="https://upload-images.jianshu.io/upload_images/25254-15c6e9f6ec53c3f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/416/format/webp" alt="img"></p>
<p>方法</p>
<blockquote>
<p>声明</p>
</blockquote>
<p>任意两种方法：</p>
<ul>
<li>一是直接声明LinkedList：<br><code>LinkedList&lt;T&gt; q = new LinkedList&lt;T&gt;();</code></li>
<li>或者使用java.util.Queue接口，其底层关联到一个LinkedList实例。<br><strong><code>Queue&lt;T&gt; q = new LinkedList&lt;T&gt;();</code></strong><br>由于只暴露部分基于队列实现的接口，所以可以提供安全的队列实现。</li>
</ul>
<blockquote>
<p>入队</p>
</blockquote>
<p><strong><code>void offer(T v)</code></strong></p>
<blockquote>
<p>出队</p>
</blockquote>
<ul>
<li><strong><code>T poll()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T remove()</code>,  如果队列为空，则抛出异常</li>
</ul>
<blockquote>
<p>看看队首元素不移除它。</p>
</blockquote>
<ul>
<li><strong><code>T peek()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T element()</code>,  如果队列为空，则抛出异常</li>
</ul>
<blockquote>
<p>是否为空</p>
</blockquote>
<ul>
<li><code>boolean isEmpty()</code>, 空返回true，否则返回false</li>
</ul>
<h5 id="作为堆栈"><a href="#作为堆栈" class="headerlink" title="作为堆栈"></a>作为堆栈</h5><p><img data-src="https://upload-images.jianshu.io/upload_images/25254-05ecccef371c9492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/631/format/webp" alt="img"></p>
<p>方法</p>
<blockquote>
<p>声明</p>
</blockquote>
<p>任意两种方法：</p>
<ul>
<li>一是直接声明LinkedList：<br><code>LinkedList&lt;T&gt; stack = new LinkedList&lt;T&gt;();</code></li>
<li>请注意，LinkedList实现的堆栈名称是Deque:<br><strong><code>Deque&lt;T&gt; stack = new LinkedList&lt;T&gt;();</code></strong><br>由于只暴露部分基于堆栈实现的接口，所以可以提供安全的队列实现。</li>
</ul>
<blockquote>
<p>入栈</p>
</blockquote>
<p><strong><code>void addFirst(T v)</code></strong><br> <strong><code>void push(T v)</code></strong></p>
<blockquote>
<p>出栈</p>
</blockquote>
<ul>
<li><strong><code>T pop()</code></strong></li>
<li><code>T poll()</code></li>
</ul>
<blockquote>
<p>peek()</p>
</blockquote>
<p>看看队首元素不移除它。</p>
<ul>
<li><strong><code>T peek()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T element()</code>,  如果队列为空，则抛出异常</li>
</ul>
<blockquote>
<p>是否为空</p>
</blockquote>
<ul>
<li><code>boolean isEmpty()</code>, 空返回true，否则返回false</li>
</ul>
<p>####6.3用一个队列实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h3 id="7-棒球比赛"><a href="#7-棒球比赛" class="headerlink" title="7.棒球比赛"></a>7.棒球比赛</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(String op:ops)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> newtop = top+stack.peek();</span><br><span class="line">                stack.push(top);</span><br><span class="line">                stack.push(newtop);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op.equals(<span class="string">&quot;C&quot;</span>))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op.equals(<span class="string">&quot;D&quot;</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">2</span>*stack.peek());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(op));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:stack)&#123;</span><br><span class="line">            ans = ans+n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-用栈操作构建数组"><a href="#8-用栈操作构建数组" class="headerlink" title="8.用栈操作构建数组"></a>8.用栈操作构建数组</h3><h3 id="9-删除最外层的括号"><a href="#9-删除最外层的括号" class="headerlink" title="9.删除最外层的括号"></a>9.删除最外层的括号</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Undo页与redo页</title>
    <url>/2021/02/14/Undo%E9%A1%B5%E4%B8%8Eredo%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC)。</p>
<ul>
<li>事务的原子性(Atomicity)<br>事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。</li>
<li>原理<br>Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。</li>
<li>事务的持久性(Durability)<br>事务一旦完成，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库系统会将修改后的数据完全的记录到持久的存储上。</li>
<li>用Undo Log实现原子性和持久化的事务的简化过程<br>假设有A、B两个数据，值分别为1,2。<br>A.事务开始.<br>B.记录A=1到undo log.<br>C.修改A=3.<br>D.记录B=2到undo log.<br>E.修改B=4.<br>F.将undo log写到磁盘。<br>G.将数据写到磁盘。<br>H.事务提交<br>这里有一个隐含的前提条件：‘数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘’。</li>
</ul>
<p>之所以能同时保证原子性和持久化，是因为以下特点：<br>A. 更新数据前记录Undo log。<br>B. 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>C. Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的,可以用来回滚事务。</p>
<p>D. 如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p>
<p>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一<br>种机制来实现持久化，即Redo Log.</p>
<h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><ul>
<li>原理<br>和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，<br>不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</li>
<li>Undo + Redo事务的简化过程<br>假设有A、B两个数据，值分别为1,2.<br>A.事务开始.<br>B.记录A=1到undo log.<br>C.修改A=3.<br>D.记录A=3到redo log.<br>E.记录B=2到undo log.<br>F.修改B=4.<br>G.记录B=4到redo log.<br>H.将redo log写入磁盘。<br>I.事务提交</li>
<li>Undo + Redo事务的特点<br>A. 为了保证持久性，必须在事务提交前将Redo Log持久化。<br>B. 数据不需要在事务提交前写入磁盘，而是缓存在内存中。<br>C. Redo Log保证事务的持久性。<br>D. Undo Log保证事务的原子性。<br>E. 有一个隐含的特点，数据必须要晚于redo log写入持久存储。</li>
<li>IO性能<br>Undo + Redo的设计主要考虑的是提升IO性能。虽说通过缓存数据，减少了写数据的IO. 但是却引入了新的IO，即写Redo Log的IO。如果Redo Log的IO性能不好，就不能起到提高性能的目的。</li>
</ul>
<p>为了保证Redo Log能够有比较好的IO性能，InnoDB 的 Redo Log的设计有以下几个特点：</p>
<p>A. 尽量保持Redo Log存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。以顺序追加的方式记录Redo Log,通过顺序IO来改善性能。<br>B. 批量写入日志。日志并不是直接写入文件，而是先写入redo log buffer.当需要将日志刷新到磁盘时 (如事务提交),将许多日志一起写入磁盘.<br>C. 并发的事务共享Redo Log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起，以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的：<br>记录1: &lt;trx1, insert …&gt;<br>记录2: &lt;trx2, update …&gt;<br>记录3: &lt;trx1, delete …&gt;<br>记录4: &lt;trx3, update …&gt;<br>记录5: &lt;trx2, insert …&gt;<br>D. 因为C的原因,当一个事务将Redo Log写入磁盘时，也会将其他未提交的事务的日志写入磁盘。<br>E. Redo Log上只进行顺序追加的操作，当一个事务需要回滚时，它的Redo Log记录也不会从Redo Log中删除掉。</p>
<h2 id="恢复-Recovery"><a href="#恢复-Recovery" class="headerlink" title="恢复(Recovery)"></a>恢复(Recovery)</h2><ul>
<li>恢复策略<br>前面说到未提交的事务和回滚了的事务也会记录Redo Log，因此在进行恢复时,这些事务要进行特殊的的处理.有2中不同的恢复策略：<br>A. 进行恢复时，只重做已经提交了的事务。<br>B. 进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务。</li>
<li>InnoDB存储引擎的恢复机制<br>MySQL数据库InnoDB存储引擎使用了B策略, InnoDB存储引擎中的恢复机制有几个特点：<br>A. 在重做Redo Log时，并不关心事务性。 恢复时，没有BEGIN，也没有COMMIT,ROLLBACK的行为。也不关心每个日志是哪个事务的。尽管事务ID等事务相关的内容会记入Redo Log，这些内容只是被当作要操作的数据的一部分。<br>B. 使用B策略就必须要将Undo Log持久化，而且必须要在写Redo Log之前将对应的Undo Log写入磁盘。<br>Undo和Redo Log的这种关联，使得持久化变得复杂起来。为了降低复杂度，InnoDB将Undo Log看作数据，因此记录Undo Log的操作也会记录到redo log中。这样undo log就可以象数据一样缓存起来， 而不用在redo log之前写入磁盘了。<br>包含Undo Log操作的Redo Log，看起来是这样的<br>记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;<br>记录2: &lt;trx1, insert …&gt;<br>记录3: &lt;trx2, Undo log insert &lt;undo_update …&gt;&gt;<br>记录4: &lt;trx2, update …&gt;<br>记录5: &lt;trx3, Undo log insert &lt;undo_delete …&gt;&gt;<br>记录6: &lt;trx3, delete …&gt;<br>C. 到这里，还有一个问题没有弄清楚。既然Redo没有事务性，那岂不是会重新执行被回滚了的事务？<br>确实是这样。同时Innodb也会将事务回滚时的操作也记录到redo log中。回滚操作本质上也是对数据进行修改，因此回滚时对数据的操作也会记录到Redo Log中。<br>一个回滚了的事务的Redo Log，看起来是这样的：<br>记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;<br>记录2: &lt;trx1, insert A…&gt;<br>记录3: &lt;trx1, Undo log insert &lt;undo_update …&gt;&gt;<br>记录4: &lt;trx1, update B…&gt;<br>记录5: &lt;trx1, Undo log insert &lt;undo_delete …&gt;&gt;<br>记录6: &lt;trx1, delete C…&gt;<br>记录7: &lt;trx1, insert C&gt;<br>记录8: &lt;trx1, update B to old value&gt;<br>记录9: &lt;trx1, delete A&gt;<br>一个被回滚了的事务在恢复时的操作就是先redo再undo，因此不会破坏数据的一致性.</li>
<li>InnoDB存储引擎中相关的函数<br>Redo: recv_recovery_from_checkpoint_start()<br>Undo: recv_recovery_rollback_active()<br>Undo Log的Redo Log: trx_undof_page_add_undo_rec_log()</li>
</ul>
]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>InnoDB存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>XML映射文件详解</title>
    <url>/2021/03/14/XML%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>XML配置文件详解</title>
    <url>/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="配置文档顶层结构"><a href="#配置文档顶层结构" class="headerlink" title="配置文档顶层结构"></a>配置文档顶层结构</h2><img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/01.png" class>



<h2 id="属性（properties"><a href="#属性（properties" class="headerlink" title="属性（properties)"></a>属性（properties)</h2><h3 id="属性配置的几种方式"><a href="#属性配置的几种方式" class="headerlink" title="属性配置的几种方式"></a>属性配置的几种方式</h3><blockquote>
<p>在外部进行配置，并且进行动态替换，即在Java属性文件中配置这些属性</p>
</blockquote>
<blockquote>
<p>在properties元素的子元素中进行设置</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，既使用了外部文件进行配置的方式，又使用了子元素配置方式。</p>
<p>设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的 username 和 password 将会由 properties 子元素中设置的相应值来替换。</p>
<p>driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p>
<blockquote>
<p>在 SqlSessionFactoryBuilder.build() 方法中传入属性值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 或者 ...</span></span><br><span class="line"></span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, environment, props);</span><br></pre></td></tr></table></figure>


<h3 id="属性配置读取的优先级"><a href="#属性配置读取的优先级" class="headerlink" title="属性配置读取的优先级"></a>属性配置读取的优先级</h3><p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p>
<ul>
<li>首先读取在 properties 元素体内指定的属性。          </li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据          url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。          </li>
<li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。          </li>
</ul>
<p>因此，<strong>通过方法参数传递的属性具有最高优先级，resource/url        属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性</strong>。</p>
<h3 id="使用占位符指定默认值"><a href="#使用占位符指定默认值" class="headerlink" title="使用占位符指定默认值"></a>使用占位符指定默认值</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username:ut_user&#125;&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 如果属性 &#x27;username&#x27; 没有被配置，&#x27;username&#x27; 属性的值将为 &#x27;ut_user&#x27; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个特性默认是关闭的，需要添加一个特定的属性；欸启用这个特性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 启用默认值特性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果你在属性名中使用了 <code>&quot;:&quot;</code> 字符（如：<code>db:username</code>），或者在 SQL 映射中使用了 OGNL 表达式的三元运算符（如： <code>$&#123;tableName != null ?tableName : &#39;global_constants&#39;&#125;</code>），就需要设置特定的属性来修改分隔属性名和默认值的字符。例如：        </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot;</span> <span class="attr">value</span>=<span class="string">&quot;?:&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 修改默认值的分隔符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db:username?:ut_user&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="设置（settings"><a href="#设置（settings" class="headerlink" title="设置（settings)"></a>设置（settings)</h2><p>MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>
<p>具体的详细设置类目不在罗列，可以参考官方文档。</p>
<blockquote>
<p>一个完整的settings元素的示例</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="类型别名（typeAliases"><a href="#类型别名（typeAliases" class="headerlink" title="类型别名（typeAliases)"></a>类型别名（typeAliases)</h2><p>类型别名可为 Java 类型设置一个缩写名字。它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>也可以指定一个包名,mybatis会在包名下面搜索需要的Java Bean</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line">&lt;/typeAliases</span><br></pre></td></tr></table></figure>
<p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean的首字母小写的非限定类名来作为它的别名。比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="java内建的类型别名"><a href="#java内建的类型别名" class="headerlink" title="java内建的类型别名"></a>java内建的类型别名</h3><img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/02.png" class>

<img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/03.png" class>





<h2 id="对象工厂-objectFactory"><a href="#对象工厂-objectFactory" class="headerlink" title="对象工厂(objectFactory)"></a>对象工厂(objectFactory)</h2><p>每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来<strong>完成实例化工作</strong>。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。 如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExampleObjectFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleObjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultObjectFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.create(type);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collection.class.isAssignableFrom(type);</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.example.ExampleObjectFactory&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ObjectFactory 接口很简单，它包含两个创建实例用的方法，一个是处理默认无参构造方法的，另外一个是处理带参数的构造方法的 。另外，setProperties 方法可以被用来配置ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。</p>
<h2 id="数据库厂商标识"><a href="#数据库厂商标识" class="headerlink" title="数据库厂商标识"></a>数据库厂商标识</h2><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 <code>databaseId</code> 属性。 MyBatis 会加载带有匹配当前数据库 <code>databaseId</code> 属性和所有不带 <code>databaseId</code> 属性的语句。 如果同时找到带有 <code>databaseId</code> 和不带 <code>databaseId</code> 的相同语句，则后者会被舍弃。 为支持多厂商特性，只要像下面这样在 mybatis-config.xml 文件中加入 <code>databaseIdProvider</code> 即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>databaseIdProvider 对应的 DB_VENDOR 实现会将 databaseId 设置为          <code>DatabaseMetaData#getDatabaseProductName()</code> 返回的字符串。          由于通常情况下这些字符串都非常长，而且相同产品的不同版本会返回不同的值，你可能想通过设置属性别名来使其变短：        </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DB2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;db2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 在提供了属性别名时，databaseIdProvider 的 DB_VENDOR 实现会将 databaseId 设置为数据库产品名与属性中的名称第一个相匹配的值，如果没有匹配的属性，将会设置为 “null”。 在这个例子中，如果          </p>
<p><code>getDatabaseProductName()</code> 返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。      </p>
<p>你可以通过实现接口 <code>org.apache.ibatis.mapping.DatabaseIdProvider</code> 并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider：        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DatabaseIdProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties p)</span> </span>&#123; <span class="comment">// 从 3.5.2 开始，该方法为默认方法</span></span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">String <span class="title">getDatabaseId</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="映射文件（mappers）"><a href="#映射文件（mappers）" class="headerlink" title="映射文件（mappers）"></a>映射文件（mappers）</h2><p>首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉MyBatis 到哪里去找映射文件。 你可以使用相对于**<u>类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。</u>**</p>
<img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/04.png" class>





















]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper</title>
    <url>/2021/03/14/zookeeper/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>coding部署</title>
    <url>/2021/03/15/coding%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>中断</title>
    <url>/2021/02/03/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断使得硬件得以发出通知给处理器，是一种变内核主动为硬件主动的方式。中断本质上是一种特殊的电信号。硬件在生成中断的时候并不需要考虑与处理器的时钟同步，即中断可以随时产生，<strong>内核随时可能因为新到来的中断而被打断</strong>。</p>
<img data-src="/2021/02/03/%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD1.png" class>

<p>不同的设备对应的中断不同，而每个中断都通过唯一的数字标识，这样，操作系统才能给不同的中断提供对应的中断处理程序。硬件发出中断，就是在提醒内核，有新的请求需要读取并处理。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>异常与中断不同之处就是在于异常在产生时必须要考虑处理器与时钟同步，所以其经常被称为同步中。</p>
<p>异常的产生原因：</p>
<blockquote>
<p>1.处理器由于执行到编程失误而导致的错误指令（如被0除）</p>
</blockquote>
<blockquote>
<p>2.执行期间出现特殊情况，例如缺页</p>
</blockquote>
<blockquote>
<p>3.系统调用陷入内核—–引起了系统调用处理程序异常</p>
</blockquote>
<p>以上，产生异常，都需要内核处理。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>内核通过执行中断处理程序(interrupt handler)来对某一特定的中断进行响应，产生中断的每一个设备都有一个相应的中断处理程序。一个设备的中断处理程序是其设备驱动程序的一部分—–设备驱动程序是<strong>用于对设备进行管理的内核代码</strong>。</p>
<p>中断处理程序被内核调用，运行于中断上下文，该上下文的执行代码不可阻塞。</p>
<h3 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h3><p>将中断处理分为两个部分。</p>
<blockquote>
<p>中断处理程序是上半部分（top half），接收到一个中断会被立即执行，只做有严格时限的工作。</p>
</blockquote>
<blockquote>
<p>能够被允许稍后完成的工作会被推迟到下半部去执行。即处理和操作中断的非即时完成请求会在随后的下半部中执行。</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><p>当执行一个中断处理程序时，内核处于中断上下文中(interrupt context)。</p>
<p>注意：</p>
<ul>
<li>中断上下文没有后备进程，所以其不可以睡眠。如果一个函数要进行睡眠，就不能出现在中断处理程序中。</li>
<li>中断处理程序实际上打断了其他的代码，这种异步执行的特性，要求所有的中断处理程序必须尽可能的快速、简单。尽量将工作从中断处理程序中分离出来，放在中断下半部执行。</li>
<li>中断处理程序栈是一个配置选项。在内核早期版本中，中断处理程序是共享别人的堆栈，获取空间时非常节约。后期，中断处理程序有了自己的栈（中断栈），但无论无何，在内核中还是要尽可能的节省空间的使用，因为内核栈本身就是有限的。</li>
<li><strong>进程上下文是可以睡眠的</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数现代硬件都通过中断来与操作系统进行通信。对给定的硬件进行管理的驱动程序注册中断处理程序，是为了响应并处理来自相关硬件的中断。中断过程所作的工作包括应答并重新设置硬件，从设备拷贝数据到内存以及反之，处理硬件请求，并发送新的硬件请求。</p>
<p>内核提供的接口包括注册和注销中断处理程序、禁止中断、屏蔽中断线以及检查中断系统的状态。</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>事件处理</title>
    <url>/2021/03/14/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>优秀项目</title>
    <url>/2021/03/11/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<blockquote>
<h2 id="litemall"><a href="#litemall" class="headerlink" title="litemall"></a>litemall</h2></blockquote>
<p><a href="https://github.com/linlinjava/litemall">https://github.com/linlinjava/litemall</a></p>
<p>Star: 15.5k</p>
<p><img data-src="https://github.com/linlinjava/litemall/raw/master/doc/pics/readme/project-structure.png" alt="img"></p>
<p>这是一个小商城系统。</p>
<p>litemall = Spring Boot后端 + Vue管理员前端 + 微信小程序用户前端 + Vue用户移动端</p>
<p>技术栈：Spring Boot、VUE、微信小程序</p>
<blockquote>
<h2 id="Head-First-Design-Patterns"><a href="#Head-First-Design-Patterns" class="headerlink" title="Head-First-Design-Patterns"></a>Head-First-Design-Patterns</h2></blockquote>
<p><a href="https://github.com/bethrobson/Head-First-Design-Patterns">https://github.com/bethrobson/Head-First-Design-Patterns</a></p>
<p>Star: 2.2k</p>
<p>《Head First Design Patterns》书籍的示例代码，与2014年7月发布的书籍对应，你可以载代码并从命令行编译并运行，或者将代码加载到 Eclipse 中的项目中。</p>
<blockquote>
<p>##Mall</p>
</blockquote>
<p><a href="https://github.com/macrozheng/mall">https://github.com/macrozheng/mall</a></p>
<p>Star: 47k</p>
<img data-src="/2021/03/11/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/01.png" class>

<p>mall致力于打造一个完整的电商系统，采用现阶段流行技术实现。</p>
<p>mall包括前台商城系统及后台管理系统，基于SpringBoot+MyBatis实现。</p>
<p>前台商城系统包含首页门户、商品推荐、商品搜索、商品展示、购物车、订单流程、会员中心、客户服务、帮助中心等模块。</p>
<p>后台管理系统包含商品管理、订单管理、会员管理、促销管理、运营管理、内容管理、统计报表、财务管理、权限管理、设置等模块。</p>
<blockquote>
<h2 id="miaosha"><a href="#miaosha" class="headerlink" title="miaosha"></a>miaosha</h2></blockquote>
<p><a href="https://github.com/qiurunze123/miaosha">https://github.com/qiurunze123/miaosha</a></p>
<p>Star: 19.3k</p>
<img data-src="/2021/03/11/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/02.png" class>

<p>miaosha = 秒杀，秒杀系统设计与实现</p>
<p>这个项目是对高并发大流量如何进行秒杀架构，而做的一个系统整理。</p>
<blockquote>
<h2 id="vhr"><a href="#vhr" class="headerlink" title="vhr"></a>vhr</h2></blockquote>
<p><a href="https://github.com/lenve/vhr">https://github.com/lenve/vhr</a></p>
<p>Star: 20.5k</p>
<img data-src="/2021/03/11/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/03.png" class>



<blockquote>
<h2 id="spring-boot-demo"><a href="#spring-boot-demo" class="headerlink" title="spring-boot-demo"></a>spring-boot-demo</h2></blockquote>
<p><a href="https://github.com/xkcoding/spring-boot-demo">https://github.com/xkcoding/spring-boot-demo</a></p>
<p>Star: 20.8k</p>
<p>spring boot demo 是一个用来深度学习并实战 spring boot 的项目，目前总共包含65个集成demo，已经完成53个。</p>
<p>这个项目已成功集成 actuator(监控)、admin(可视化监控)、logback(日志)、aopLog(通过AOP记录web请求日志)、统一异常处理(json级别和页面级别)、freemarker(模板引擎)、Mybatis、redis、zookeeper、RabbitMQ、Kafka等。</p>
<blockquote>
<h2 id="eladmin"><a href="#eladmin" class="headerlink" title="eladmin"></a>eladmin</h2></blockquote>
<p><a href="https://github.com/elunez/eladmin">https://github.com/elunez/eladmin</a></p>
<p>Star: 14.6k</p>
<p>这是一个基于 Spring Boot、Jpa、Spring Security、redis、Vue 的前后端分离的后台管理系统。</p>
<p>项目采用分模块开发方式，权限控制采用 RBAC，支持数据字典与数据权限管理，支持一键生成前后端代码，支持动态路由。</p>
<p>系统功能：用户管理、角色管理、菜单管理、部门管理、岗位管理、SQL监控、定时任务、邮件工具、七牛云存储、支付宝支付、服务监控、运维管理等。</p>
<blockquote>
<h2 id="99-problems"><a href="#99-problems" class="headerlink" title="99-problems"></a>99-problems</h2></blockquote>
<p><a href="https://github.com/shekhargulati/99-problems">https://github.com/shekhargulati/99-problems</a></p>
<p>Star: 3.3k</p>
<p>光看名字就能对其功能了解一二，它的作用是帮助大家磨练逻辑编程中的具体技能。大家可以选择利用Java 8、Scala 或者 Haskell 进行问题解决，并最终找到最精致的解决办法。</p>
<p>如果大家喜爱解题，其中还提供多种不同层级的难度供各位选择。另外，如果大家将全部 99 道难题解决掉，则可进一步冲击Java Deathmatch。如果大家被难住了，请点击此处查看难题——但请注意，认真思考之后再参阅比较好。</p>
<blockquote>
<h2 id="Dex"><a href="#Dex" class="headerlink" title="Dex"></a>Dex</h2></blockquote>
<p><a href="https://github.com/PatMartin/Dex">https://github.com/PatMartin/Dex</a></p>
<p>Star: 1.2k</p>
<p>如果大家希望通过酷炫的方式进行数据交互，那么 Dex 绝对不容错过。它能够帮助我们提取、转换及可视化数据，同时附带预测功能。大家可以将可视化结果发布为 3D 或者其它 HTML 变量形式。</p>
<p>Dex 允许我们生成超过 50 种不同的可视化模式，其中包括世界地图、时间表、网络可视化等。</p>
 <img data-src="/2021/03/11/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/04.png" class>

<img data-src="/2021/03/11/%E4%BC%98%E7%A7%80%E9%A1%B9%E7%9B%AE/05.png" class>















]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>优秀项目</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker部署开发环境</title>
    <url>/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="在Linux上安装Docker"><a href="#在Linux上安装Docker" class="headerlink" title="在Linux上安装Docker"></a>在Linux上安装Docker</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # 系统内核是3.10以上的</span><br><span class="line">root@theSun:&#x2F;# uname -r</span><br><span class="line">4.4.0-185-generic</span><br><span class="line"></span><br><span class="line"># 系统版本</span><br><span class="line">root@theSun:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="meta">#</span><span class="bash"> step 2: 安装GPG证书</span></span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="meta">#</span><span class="bash"> Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Step 4: 更新并安装 Docker-CE</span></span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get -y install docker-ce</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker image</span><br><span class="line"></span><br><span class="line">卸载：</span><br><span class="line">1、卸载依赖</span><br><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br><span class="line">2、删除资源</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
<h2 id="Docker安装部署RabbitMQ"><a href="#Docker安装部署RabbitMQ" class="headerlink" title="Docker安装部署RabbitMQ"></a>Docker安装部署RabbitMQ</h2><p>这里注意获取镜像的时候要获取management版本的，不要获取last版本的，management版本的才带有管理界面。</p>
<h3 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">search</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br></pre></td></tr></table></figure>
<p>可以看到如下结果：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># docker search rabbitmq:management</span></span><br><span class="line">INDEX       NAME                                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/macintoshplus/rabbitmq-management   Based <span class="keyword">on</span> rabbitmq:management whit python a...   <span class="number">1</span>                    [OK]</span><br><span class="line">docker.io   docker.io/transmitsms/rabbitmq-sharded        Fork of rabbitmq:management <span class="keyword">with</span> sharded_e...   <span class="number">0</span></span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta">#</span></span><br></pre></td></tr></table></figure>


<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br></pre></td></tr></table></figure>
<p>可以看到如下结果</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># docker pull rabbitmq:management</span></span><br><span class="line">Trying to pull repository docker.io/library/rabbitmq ...</span><br><span class="line">management: Pulling <span class="keyword">from</span> docker.io/library/rabbitmq</span><br><span class="line">e7bb522d92ff: Pull complete</span><br><span class="line">ad90649c4d84: Pull complete</span><br><span class="line"><span class="number">5</span>a318b914d6c: Pull complete</span><br><span class="line">cedd60f70052: Pull complete</span><br><span class="line">f4ec28761801: Pull complete</span><br><span class="line">b8fa44aa9074: Pull complete</span><br><span class="line">e8002a209c24: Pull complete</span><br><span class="line">cd1206edcd43: Pull complete</span><br><span class="line"><span class="number">769b</span>e0727074: Pull complete</span><br><span class="line"><span class="number">7308b</span>93d35af: Pull complete</span><br><span class="line">c4102ef22c29: Pull complete</span><br><span class="line">fefc8e1aa4b5: Pull complete</span><br><span class="line">a271d400045b: Pull complete</span><br><span class="line">b0d4c40c62de: Pull complete</span><br><span class="line">Digest: sha256:<span class="number">8761</span>de2c22badfc86dfe89791dc9dbf122f67ff0f8981966573d267af421b97f</span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-d</span> <span class="selector-tag">-p</span> 5672<span class="selector-pseudo">:5672</span> <span class="selector-tag">-p</span> 15672<span class="selector-pseudo">:15672</span> <span class="selector-tag">--name</span> <span class="selector-tag">rabbitmq</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br></pre></td></tr></table></figure>
<p>看到如下结果，变成功了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-d</span> <span class="selector-tag">-p</span> 5672<span class="selector-pseudo">:5672</span> <span class="selector-tag">-p</span> 15672<span class="selector-pseudo">:15672</span> <span class="selector-tag">--name</span> <span class="selector-tag">rabbitmq</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br><span class="line"><span class="selector-tag">e194a2dbeb52f2296dfb6d1c527cf052d82be5ed9a4c974d70dcd6af3da3eb7e</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span>#</span><br></pre></td></tr></table></figure>


<h3 id="访问管理页面"><a href="#访问管理页面" class="headerlink" title="访问管理页面"></a>访问管理页面</h3><p>访问管理界面的地址就是 http://[宿主机IP]:15672，可以使用默认的账户登录，用户名和密码都guest，如：</p>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/01.png" class>

<blockquote>
<p><strong>需要注意的是</strong>：</p>
<ul>
<li>在云服务器上，默认情况下，RabbitMQ的端口号15672是不开放的，需要自己登陆控制台添加安全组规则，放开对15672端口号的访问限制。</li>
<li>Linux系统上，宿主IP地址直接就是该系统的公网地址。</li>
</ul>
</blockquote>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/02.png" class>

<h2 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h2><h3 id="找到一个合适的docker的redis的版本"><a href="#找到一个合适的docker的redis的版本" class="headerlink" title="找到一个合适的docker的redis的版本"></a>找到一个合适的docker的redis的版本</h3><p>可以去docker hub中去找一下</p>
<p><a href="https://hub.docker.com/_/redis?tab=tags">https://hub.docker.com/_/redis?tab=tags</a></p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/03.png" class>

<h3 id="使用docker安装redis"><a href="#使用docker安装redis" class="headerlink" title="使用docker安装redis"></a>使用docker安装redis</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo docker pull redis</span><br></pre></td></tr></table></figure>
<p>安装好之后使用<code>docker images即可查看</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ </span><br><span class="line">truedei@truedei:~$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              987b78fc9e38        <span class="number">10</span> days ago         104MB</span><br><span class="line">httpd               latest              a8a9cbaadb0c        <span class="number">2</span> weeks ago         166MB</span><br><span class="line">fjudith/draw.io     latest              7b136fc80d31        <span class="number">3</span> weeks ago         683MB</span><br><span class="line">mysql               <span class="number">5.7</span><span class="number">.29</span>              f5829c0eee9e        <span class="number">5</span> weeks ago         455MB</span><br><span class="line">truedei@truedei:~$ </span><br><span class="line">truedei@truedei:~$ </span><br></pre></td></tr></table></figure>
<h3 id="准备redis"><a href="#准备redis" class="headerlink" title="准备redis"></a>准备redis</h3><p>因为需要<a href="https://cloud.tencent.com/product/crs?from=10680">redis</a>的配置文件，这里最好还是去redis的官方去下载一个redis使用里面的配置文件即可</p>
<p>redis中文官方网站：<a href="http://www.redis.cn/download.html">http://www.redis.cn/download.html</a></p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/04.png" class>

<p>下载后解压出来： </p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/05.png" class>

<p>这个<code>redis.conf</code>文件就是咱们需要的，为了保险，还是拷贝一下，做个备份。</p>
<h3 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h3><p><strong>修改<code>redis.conf</code>配置文件：</strong> 主要配置的如下：</p>
<blockquote>
<p> <code>bind 127.0.0.1</code> #注释掉这部分，使redis可以外部访问 <code>daemonize no</code>#用守护线程的方式启动 <code>requirepass 你的密码</code>#给redis设置密码 <code>appendonly yes</code>#redis持久化　　默认是no <code>tcp-keepalive 300</code> #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300 </p>
</blockquote>
<h3 id="创建本地与docker映射的目录，即本地存放的位置"><a href="#创建本地与docker映射的目录，即本地存放的位置" class="headerlink" title="创建本地与docker映射的目录，即本地存放的位置"></a>创建本地与docker映射的目录，即本地存放的位置</h3><p>创建本地存放redis的位置;</p>
<blockquote>
<p> 可以自定义，因为我的docker的一些配置文件都是存放在<code>/data</code>目录下面的，所以我依然在<code>/data</code>目录下创建一个<code>redis</code>目录，这样是为了方便后期管理 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ sudo mkdir /data/redis</span><br><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ sudo mkdir /data/redis/data</span><br></pre></td></tr></table></figure>
<p>把<code>配置文件</code>拷贝到刚才创建好的文件里</p>
<blockquote>
<p> 因为我本身就是Linux操作系统，所以我可以直接拷贝过去，如果你是windows的话，可能需要使用ftp拷贝过去，或者直接复制内容，然后粘贴过去。 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ sudo cp -p redis.conf /data/redis/</span><br><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ </span><br></pre></td></tr></table></figure>
<h3 id="启动docker-redis"><a href="#启动docker-redis" class="headerlink" title="启动docker redis"></a>启动docker redis</h3><p>启动：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ sudo docker run -p <span class="number">6379</span>:<span class="number">6379</span> --name redis -v /data/redis/redis.conf:<span class="regexp">/etc/</span>redis/redis.conf  -v /data/redis/data:<span class="regexp">/data -d redis redis-server /</span>etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<blockquote>
<p> <code>-p 6379:6379</code>:把容器内的6379端口映射到<a href="https://cloud.tencent.com/product/cdh?from=10680">宿主机</a>6379端口 <code>-v /data/redis/redis.conf:/etc/redis/redis.conf</code>：把宿主机配置好的redis.conf放到容器内的这个位置中 <code>-v /data/redis/data:/data</code>：把redis持久化的数据在宿主机内显示，做数据备份 <code>redis-server /etc/redis/redis.conf</code>：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动 <code>–appendonly yes</code>：redis启动后数据持久化 </p>
</blockquote>
<h3 id="查看是否启动成功"><a href="#查看是否启动成功" class="headerlink" title="查看是否启动成功"></a>查看是否启动成功</h3><p>查看是否成功启动：<code>sudo docker ps</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">85cb7d83a2ff        redis               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   <span class="number">7</span> minutes ago       Up <span class="number">7</span> minutes        <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">6379</span>-&gt;<span class="number">6379</span>/tcp              redis</span><br><span class="line">0a122a08125f        mysql:<span class="number">5.7</span><span class="number">.29</span>        <span class="string">&quot;docker-entrypoint.s…&quot;</span>   <span class="number">5</span> weeks ago         Up About an hour    <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3306</span>-&gt;<span class="number">3306</span>/tcp, <span class="number">33060</span>/tcp   mysql57</span><br><span class="line">truedei@truedei:~$ </span><br></pre></td></tr></table></figure>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/06.png" class>

<p>可以查看一下日志：<code>sudo docker logs redis</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ sudo docker logs redis</span><br><span class="line">1:C 29 May 2020 01:16:22.107 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">1:C 29 May 2020 01:16:22.107 # Redis version=6.0.3, bits=64, commit=00000000, modified=0, pid=1, just started</span><br><span class="line">1:C 29 May 2020 01:16:22.107 # Configuration loaded</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-<span class="string">``</span>__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-<span class="string">``</span>    <span class="string">`.  `</span>_.  <span class="string">&#x27;&#x27;</span>-._           Redis <span class="number">6.0</span><span class="number">.3</span> (<span class="number">00000000</span>/<span class="number">0</span>) <span class="number">64</span> bit</span><br><span class="line">  .-<span class="string">``</span> .-<span class="string">``</span><span class="string">`.  `</span><span class="string">``</span>\/    _.,_ <span class="string">&#x27;&#x27;</span>-._                                   </span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span><span class="string">` _.-&#x27;|     Port: 6379</span></span><br><span class="line"><span class="string"> |    `</span>-._   <span class="string">`._    /     _.-&#x27;    |     PID: 1</span></span><br><span class="line"><span class="string">  `</span>-._    <span class="string">`-._  `</span>-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |<span class="string">`-._`</span>-._    <span class="string">`-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `</span>-._<span class="string">`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span></span><br><span class="line"><span class="string">  `</span>-._    <span class="string">`-._`</span>-.__.-<span class="string">&#x27;_.-&#x27;</span>    _.-<span class="string">&#x27;                                   </span></span><br><span class="line"><span class="string"> |`-._`-._    `-.__.-&#x27;</span>    _.-<span class="string">&#x27;_.-&#x27;</span>|                                  </span><br><span class="line"> |    <span class="string">`-._`</span>-._        _.-<span class="string">&#x27;_.-&#x27;</span>    |                                  </span><br><span class="line">  <span class="string">`-._    `</span>-._<span class="string">`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span></span><br><span class="line"><span class="string">      `</span>-._    <span class="string">`-.__.-&#x27;    _.-&#x27;                                       </span></span><br><span class="line"><span class="string">          `</span>-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">1:M 29 May 2020 01:16:22.108 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">1:M 29 May 2020 01:16:22.108 # Server initialized</span><br><span class="line">1:M 29 May 2020 01:16:22.108 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span><br><span class="line">1:M 29 May 2020 01:16:22.108 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line"><span class="number">1</span>:M <span class="number">29</span> May <span class="number">2020</span> <span class="number">01</span>:<span class="number">16</span>:<span class="number">22.108</span> * Ready to accept connections</span><br><span class="line">truedei@truedei:~$ </span><br></pre></td></tr></table></figure>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/07.png" class>

<h2 id="Docker安装MongoDB"><a href="#Docker安装MongoDB" class="headerlink" title="Docker安装MongoDB"></a>Docker安装MongoDB</h2><p>MongoDB 是一个免费的开源跨平台面向文档的 NoSQL 数据库程序。</p>
<h3 id="1、查看可用的-MongoDB-版本"><a href="#1、查看可用的-MongoDB-版本" class="headerlink" title="1、查看可用的 MongoDB 版本"></a>1、查看可用的 MongoDB 版本</h3><p>访问 MongoDB 镜像库地址： <a href="https://hub.docker.com/_/mongo?tab=tags&amp;page=1%E3%80%82">https://hub.docker.com/_/mongo?tab=tags&amp;page=1。</a></p>
<p>可以通过 Sort by 查看其他版本的 MongoDB，默认是最新版本 <strong>mongo:latest</strong>。</p>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/08.png" class>

<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/09.png" class>

<p>此外，我们还可以用  docker search mongo 命令来查看可用版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search mongo</span></span><br><span class="line">NAME                              DESCRIPTION                      STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mongo                             MongoDB document databases ...   1989      [OK]       </span><br><span class="line">mongo-express                     Web-based MongoDB admin int...   22        [OK]       </span><br><span class="line">mvertes/alpine-mongo              light MongoDB container          19                   [OK]</span><br><span class="line">mongooseim/mongooseim-docker      MongooseIM server the lates...   9                    [OK]</span><br><span class="line">torusware/speedus-mongo           Always updated official Mon...   9                    [OK]</span><br><span class="line">jacksoncage/mongo                 Instant MongoDB sharded cluster  6                    [OK]</span><br><span class="line">mongoclient/mongoclient           Official docker image for M...   4                    [OK]</span><br><span class="line">jadsonlourenco/mongo-rocks        Percona Mongodb with Rocksd...   4                    [OK]</span><br><span class="line">asteris/apache-php-mongo          Apache2.4 + PHP + Mongo + m...   2                    [OK]</span><br><span class="line">19hz/mongo-container              Mongodb replicaset for coreos    1                    [OK]</span><br><span class="line">nitra/mongo                       Mongo3 centos7                   1                    [OK]</span><br><span class="line">ackee/mongo                       MongoDB with fixed Bluemix p...  1                    [OK]</span><br><span class="line">kobotoolbox/mongo                 https://github.com/kobotoolb...  1                    [OK]</span><br><span class="line">valtlfelipe/mongo                 Docker Image based on the la...  1                    [OK]</span><br></pre></td></tr></table></figure>
<h3 id="2、取最新版的-MongoDB-镜像"><a href="#2、取最新版的-MongoDB-镜像" class="headerlink" title="2、取最新版的 MongoDB 镜像"></a>2、取最新版的 MongoDB 镜像</h3><p>这里我们拉取官方的最新版本的镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker pull mongo:latest</span><br></pre></td></tr></table></figure>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/12.png" class>

<h3 id="3、查看本地镜像"><a href="#3、查看本地镜像" class="headerlink" title="3、查看本地镜像"></a>3、查看本地镜像</h3><p>使用以下命令来查看是否已安装了 mongo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/13.png" class>

<h3 id="4、运行容器"><a href="#4、运行容器" class="headerlink" title="4、运行容器"></a>4、运行容器</h3><p>安装完成后，我们可以使用以下命令来运行 mongo 容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name mongo -p 27017:27017 mongo --auth</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>-p 27017:27017</strong> ：映射容器服务的 27017 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务。</li>
<li><strong>–auth</strong>：需要密码才能访问容器服务。</li>
</ul>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/10.png" class>

<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/11.png" class>



<h2 id="Docker安装ElasticSearch"><a href="#Docker安装ElasticSearch" class="headerlink" title="Docker安装ElasticSearch"></a>Docker安装ElasticSearch</h2><h3 id="下载ElasticSearch"><a href="#下载ElasticSearch" class="headerlink" title="下载ElasticSearch"></a>下载ElasticSearch</h3><blockquote>
<p>docker pull elasticsearch:6.8.6</p>
</blockquote>
<h3 id="运行ElasticSearch"><a href="#运行ElasticSearch" class="headerlink" title="运行ElasticSearch"></a>运行ElasticSearch</h3><blockquote>
<p>docker run -d –name elasticsearch -p 9200:9200 -p 9300:9300 -e “discovery.type=single-node”  -e “ES_JAVA_OPTS=-Xms512m -Xmx512m” elasticsearch:6.8.6</p>
</blockquote>
<h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><blockquote>
<p>docker ps</p>
</blockquote>
<h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p>网页输入：“主机地址:9200”，出现如下json数据，即成功！<strong>同样需要放开端口</strong></p>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/14.png" class>

<h2 id="Docker安装MySQL"><a href="#Docker安装MySQL" class="headerlink" title="Docker安装MySQL"></a>Docker安装MySQL</h2><h2 id="Docker安装JDK"><a href="#Docker安装JDK" class="headerlink" title="Docker安装JDK"></a>Docker安装JDK</h2><h2 id="Docker安装Nginx和Tomcat"><a href="#Docker安装Nginx和Tomcat" class="headerlink" title="Docker安装Nginx和Tomcat"></a>Docker安装Nginx和Tomcat</h2>]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>创建一个Vue实例</title>
    <url>/2021/03/07/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="创建一个Vue实例"><a href="#创建一个Vue实例" class="headerlink" title="创建一个Vue实例"></a>创建一个Vue实例</h2><p>虽然没有完全遵循 <a href="https://zh.wikipedia.org/wiki/MVVM">MVVM 模型</a>，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (ViewModel 的缩写) 这个变量名表示 Vue 实例。</p>
<p>当创建一个 Vue 实例时，你可以传入一个<strong>选项对象</strong> </p>
<p>一个 Vue 应用由一个通过 <code>new Vue</code> 创建的<strong>根 Vue 实例</strong>，以及可选的嵌套的、可复用的组件树组成。举个例子，一个 todo 应用的组件树可以是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根实例</span><br><span class="line">└─ TodoList</span><br><span class="line">   ├─ TodoItem</span><br><span class="line">   │  ├─ TodoButtonDelete</span><br><span class="line">   │  └─ TodoButtonEdit</span><br><span class="line">   └─ TodoListFooter</span><br><span class="line">      ├─ TodosButtonClear</span><br><span class="line">      └─ TodoListStatistics</span><br></pre></td></tr></table></figure>
<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，<strong>视图</strong>将会产生“响应”，即匹配更新为新的值</p>
<p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的 property 才是<strong>响应式</strong>的。也就是说如果你添加一个新的 property，</p>
<p>你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  newTodoText: &#39;&#39;,</span><br><span class="line">  visitCount: 0,</span><br><span class="line">  hideCompletedTodos: false,</span><br><span class="line">  todos: [],</span><br><span class="line">  error: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>Object.freeze()</code>，这会阻止修改现有的 property，也意味着响应系统无法再<em>追踪</em>变化。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">var obj = &#123;</span><br><span class="line">	foot:&#x27;bar&#x27;</span><br><span class="line">&#125;</span><br><span class="line">Object.freeze(obj)</span><br><span class="line">new Vue(&#123;</span><br><span class="line">	el:&#x27;#app&#x27;</span><br><span class="line">	data: obj</span><br><span class="line">&#125;)     //没办法对obj进行修改</span><br></pre></td></tr></table></figure>
<p><a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">选项对象API</a></p>
<p>有用的property与方法，带有前缀$,以便于用户定义的property区分开</p>
<p><a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B-property">具体API文档</a></p>
<h2 id="实例的生命周期"><a href="#实例的生命周期" class="headerlink" title="实例的生命周期"></a>实例的生命周期</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 <a href="https://cn.vuejs.org/v2/api/#created"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: function () &#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    console.log(<span class="string">&#x27;a is: &#x27;</span> + <span class="keyword">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; &quot;a is: 1&quot;</span></span><br></pre></td></tr></table></figure>
<p> 有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://cn.vuejs.org/v2/api/#mounted"><code>mounted</code></a>、<a href="https://cn.vuejs.org/v2/api/#updated"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/v2/api/#destroyed"><code>destroyed</code></a>。<u>生命周</u><u>期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例</u>。</p>
<blockquote>
<p>不要在选项 property 或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。**因为箭头函数并没有 <code>this</code>**，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
</blockquote>
<p>生命周期的图示</p>
<img data-src="/2021/03/07/%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAVue%E5%AE%9E%E4%BE%8B/lifecycle.png" class>





]]></content>
      <categories>
        <category>Vue框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列MQ</title>
    <url>/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/</url>
    <content><![CDATA[<h2 id="MQ的基本概念"><a href="#MQ的基本概念" class="headerlink" title="MQ的基本概念"></a>MQ的基本概念</h2><p>MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。 当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。</p>
<p>当你需要使用消息队列时，首先需要考虑它的必要性。可以使用mq的场景有很多，最常用的几种，是做业务解耦/最终一致性/广播/错峰流控等。反之，如果需要强一致性，关注业务逻辑的处理结果，则RPC显得更为合适</p>
<p>如果没有消息队列，分布式系统之间可能互相通过远程调用来实现不同系统之间的访问。</p>
 <img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/01.png" class>

<p>MQ，消息队列，存储消息的<strong>中间件</strong>,分布式系统通信两种方式：直接远程调用 和 借助第三方 完成间接通信,发送方称为生产者，接收方称为消费者。</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/02.png" class>

<h2 id="MQ的优势与劣势"><a href="#MQ的优势与劣势" class="headerlink" title="MQ的优势与劣势"></a>MQ的优势与劣势</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><blockquote>
<p>应用解耦</p>
</blockquote>
<p>解耦是消息队列要解决的最本质问题。所谓解耦，简单点讲就是一个事务，只关心核心的流程。而需要依赖其他系统但不那么重要的事情，**==有通知即可，无需等待结果==**。换句话说，基于消息的模型，关心的是“通知”，而非“处理”。 </p>
<p>比如在美团旅游，我们有一个产品中心，产品中心上游对接的是主站、移动后台、旅游供应链等各个数据源；下游对接的是筛选系统、API系统等展示系统。当上游的数据发生变更的时候，如果不使用消息系统，势必要调用我们的接口来更新数据，就特别依赖产品中心接口的稳定性和处理能力。但其实，作为旅游的产品中心，也许只有对于旅游自建供应链，产品中心更新成功才是他们关心的事情。而对于团购等外部系统，产品中心更新成功也好、失败也罢，并不是他们的职责所在。他们只需要保证在信息变更的时候通知到我们就好了。 而我们的下游，可能有更新索引、刷新缓存等一系列需求。对于产品中心来说，这也不是我们的职责所在。说白了，如果他们定时来拉取数据，也能保证数据的更新，只是实时性没有那么强。但使用接口方式去更新他们的数据，显然对于产品中心来说太过于“重量级”了，只需要发布一个产品ID变更的通知，由下游系统来处理，可能更为合理。 再举一个例子，对于我们的订单系统，订单最终支付成功之后可能需要给用户发送短信积分什么的，但其实这已经不是我们系统的核心流程了。如果外部系统速度偏慢（比如短信网关速度不好），那么主流程的时间会加长很多，用户肯定不希望点击支付过好几分钟才看到结果。那么我们只需要通知短信系统“我们支付成功了”，不一定非要等待它处理完成。</p>
 <img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/03.png" class>

<p>例如，在上面的例子中，订单系统过分依赖剩余四个系统。用户向订单系统发送消息，订单系统分别向下层的四个系统传递用户消息。这样一来，不仅时间上效率很低，而且，一旦下层的某个系统挂掉，订单系统以及上层用户迟迟得不到反馈，这对于“争分夺秒”的电商行业是不能承受的。而添加了MQ之后，订单系统只需要将消息发给MQ，并且MQ可以先行通知用户操作成功，而不一定非要等到下层子系统操作完成之后在进行反馈。同时，如果下层系统挂掉(通常很快就可以修复，只有几分钟，但是对业务的影响是巨大的），订单系统因为由消息队列的存在，仍旧可以给予用户反馈，提升了客户的访问体验。</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/04.png" class>

<blockquote>
<p>异步提速，削峰填谷</p>
</blockquote>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/05.png" class>

<p><strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p>
<p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/06.png" class>

<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/07.png" class>

<p>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<blockquote>
<p>利用消息队列实现事件驱动结构</p>
</blockquote>
<p>最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/08.png" class>

<p><strong>消息队列利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong></p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。</strong> 另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</p>
<blockquote>
<p>广播</p>
</blockquote>
<p>消息队列的基本功能之一是进行广播。如果没有消息队列，每当一个新的业务方接入，我们都要联调一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。 比如本文开始提到的产品中心发布产品变更的消息，以及景点库很多去重更新的消息，可能“关心”方有很多个，但产品中心和景点库只需要发布变更消息即可，谁关心谁接入。</p>
<blockquote>
<p>错峰与流控</p>
</blockquote>
<p>试想上下游对于事情的处理能力是不同的。比如，Web前端每秒承受上千万的请求，并不是什么神奇的事情，只需要加多一点机器，再搭建一些LVS负载均衡设备和Nginx等即可。但<strong>数据库的处理能力却十分有限</strong>，即使使用SSD加分库分表，单机的处理能力仍然在万级。由于成本的考虑，我们不能奢求数据库的机器数量追上前端。 这种问题同样存在于系统和系统之间，如短信系统可能由于短板效应，速度卡在网关上（每秒几百次请求），跟前端的并发量不是一个数量级。但用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过协商、滑动窗口等复杂的方案也不是说不能实现。但系统复杂性指数级增长，势必在上游或者下游做存储，并且要处理定时、拥塞等一系列问题。而且每当有处理能力有差距的时候，都需要单独开发一套逻辑来维护这套逻辑。所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p>
<p>总而言之，消息队列不是万能的。<strong>对于需要强事务保证而且延迟敏感的，RPC是优于消息队列</strong>的。 <strong>对于一些无关痛痒，或者对于别人非常重要但是对于自己不是那么关心的事情，可以利用消息队列去做。</strong> 支持最终一致性的消息队列，能够用来处理<strong>延迟不那么敏感</strong>的“分布式事务”场景，而且相对于笨重的分布式事务，可能是更优的处理方式。 当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的“漏斗”。在下游有能力处理的时候，再进行分发。 如果下游有很多系统关心你的系统发出的通知的时候，果断地使用消息队列吧</p>
<h3 id="MQ的劣势"><a href="#MQ的劣势" class="headerlink" title="MQ的劣势"></a>MQ的劣势</h3><blockquote>
<p>一致性问题</p>
</blockquote>
<p>A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？</p>
<p>最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。当然有个时间限制，理论上越快越好，但实际上在各种异常的情况下，可能会有一定延迟达到最终一致状态，但最后两个系统的状态是一样的。 </p>
<p>业界有一些为“最终一致性”而生的消息队列，如Notify（阿里）、QMQ（去哪儿）等，其设计初衷，就是为了交易系统中的高可靠通知。 </p>
<p>以一个银行的转账过程来理解最终一致性，转账的需求很简单，如果A系统扣钱成功，则B系统加钱一定成功。反之则一起回滚，像什么都没发生一样。 然而，这个过程中存在很多可能的意外： 1. A扣钱成功，调用B加钱接口失败。 2. A扣钱成功，调用B加钱接口虽然成功，但获取最终结果时网络异常引起超时。 3. A扣钱成功，B加钱失败，A想回滚扣的钱，但A机器down机。</p>
<p>可见，想把这件看似简单的事真正做成，真的不那么容易。所有跨VM的一致性问题，从技术的角度讲通用的解决方案是：</p>
<ul>
<li><p>强一致性，分布式事务，但落地太难且成本太高。</p>
</li>
<li><p>最终一致性，主要是用“记录”和“补偿”的方式。在做所有的不确定的事情之前，先把事情记录下来，然后去做不确定的事情，结果可能是：成功、失败或是不确定，“不确定”（例如超时等）可以等价为失败。成功就可以把记录的东西清理掉了，对于失败和不确定，可以依靠定时任务等方式把所有失败的事情重新搞一遍，直到成功为止。</p>
<p> 回到刚才的例子，系统在A扣钱成功的情况下，把要给B“通知”这件事记录在库里（为了保证最高的可靠性可以把通知B系统加钱和扣钱成功这两件事维护在一个本地事务里），通知成功则删除这条记录，通知失败或不确定则依靠定时任务补偿性地通知我们，直到我们把状态更新成正确的为止。 整个这个模型依然可以基于RPC来做，但可以抽象成一个统一的模型，基于消息队列来做一个“企业总线”。 具体来说，本地事务维护业务变化和通知消息，一起落地（失败则一起回滚），然后RPC到达broker，在broker成功落地后，RPC返回成功，本地消息可以删除。否则本地消息一直靠定时任务轮询不断重发，这样就保证了消息可靠落地broker。 broker往consumer发送消息的过程类似，一直发送消息，直到consumer发送消费成功确认。 我们先不理会重复消息的问题，通过两次消息落地加补偿，下游是一定可以收到消息的。然后依赖状态机版本号等方式做判重，更新自己的业务，就实现了最终一致性。</p>
</li>
</ul>
<blockquote>
<p>系统可用性降低</p>
</blockquote>
<p>系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/09.png" class>



<blockquote>
<p>系统复杂度提高</p>
</blockquote>
<p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p>
<h2 id="MQ的应用场景"><a href="#MQ的应用场景" class="headerlink" title="MQ的应用场景"></a>MQ的应用场景</h2><p>①生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p>
<p>②容许短暂的不一致性。</p>
<p>③确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>初识动态规划</title>
    <url>/2021/02/03/%E5%88%9D%E8%AF%86%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>双指针问题</title>
    <url>/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="环形列表I"><a href="#环形列表I" class="headerlink" title="环形列表I"></a>环形列表I</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p> 进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p> 示例 1：</p>
<p> <img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114100453506.png" alt="image-20210114100453506"></p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114100714252.png" alt="image-20210114100714252"></p>
<p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114100749569.png" alt="image-20210114100749569" style="zoom:150%;">

<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;= Node.val &lt;= 105<br>pos 为 -1 或者链表中的一个 有效索引 </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>####方法一：哈希表<br>思路及算法</p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolen <span class="title">hascirle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        Set&lt;ListNOde&gt; seen = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>( head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen.add(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####复杂度分析</p>
<p>时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p>
<p>空间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>
<h4 id="方式二；双指针–快慢指针"><a href="#方式二；双指针–快慢指针" class="headerlink" title="方式二；双指针–快慢指针"></a>方式二；双指针–快慢指针</h4><p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<p> 为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>
<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p>
<p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">puclic <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolen <span class="title">hascycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。</p>
<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 NN 轮。</p>
<p>空间复杂度：O(1)O(1)。我们只使用了两个指针的额外空间</p>
<h2 id="环形列表II"><a href="#环形列表II" class="headerlink" title="环形列表II"></a>环形列表II</h2><h3 id="题目说明-1"><a href="#题目说明-1" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：</p>
<p>你是否可以使用 O(1) 空间解决此题？</p>
<p> 示例 1：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114102706369.png" alt="image-20210114102706369"></p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114102721841.png" alt="image-20210114102721841"></p>
<p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114102737481.png" alt="image-20210114102737481"></p>
<p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p>
<p>提示：</p>
<p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;= Node.val &lt;= 105<br>pos 的值为 -1 或者链表中的一个有效索引</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。</p>
<p>空间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。</p>
<h4 id="方法二：双指针–快慢指针"><a href="#方法二：双指针–快慢指针" class="headerlink" title="方法二：双指针–快慢指针"></a>方法二：双指针–快慢指针</h4><p>我们使用两个指针，\textit{fast}fast 与 \textit{slow}slow。它们起始都位于链表的头部。随后，\textit{slow}slow 指针每次向后移动一个位置，而 \textit{fast}fast 指针向后移动两个位置。如果链表中存在环，则 \textit{fast}fast 指针最终将再次与 \textit{slow}slow 指针在环中相遇。</p>
<p>如下图所示，设链表中环外部分的长度为 aa。\textit{slow}slow 指针进入环后，又走了 bb 的距离与 \textit{fast}fast 相遇。此时，\textit{fast}fast 指针已经走完了环的 nn 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc</p>
 <img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114103031586.png" alt="image-20210114103031586" style="zoom:50%;">

<p>根据题意，任意时刻，\textit{fast}fast 指针走过的距离都为 \textit{slow}slow 指针的 22 倍。因此，我们有</p>
<p>a+(n+1)b+nc=2(a+b) \implies a=c+(n-1)(b+c)<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)</p>
<p>有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p>
<p>因此，当发现 \textit{slow}slow 与 \textit{fast}fast 相遇时，我们再额外使用一个指针 \textit{ptr}ptr。起始，它指向链表头部；随后，它和 \textit{slow}slow 每次向后移动一个位置。最终，它们会在入环点相遇。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#####复杂度分析</p>
<p>时间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。在最初判断快慢指针是否相遇时，\textit{slow}slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)O(N)+O(N)=O(N)。</p>
<p>空间复杂度：O(1)O(1)。我们只使用了 \textit{slow}, \textit{fast}, \textit{ptr}slow,fast,ptr 三个指针。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>初识递归</title>
    <url>/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="二叉搜索树的范围和"><a href="#二叉搜索树的范围和" class="headerlink" title="二叉搜索树的范围和"></a>二叉搜索树的范围和</h2><h3 id="DFS深度优先搜索"><a href="#DFS深度优先搜索" class="headerlink" title="DFS深度优先搜索"></a>DFS深度优先搜索</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">       ans = <span class="number">0</span> ;</span><br><span class="line">        dfs(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L&lt;=node.val&amp;&amp;node.val&lt;=R)&#123;</span><br><span class="line">                ans+=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.val&gt;L)&#123;</span><br><span class="line">                dfs(node.left,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.val&lt;R)&#123;</span><br><span class="line">                dfs(node.right,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.val&gt;=low&amp;&amp;node.val&lt;=high)&#123;</span><br><span class="line">                    ans+=node.val;             <span class="comment">//注意：在这里不要写成ans+=node;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.val&gt;low)&#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.val&lt;high)&#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeftHight = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> maxRightHighgt = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(maxLeftHight,maxRightHighgt)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/01.png" class>



<h2 id="面试题：汉诺塔"><a href="#面试题：汉诺塔" class="headerlink" title="面试题：汉诺塔"></a>面试题：汉诺塔</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:</span><br><span class="line">(1) 每次只能移动一个盘子;</span><br><span class="line">(2) 盘子只能从柱子顶端滑出移到下一根柱子;</span><br><span class="line">(3) 盘子只能叠在比它大的盘子上。</span><br><span class="line"></span><br><span class="line">请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</span><br><span class="line"></span><br><span class="line">你需要原地修改栈。</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/02.gif" class>





<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/03.gif" class>







<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        将A柱子上面的盘子，通过辅助柱子B移动到C柱子的上面，需要用到递归和分治的算法</span></span><br><span class="line"><span class="comment">        先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；</span></span><br><span class="line"><span class="comment">		再将最大的盘子从 A 移到 C；</span></span><br><span class="line"><span class="comment">		再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> n = A.size();  <span class="comment">//先用n来表示柱子A上盘子的规模</span></span><br><span class="line">        moveable(n,A,B,C);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveable</span><span class="params">(<span class="keyword">int</span> num,List&lt;Integer&gt;A,List&lt;Integer&gt; B,List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>));    <span class="comment">//只有一个盘子，直接移动即可</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            moveable(num-<span class="number">1</span>,A,C,B);         <span class="comment">//以C柱为辅助，将A柱上的n-1个圆盘移动至B柱</span></span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>));   <span class="comment">//将A柱的最大圆盘放在C柱底端</span></span><br><span class="line">            moveable(num-<span class="number">1</span>,B,A,C);         <span class="comment">//以A柱为辅助柱，将B柱的n-1个圆盘移动至C柱</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/04.png" class>





<h2 id="递归顺序查找树"><a href="#递归顺序查找树" class="headerlink" title="递归顺序查找树"></a>递归顺序查找树</h2><p>给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<p>示例 ：</p>
<p>输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] </p>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/05.png" class>

<h3 id="方法一：中序遍历-构造新的树"><a href="#方法一：中序遍历-构造新的树" class="headerlink" title="方法一：中序遍历+构造新的树"></a>方法一：中序遍历+构造新的树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//获取到了升序的数组vals</span></span><br><span class="line">        inorder(root,vals);</span><br><span class="line">        <span class="comment">//下面的过程是重构树的过程，要求没有左节点，只有右节点</span></span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode cur = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : vals)&#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.right;   <span class="comment">//返回的即为第一个节点，这里也体现出了设立ans的作用，类似于链表中的哨兵，在构建完成之后方便返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历-----递归部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; vals)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不要忘了node为空的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(node.left,vals);        <span class="comment">//从当前结点出发，先遍历左子树</span></span><br><span class="line">        vals.add(node.val);                 <span class="comment">//node的左子树遍历完成，将node加入数组</span></span><br><span class="line">        inorder(node.right,vals);       <span class="comment">//遍历当前节点的右子树，将其值加入数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/06.png" class>

<h3 id="方法二：中序递归遍历-更改树的连接关系"><a href="#方法二：中序递归遍历-更改树的连接关系" class="headerlink" title="方法二：中序递归遍历+更改树的连接关系"></a>方法二：中序递归遍历+更改树的连接关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode cur;    <span class="comment">//作为成员变量，可以被各个方法引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        cur = ans;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left);</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        cur.right = node;</span><br><span class="line">        cur = node;</span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="面试题：biNode"><a href="#面试题：biNode" class="headerlink" title="面试题：biNode"></a>面试题：biNode</h2><p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">    TreeNode prev = head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        makelist(root);</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makelist</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//采用中序遍历，最后会得到一个升序的单链表</span></span><br><span class="line">        <span class="comment">//最后返回的仍然是树，但是左子树为空，并且题目要求在原址修改，所以直接返回树即可</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        makelist(node.left);</span><br><span class="line">        prev.right = node;</span><br><span class="line">        prev = node;  </span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        makelist(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​      </p>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/07.png" class>



<p>这个图可以解释上面递归顺序查找树和biNode两道题中类似下面这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> cur.right = node;</span><br><span class="line"> cur = node;</span><br><span class="line"></span><br><span class="line">prev.right = node;</span><br><span class="line"> prev = node; </span><br></pre></td></tr></table></figure>
<p>第一条指令用于更新结点指向，后一天指令用于prev的指向，即指向下一个元素，方便下一次访问</p>
<h2 id="面试题16-11-跳水板"><a href="#面试题16-11-跳水板" class="headerlink" title="面试题16.11 跳水板"></a>面试题16.11 跳水板</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
 <img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/08.png" class>



<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><p>给定一个二叉树，计算 整个树 的坡度 。</p>
<p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>
<p>整个树的坡度就是其<strong>所有节点的坡度之和。</strong></p>
 <img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/09.png" class>

<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/10.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量可以不赋初值，局部变量必须要赋初值，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        calculate(root);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后期需要用到，所以每次递归的结果用left和right接收一下</span></span><br><span class="line">        <span class="keyword">int</span> left = calculate(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = calculate(node.right);</span><br><span class="line">        count+=Math.abs(left-right);</span><br><span class="line">        <span class="keyword">return</span> left+right+node.val;    <span class="comment">//返回当前结点之和，便于下次递归使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/11.png" class>



























]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表easy篇总结</title>
    <url>/2021/03/11/%E5%93%88%E5%B8%8C%E8%A1%A8easy%E7%AF%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>##哈希表刷题总结</p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。</p>
<p>一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 xx 到首字母 F(x)F(x) 的一个函数关系），在首字母为 WW 的表中查找 “王” 姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母” 是这个例子中哈希函数的函数法则 F()F()，存放首字母的表对应哈希表。关键字和函数法则理论上可以任意确定。</p>
<p>哈希表是使用 O(1)O(1) 时间进行数据的插入删除和查找，但是哈希表不保证表中数据的有序性，<del>这样在哈希表中查找最大数据或者最小数据的时间是 O(N)O(N) 实现。</del>哈希表不支持需要元素间任何排序信息的操作，例如findMin、findMax或者打印输出排序号的整张表。</p>
<h3 id="设计哈希映射"><a href="#设计哈希映射" class="headerlink" title="设计哈希映射"></a>设计哈希映射</h3><p>哈希表是一个在不同语言中都有的通用数据结构。例如，Python 中的 dict 和 Java 中的 Hashmap。哈希表的特性是可以根据给出的 key 快速访问 value。</p>
<p>设计哈希表有两个问题需要去解决： 1). 如何设计哈希方法？ 和 2).如何避免哈希碰撞？ 。</p>
<p>1). 如何设计哈希方法？：哈希方法会将键值映射到某块存储空间，一个好的哈希方法应该将不同的键值 均匀 地分布在存储空间中。</p>
<p>2). 如何避免哈希碰撞？：哈希方法要将大量的键值映射到一个有限的空间里,这样就有可能会将不同的键值映射到同一个存储空间，这种情况称为 ‘哈希碰撞’ 。哈希碰撞是不可避免的，但可以用策略来解决哈希碰撞。</p>
<h3 id="1-有多少小于当前数字的数字"><a href="#1-有多少小于当前数字的数字" class="headerlink" title="1.有多少小于当前数字的数字"></a>1.有多少小于当前数字的数字</h3><p>####一、暴力求解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//第一种方法1：暴力求解法，逐一遍历除当前元素之外的所有元素</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        复杂度分析：</span></span><br><span class="line"><span class="comment">        空间复杂度为O(n)，需要存储新的答案数组</span></span><br><span class="line"><span class="comment">        时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span> newtime[] = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;length;h++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[h])&#123;</span><br><span class="line">                    time++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newtime[i] = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newtime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二、计数排序"><a href="#二、计数排序" class="headerlink" title="二、计数排序"></a>二、计数排序</h4><h4 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h4><h4 id="四、排序与映射结合"><a href="#四、排序与映射结合" class="headerlink" title="四、排序与映射结合"></a>四、排序与映射结合</h4><h3 id="2-第一个只出现一次的字符"><a href="#2-第一个只出现一次的字符" class="headerlink" title="2.第一个只出现一次的字符"></a>2.第一个只出现一次的字符</h3><h4 id="3-1哈希表的遍历"><a href="#3-1哈希表的遍历" class="headerlink" title="3.1哈希表的遍历"></a>3.1哈希表的遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] string = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:string)&#123;</span><br><span class="line">            dic.put(c,!dic.containsKey(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:string)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.get(c))</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">复杂度分析：</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>


<h4 id="3-2有序hash表的遍历"><a href="#3-2有序hash表的遍历" class="headerlink" title="3.2有序hash表的遍历"></a>3.2有序hash表的遍历</h4><p>哈希表是 去重 的，即哈希表中键值对数量 ≤ 字符串 s 的长度。因此，相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Boolean&gt; dic = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] string = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:string)&#123;</span><br><span class="line">            dic.put(c,!dic.containsKey(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Boolean&gt; d : dic.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(d.getValue())</span><br><span class="line">                <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-3补充知识：Java中的Character类"><a href="#3-3补充知识：Java中的Character类" class="headerlink" title="3.3补充知识：Java中的Character类"></a>3.3补充知识：Java中的Character类</h4><p>Character 类用于对单个字符进行操作。</p>
<p>Character 类在对象中包装一个基本类型 <strong>char</strong> 的值(类似于Integer与int的关系)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Unicode 字符表示形式</span></span><br><span class="line"><span class="keyword">char</span> uniChar = <span class="string">&#x27;\u039A&#x27;</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] charArray =&#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了<strong>包装类Character类</strong>。</p>
<p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：</p>
<p>在某些情况下，Java编译器会自动创建一个Character对象。</p>
<p>例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始字符 &#x27;a&#x27; 装箱到 Character 对象 ch 中</span></span><br><span class="line">Character ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 原始字符 &#x27;x&#x27; 用 test 方法装箱</span></span><br><span class="line"><span class="comment">// 返回拆箱的值到 &#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">char</span> c = test(<span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p><img data-src="/2021/03/11/%E5%93%88%E5%B8%8C%E8%A1%A8easy%E7%AF%87%E6%80%BB%E7%BB%93/Users\xinghaodong\AppData\Roaming\Typora\typora-user-images\image-20210202160601128.png" alt="image-20210202160601128"></p>
<p>###3.只出现一次的字符</p>
<p>####3.1哈希表两次遍历</p>
<p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Hash表的第一次遍历</span></span><br><span class="line">        HashMap&lt;Integer,Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            dic.put(i,!dic.containsKey(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.get(i))</span><br><span class="line">                <span class="keyword">return</span> i;   <span class="comment">//不能返回nums[i],这里的增强for循环中的i代表的是nums[]中的某一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;   <span class="comment">//当表示如不存在所求值时，，不能返回null,要返回-1.    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2位运算"><a href="#3-2位运算" class="headerlink" title="3.2位运算"></a>3.2位运算</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-3集合运算"><a href="#3-3集合运算" class="headerlink" title="3.3集合运算"></a>3.3集合运算</h4><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>
<h4 id="3-4集合放入与删除"><a href="#3-4集合放入与删除" class="headerlink" title="3.4集合放入与删除"></a>3.4集合放入与删除</h4><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>
<h3 id="4-岛屿的周长"><a href="#4-岛屿的周长" class="headerlink" title="4.岛屿的周长"></a>4.岛屿的周长</h3><p>####方法一：迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> land=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> border=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = grid.length;</span><br><span class="line">        <span class="keyword">int</span> k = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;k;h++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][h]==<span class="number">1</span>)&#123;</span><br><span class="line">                    land++;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;grid.length-<span class="number">1</span>&amp;&amp;grid[i+<span class="number">1</span>][h]==<span class="number">1</span>)&#123;</span><br><span class="line">                    border++;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="keyword">if</span>(h&lt;grid[<span class="number">0</span>].length-<span class="number">1</span>&amp;&amp;grid[i][h+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    border++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>*land-<span class="number">2</span>*border;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">找规律，凡是两个陆地相接，必然在最后的周长计算里面损失两个边长值</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h4 id="方法二：DFS深度优先搜索"><a href="#方法二：DFS深度优先搜索" class="headerlink" title="方法二：DFS深度优先搜索"></a>方法二：DFS深度优先搜索</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">从土地到土地，之间不会产生周长，但从土地迈入海洋，之间会产生 1 个周长，从土地迈出矩阵边界，也会产生 1 个周长。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfsfunction</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][]grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=grid.length||j&lt;<span class="number">0</span>||j&gt;=grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//当前正好要越界，周长值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//说明从陆地来到了海上，周长值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//DFS需要记录状态，避免重复访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="number">2</span>; <span class="comment">//到此，该节点已经访问完毕，状态变更</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从当前模块开始，向上下左右进行遍历，其实有递归的思想，最后的结果随着递归的出栈，子问题的解自上而下的返回，最终得出大问题的解</span></span><br><span class="line">        <span class="keyword">return</span> dfsfunction(i-<span class="number">1</span>,j,grid)+dfsfunction(i,j-<span class="number">1</span>,grid)+dfsfunction(i+<span class="number">1</span>,j,grid)+dfsfunction(i,j+<span class="number">1</span>,grid);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                       <span class="keyword">return</span> dfsfunction(i,j,grid); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="官方题解1-迭代—-利用算子"><a href="#官方题解1-迭代—-利用算子" class="headerlink" title="官方题解1:迭代—-利用算子"></a>官方题解1:迭代—-利用算子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || grid[tx][ty] == <span class="number">0</span>) &#123;</span><br><span class="line">                            cnt += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>####官方题解2:DFS—-利用算子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    constexpr <span class="keyword">static</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    constexpr <span class="keyword">static</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            res += dfs(tx, ty, grid, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans += dfs(i, j, grid, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这个题放在散列表题目下，个人觉得是因为可以使用散列表去记录方格的访问状态</p>
<p>key用来放方格点，value用true或者false来代表方格是否被访问过。</p>
<h3 id="5-岛屿的数量"><a href="#5-岛屿的数量" class="headerlink" title="5.岛屿的数量"></a>5.岛屿的数量</h3><p>###6.岛屿的最大面积</p>
<h3 id="7-查找常用字符"><a href="#7-查找常用字符" class="headerlink" title="7.查找常用字符"></a>7.查找常用字符</h3><p>总体来说，还是hash表的思路，重点在于用一个数组创建索引，用另外一个数组更新值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历、计数、更新</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用数组实现一个哈希表，以字符为数组下标索引：字符-&#x27;a&#x27;=索引---即：0-&#x27;a&#x27;,2-&#x27;b&#x27;,3-&#x27;c&#x27;,25-&#x27;z&#x27;.</span></span><br><span class="line"><span class="comment">用freq数组存储当前遍历字符串中各字符的数量,在遍历完成后，</span></span><br><span class="line"><span class="comment">以各字符数量的最小值更新minfreq数组，遍历完成后即可得到公共字符的数量集合hash，</span></span><br><span class="line"><span class="comment">将minfreq数组中的非0值还原成字符串加入到列表中，即可得到答案。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] minfreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];   <span class="comment">//建立minfreq[c]来存储各字符串中c出现的最小次数</span></span><br><span class="line">        Arrays.fill(minfreq,Integer.MAX_VALUE);<span class="comment">//将指定的int值分配给指定的int数组的每个元素，即此时minfreq中的每个元素值均为Integer.MAX_VALUE。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String word:A)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">int</span> length = word.length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> ch =word.charAt(i);</span><br><span class="line">                ++freq[ch-<span class="string">&#x27;a&#x27;</span>];             <span class="comment">//ch-&#x27;a&#x27;创建索引</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                minfreq[i] = Math.min(minfreq[i],freq[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;minfreq[i];j++)&#123;</span><br><span class="line">                ans.add(String.valueOf((<span class="keyword">char</span>)(i+<span class="string">&#x27;a&#x27;</span>)));  <span class="comment">//i+&#x27;a&#x27;是在将还原minfreq中的字符还原成字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="8-唯一元素的和"><a href="#8-唯一元素的和" class="headerlink" title="8.唯一元素的和"></a>8.唯一元素的和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfUnique</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;Integer,Boolean&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            dic.put(i,!dic.containsKey(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.get(i))&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串调用length，调用的是方法，因而要加()；数组调用length，调用的是属性，不需要加()。</span></span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux环境安装redis</title>
    <url>/2021/03/18/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/</url>
    <content><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="云服务器部署redis"><a href="#云服务器部署redis" class="headerlink" title="云服务器部署redis"></a>云服务器部署redis</h3><h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><blockquote>
<p>下载</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-stable.tar.gz </span><br></pre></td></tr></table></figure>
<p>这样就直接下载好了稳定版本。</p>
<blockquote>
<p>解压</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf redis-stable.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入到redis的src目录下</span></span><br><span class="line">cd redis/src</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<blockquote>
<p>报错处理方法</p>
</blockquote>
<ul>
<li><p>出现了 <strong>zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory</strong></p>
<ul>
<li><blockquote>
<pre><code class="shell">make MALLOC=libc
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 出现了serve.c方面的报错</span><br><span class="line"></span><br><span class="line"> &#123;%asset_image 01.png%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gcc的版本太低，因为redis本身使用C语言写的，在编译时需要用到GCC编译器，版本过低的话，就会报这个错。</span><br><span class="line"></span><br><span class="line">&gt;[root@localhost redis-6.0.1]# gcc -v                             # 查看gcc版本</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# yum -y install centos-release-scl  # 升级到9.1版本</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# scl enable devtoolset-9 bash</span><br><span class="line">&gt;以上为临时启用，如果要长期使用gcc 9.1的话：</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">再执行编译，PREFIX 安装目录</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">[root@localhost redis-6.0.1]# make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure></code></pre>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>安装成功</p>
</blockquote>
<img data-src="/2021/03/18/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/02.png" class>



<blockquote>
<p>启动redis服务</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis/src</span><br><span class="line"><span class="meta">#</span><span class="bash">运行以下命令</span></span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure>
<p>启动成功界面</p>
 <img data-src="/2021/03/18/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/03.png" class>



<p><strong>接下来就可以愉快的使用redis了。</strong></p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><blockquote>
<p>redis的启动方式</p>
</blockquote>
<ul>
<li><p>直接启动</p>
<p>进入到redis根目录，执行以下命令，其中，加上‘&amp;’号可以使redis以后台程序运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. /redis-server  &amp;</span><br></pre></td></tr></table></figure></li>
<li><p>通过指定配置文件来启动</p>
<p> 可以为redis服务启动指定配置文件，例如配置为/etc/redis/6379.conf。当然，配置文件不是绝对的，可以通过个人来指定。</p>
<p>最好不要在原来的redis-conf上进行修改，最好复制一个新的配置文件。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. /redis-server  /etc/redis/6379 .conf</span><br></pre></td></tr></table></figure>
<p>​        如果更改了端口，使用<code>redis-cli</code>客户端连接时，也需要指定端口，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6380</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用redis启动脚本来设置开机自启动</p>
<p> 启动脚本 redis_init_script 位于位于Redis的 /utils/ 目录下，redis_init_script脚本代码如下：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Simple Redis init.d script conceived to work on Linux systems</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> as it does use of the /proc filesystem.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:     redis_6379</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:        2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:         0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description:    Redis data structure server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description:          Redis data structure server. See https://redis.io</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">redis服务器监听端口</span></span><br><span class="line">REDISPORT=6379 </span><br><span class="line"><span class="meta">#</span><span class="bash">服务端所处位置</span></span><br><span class="line">EXEC=/usr/local/bin/redis-server</span><br><span class="line"><span class="meta">#</span><span class="bash">客户端位置</span></span><br><span class="line">CLIEXEC=/usr/local/bin/redis-cli</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">redis的PID文件位置，需要修改</span></span><br><span class="line">PIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line"><span class="meta">#</span><span class="bash">redis的配置文件位置，需将<span class="variable">$&#123;REDISPORT&#125;</span>修改为文件名</span></span><br><span class="line">CONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        if [ -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE exists, process is already running or crashed&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;Starting Redis server...&quot;</span><br><span class="line">                $EXEC $CONF</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        if [ ! -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE does not exist, process is not running&quot;</span><br><span class="line">        else</span><br><span class="line">                PID=$(cat $PIDFILE)</span><br><span class="line">                echo &quot;Stopping ...&quot;</span><br><span class="line">                $CLIEXEC -p $REDISPORT shutdown</span><br><span class="line">                while [ -x /proc/$&#123;PID&#125; ]</span><br><span class="line">                do</span><br><span class="line">                    echo &quot;Waiting for Redis to shutdown ...&quot;</span><br><span class="line">                    sleep 1</span><br><span class="line">                done</span><br><span class="line">                echo &quot;Redis stopped&quot;</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Please use start or stop as first argument&quot;</span><br><span class="line">Type  :quit&lt;Enter&gt;  to exit Vim   </span><br></pre></td></tr></table></figure>
<p>此处直接配置开启自启动 <code>chkconfig redisd on</code> 将报错误： <code>service redisd does not support chkconfig</code> </p>
<p>在启动脚本开头添加如下两行注释以修改其运行级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># chkconfig:   2345 90 10</span><br><span class="line"># description:  Redis is a persistent key-value database</span><br><span class="line">#</span><br></pre></td></tr></table></figure>


<p>设置即可成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置为开机自启动服务器</span><br><span class="line">chkconfig redisd on</span><br><span class="line">#打开服务</span><br><span class="line">service redisd start</span><br><span class="line">#关闭服务</span><br><span class="line">service redisd stop</span><br></pre></td></tr></table></figure>


<h4 id="远程连接工具"><a href="#远程连接工具" class="headerlink" title="远程连接工具"></a>远程连接工具</h4>]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/2021/02/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>基于XML的DI</title>
    <url>/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/</url>
    <content><![CDATA[<h2 id="基于XML的DI"><a href="#基于XML的DI" class="headerlink" title="基于XML的DI"></a>基于XML的DI</h2> <img data-src="/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/01.png" class>

<p>bean 实例在调用无参构造器创建对象后，就要对 bean 对象的属性进行初始化。初始化 是由容器自动完成的，称为注入。</p>
<p>根据注入方式的不同，常用的有两类：set注入、构造注入</p>
<h3 id="set注入"><a href="#set注入" class="headerlink" title="set注入"></a>set注入</h3><blockquote>
<p>set注入</p>
</blockquote>
<p>set注入，又叫设值注入，通过<strong>setter 方法</strong>传入被调用者的实例。这种注入方式简单、 直观，因而在 Spring 的依赖注入中大量使用。</p>
<ul>
<li><h4 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h4></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;myemail:&quot;</span> + email);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;studenet&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="comment">&lt;!--声明student对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mystudent&quot;</span>  <span class="attr">class</span>=<span class="string">&quot;com.bytedance.ba01.student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xinghaodong123@163.com&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--说明不一定是属性才可以注入，spring关心的只是name对应的有没有set方法，有即可设置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建java.util.Date，并设置初始的日期时间</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;bean id=<span class="string">&quot;mydate&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">&quot;time&quot;</span> value=<span class="string">&quot;123&quot;</span>/&gt;</span><br><span class="line">&lt;!--Date类里面有setTime方法--&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure>


<ul>
<li><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4></li>
</ul>
<p>当指定 bean 的某属性值为另一 bean 的实例时，通过 ref 指定它们间的引用关系。ref 的值必须为某 bean 的 id 值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> School school;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//setter</span></span><br><span class="line">    <span class="comment">//toString()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;mystudent&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bytedance.ba02.student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;12&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;22&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myschool&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;myschool&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 声明school对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myschool&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.bytedance.ba02.school&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京大学&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;address&quot;</span> <span class="attr">value</span>=<span class="string">&quot;北京市海淀区&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h3><p>构造注入是指，在构造调用者实例的同时，完成被调用者的实例化。即使用构造器设置依赖关系。</p>
 <img data-src="/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/02.png" class>



<p>标签中用于指定参数的属性有：</p>
<p> ➢ name：指定参数名称。 </p>
<p>➢ index：指明该参数对应着构造器的第几个参数，从 0 开始。不过，该属性不要也行， 但要注意，若参数类型相同，或之间有包含关系，则需要保证赋值顺序要与构造器中的参数 顺序一致。</p>
 <img data-src="/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/03.png" class>



<h3 id="引用类型属性自动注入"><a href="#引用类型属性自动注入" class="headerlink" title="引用类型属性自动注入"></a>引用类型属性自动注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">引用类型的自动注入</span><br><span class="line">spring框架根据某些规则可以给“引用类型”赋值，自动注入，不需要程序员再给引用类型赋值了</span><br><span class="line">使用的规则常用的是byName,byType</span><br><span class="line">1.byName(按名称注入)：Java类中引用类型的属性名称和spring容器中（配置文件）&lt;bean&gt;的id的名称一样，数据类型一样，这样的容器中的bean，spring能够赋值给引用类型</span><br><span class="line">    语法规则：</span><br><span class="line">    &lt;bean id&#x3D;&quot;xx&quot;,class&#x3D;&quot;yy&quot; autowire&#x3D;&quot;byname&quot;&gt;</span><br><span class="line">        简单类型属性赋值</span><br><span class="line">     &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">2.byType(按照类型注入)：Java类中引用类型的数据类型和spring容器中（配置文件）&lt;bean&gt;的class属性是同源关系，这样的bean,spring能够赋值给引用类型</span><br><span class="line">    同源就是一类的意思：</span><br><span class="line">    1.java类中引用类型的数据类型和bean的class的值是一样的</span><br><span class="line">    2.Java类中的引用类型的数据类型和bean的class的值是父子类关系</span><br><span class="line">    3.java类中的引用类型的数据类型和bean的class的值是接口与实现类的关系</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/04.png" class>



<p>具体说明：</p>
<ul>
<li><h4 id="byName方式自动注入"><a href="#byName方式自动注入" class="headerlink" title="byName方式自动注入"></a>byName方式自动注入</h4><p>当配置文件中被调用者 bean 的 id 值与代码中调用者 bean 类的属性名相同时，可使用 byName 方式，让容器自动将被调用者 bean 注入给调用者 bean。容器是通过调用者的 bean 类的引用类型属性名与配置文件的被调用者 bean 的 id 进行比较而实现自动注入的。</p>
<img data-src="/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/05.png" class>



</li>
</ul>
<ul>
<li><h4 id="byType自动注入"><a href="#byType自动注入" class="headerlink" title="byType自动注入"></a>byType自动注入</h4><p>使用 byType 方式自动注入，要求：配置文件中被调用者 bean 的 class 属性指定的类， 要与代码中调用者 bean 类的某引用类型属性类型同源。即要么相同，要么有 is-a 关系（子 类，或是实现类）。但这样的同源的被调用 bean 只能有一个。多于一个，容器就不知该匹配哪一个了。</p>
<img data-src="/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/06.png" class>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果出现同源类在XML文件中出现两个类，只能保留一个，否则会出现BeanDefinitionParsingException异常</span><br></pre></td></tr></table></figure>


<h3 id="为应用指定多个Spring配置文件"><a href="#为应用指定多个Spring配置文件" class="headerlink" title="为应用指定多个Spring配置文件"></a>为应用指定多个Spring配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> spring-total表示主配置文件：用以包含其他的配置文件，主配置文件一般是不定义对象的。</span><br><span class="line">       语法：&lt;import resource&#x3D;&quot;其他配置文件的路径&quot;&#x2F;&gt;</span><br><span class="line">       关键字：“classpath”：表示类路径（class文件所在的目录的target路径下;）</span><br><span class="line">       在spring的配置文件中要指定其他文件的位置，需要使用classpath，告诉spring到哪里去加载读取文件</span><br><span class="line">        </span><br><span class="line">在具有包含关系的配置文件中，可以使用通配符（*：表示任意字符） 且这些文件必须在resources下面的一级目录下 。 </span><br><span class="line">使用多配置文件时，不能将主文件自身包括进自生主文件</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/02/28/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/07.png" class>





]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>基础注解的DI</title>
    <url>/2021/02/28/%E5%9F%BA%E7%A1%80%E6%B3%A8%E8%A7%A3%E7%9A%84DI/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>客户端识别与Cookie</title>
    <url>/2021/03/14/%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%AF%86%E5%88%AB%E4%B8%8ECookie/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>封装Mybatis输出结果与模糊查询</title>
    <url>/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><p>resultType: 执行 sql 得到 ResultSet 转换的类型，使用类型的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。resultType 和 resultMap，不能同时使用。</p>
<h4 id="resultType-1"><a href="#resultType-1" class="headerlink" title="resultType"></a>resultType</h4><img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/01.png" class>



<blockquote>
<p>简单类型</p>
</blockquote>
<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countStudent</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>mapper文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;countStudent&quot;</span> resultType=<span class="string">&quot;int&quot;</span>&gt;</span><br><span class="line">	 <span class="function">select <span class="title">count</span><span class="params">(*)</span> from student</span></span><br><span class="line"><span class="function">&lt;/select&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRetunInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = studentDao.countStudent();</span><br><span class="line">     System.out.println(<span class="string">&quot;学生总人数：&quot;</span>+ count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>对象类型</p>
</blockquote>
<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>mapper文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectById&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line">     select id,name,email,age from student where id=#&#123;studentId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/02.png" class>

 <img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/03.png" class>



<blockquote>
<p>Map</p>
</blockquote>
<p>sql 的查询结果作为 Map 的 key 和 value。推荐使用 Map。 注意：Map 作为接口返回值，sql 语句的查询结果最多只能有一条记录。大于一条记录是错误。</p>
<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Map&lt;Object,Object&gt; <span class="title">selectReturnMap</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>mapper文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectReturnMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.util.HashMap&quot;</span>&gt;</span></span><br><span class="line">	 select name,email from student where id = #&#123;studentId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Map&lt;Object,Object&gt; retMap = studentDao.selectReturnMap(<span class="number">1002</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;查询结果是 Map:&quot;</span>+retMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>resultMap 可以自定义 sql 的结果和 java 对象属性的映射关系。更灵活的把列值赋值给指定属性。 常用在列名和 java 对象属性名不一样的情况。</p>
<p> 使用方式： </p>
<p>1.先定义 resultMap,指定列名和属性的对应关系。</p>
<p> 2.在<select>中把 resultType 替换为 resultMap。</select></p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectUseResultMap</span><span class="params">(QueryParam param)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建 resultMap</span></span><br><span class="line"><span class="comment">     id:自定义的唯一名称，在&lt;select&gt;使用</span></span><br><span class="line"><span class="comment">     type:期望转为的 java 对象的全限定名称或别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 主键字段使用 id --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--非主键字段使用 result--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--resultMap: resultMap 标签中的 id 属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUseResultMap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">     select id,name,email,age from student where name=#&#123;queryName&#125; or</span><br><span class="line">    age=#&#123;queryAge&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectUseResultMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam param = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     param.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     param.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectUseResultMap(param);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实体类属性名和列名不同的处理方式"><a href="#实体类属性名和列名不同的处理方式" class="headerlink" title="实体类属性名和列名不同的处理方式"></a>实体类属性名和列名不同的处理方式</h3><h4 id="使用列别名和"><a href="#使用列别名和" class="headerlink" title="使用列别名和"></a>使用列别名和<resultType></resultType></h4><ul>
<li> 创建新的实体类 PrimaryStudent</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.domain;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Description: 实体类 &lt;/p&gt;</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Company: http://www.bjpowernode.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Integer stuId;</span><br><span class="line">     <span class="keyword">private</span> String stuName;</span><br><span class="line">     <span class="keyword">private</span> Integer stuAge;</span><br><span class="line">     <span class="comment">// set , get 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;PrimaryStudent&gt; <span class="title">selectUseFieldAlias</span><span class="params">(QueryParam param)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Mapper文件</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectUseFieldAlias&quot;</span></span><br><span class="line">resultType=<span class="string">&quot;com.bjpowernode.domain.PrimaryStudent&quot;</span>&gt;</span><br><span class="line">     select id as stuId, name as stuName,age as stuAge</span><br><span class="line">     from student where name=#&#123;queryName&#125; or age=#&#123;queryAge&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectUseFieldAlias</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam param = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     param.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     param.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;PrimaryStudent&gt; stuList;</span><br><span class="line">     stuList = studentDao.selectUseFieldAlias(param);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用 "></a>使用 <resultMap></resultMap></h4><ul>
<li><p>接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;PrimaryStudent&gt; <span class="title">selectUseDiffResultMap</span><span class="params">(QueryParam param)</span></span>;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>mapper文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建 resultMap</span></span><br><span class="line"><span class="comment"> id:自定义的唯一名称，在&lt;select&gt;使用</span></span><br><span class="line"><span class="comment"> type:期望转为的 java 对象的全限定名称或别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;primaryStudentMap&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;com.bjpowernode.domain.PrimaryStudent&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 主键字段使用 id --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuId&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--非主键字段使用 result--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuName&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuAge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--resultMap: resultMap 标签中的 id 属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUseDiffResultMap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;primaryStudentMap&quot;</span>&gt;</span></span><br><span class="line">     select id,name,email,age from student</span><br><span class="line">     where name=#&#123;queryName&#125; or age=#&#123;queryAge&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li><p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectUseDiffResultMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam param = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     param.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     param.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;PrimaryStudent&gt; stuList;</span><br><span class="line">     stuList = studentDao.selectUseDiffResultMap(param);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="模糊like"><a href="#模糊like" class="headerlink" title="模糊like"></a>模糊like</h3><p>模糊查询的实现有两种方式， 一是 java 代码中给查询数据加上“%” ; 二是在 mapper 文件 sql 语句的条件位置加上“%”。</p>
<img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/04.png" class>

 <img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/05.png" class>

]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>条件渲染与列表渲染</title>
    <url>/2021/03/14/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%E4%B8%8E%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Vue模板语法</title>
    <url>/2021/03/07/%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML，所以能被遵循规范的浏览器和 HTML 解析器解析。</p>
<p>在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，Vue 能够智能地计算出最少需要重新渲染多少组件，并把 DOM 操作次数减到最少。</p>
<h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><h4 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h4><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Message:&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Mustache 标签将会被替代为对应数据对象上 <code>msg</code> property 的值。无论何时，绑定的数据对象上 <code>msg</code> property 发生了改变，插值处的内容都会更新。</p>
<p>通过使用 **<a href="https://cn.vuejs.org/v2/api/#v-once">v-once 指令</a>**，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>这个节点上的数据将不会改变：&#123;&#123;mag&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="双大括号下的原始HTML文本"><a href="#双大括号下的原始HTML文本" class="headerlink" title="双大括号下的原始HTML文本"></a>双大括号下的原始HTML文本</h4><p>双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用**`v-html  **</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Using v-html directive: <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-html</span>=<span class="string">&quot;rawHtml&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>你不能使用 <code>v-html</code> 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。</p>
<blockquote>
<p>你的站点上动态渲染的任意 HTML 可能会非常危险，因为它很容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS 攻击</a>。请只对可信内容使用 HTML 插值，<strong>绝不要</strong>对用户提供的内容使用插值。</p>
</blockquote>
<h2 id="对Attribute进行数据绑定"><a href="#对Attribute进行数据绑定" class="headerlink" title="对Attribute进行数据绑定"></a>对Attribute进行数据绑定</h2><p>Mustache 语法不能作用在 HTML attribute 上，遇到这种情况应该使用 <a href="https://cn.vuejs.org/v2/api/#v-bind"><code>v-bind</code> 指令</a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:id&#x3D;&quot;dynamicId&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<p>对于布尔 attribute (它们只要存在就意味着值为 <code>true</code>)，<code>v-bind</code> 工作起来略有不同，在这个例子中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button v-bind:disabled&#x3D;&quot;isButtonDisabled&quot;&gt;Button&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>如果 <code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled</code> attribute 甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中。</p>
<h4 id="使用JavaScript表达式-而不是键值"><a href="#使用JavaScript表达式-而不是键值" class="headerlink" title="使用JavaScript表达式(而不是键值)"></a>使用JavaScript表达式(而不是键值)</h4><p>迄今为止，在我们的模板中，我们一直都只绑定简单的 property 键值。但实际上，对于所有的数据绑定，Vue.js 都提供了完全的 JavaScript 表达式支持。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;&#123; number + <span class="number">1</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? <span class="string">&#x27;YES&#x27;</span> : <span class="string">&#x27;NO&#x27;</span> &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>) &#125;&#125;</span><br><span class="line"></span><br><span class="line">&lt;div v-bind:id=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>这些表达式会在所属 Vue 实例的数据作用域下作为 JavaScript 被解析。有个限制就是，每个绑定都只能包含<strong>单个表达式</strong>，所以下面的例子都<strong>不会</strong>生效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是语句，不是表达式 --&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">var</span> a = <span class="number">1</span> &#125;&#125;      </span><br><span class="line"></span><br><span class="line">&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;</span><br><span class="line">&#123;&#123; <span class="keyword">if</span> (ok) &#123; <span class="keyword">return</span> message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 attribute。指令 attribute 的值预期是<strong>单个 JavaScript 表达式</strong> (<code>v-for</code> 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p v-if&#x3D;&quot;seen&quot;&gt;现在你看到我了&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>
<p>这里，<code>v-if</code> 指令将根据表达式 <code>seen</code> 的值的真假来插入/移除 <code>&lt;p&gt;</code> 元素</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="[参数]"></a>[参数]</h3><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，<code>v-bind</code> 指令可以用于响应式地更新 HTML attribute：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href</code> attribute 与表达式 <code>url</code> 的值绑定。</p>
<p>另一个例子是 <code>v-on</code> 指令，它用于监听 DOM 事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>在这里参数是监听的事件名。 </p>
<h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0">动态参数</a></h3><blockquote>
<p>2.6.0 新增</p>
</blockquote>
<p>从 2.6.0 开始，可以用方括号括起来的 JavaScript 表达式作为一个指令的参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;a v-bind:[attributeName]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>attributeName</code> 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 <code>data</code> property <code>attributeName</code>，其值为 <code>&quot;href&quot;</code>，那么这个绑定将等价于 <code>v-bind:href</code>。</p>
<p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a v-on:[eventName]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，当 <code>eventName</code> 的值为 <code>&quot;focus&quot;</code> 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>。</p>
<h4 id="对动态参数的值的约束"><a href="#对动态参数的值的约束" class="headerlink" title="对动态参数的值的约束"></a>对动态参数的值的约束</h4><p>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code>。这个<strong>特殊的 <code>null</code> 值可以被显性地用于移除绑定</strong>。任何其它非字符串类型的值都将会触发一个警告。</p>
<h4 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="headerlink" title="对动态参数表达式的约束"></a>对动态参数表达式的约束</h4><p>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这会触发一个编译警告 --&gt;</span><br><span class="line">&lt;a v-bind:[&#39;foo&#39; + bar]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。</p>
<p>在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">在 DOM 中使用模板时这段代码会被转换为 &#96;v-bind:[someattr]&#96;。</span><br><span class="line">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span><br><span class="line">--&gt;</span><br><span class="line">&lt;a v-bind:[someAttr]&#x3D;&quot;value&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>


<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</a></h3><p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，<code>.prevent</code> 修饰符告诉 <code>v-on</code> 指令对于触发的事件调用 <code>event.preventDefault()</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;...&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>
<p>阻止某一事件的默认机制执行，此时组织了submit行为的产生</p>
<h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 Vue 特定的 attribute。当你在使用 Vue.js 为现有标签添加动态行为 (dynamic behavior) 时，<code>v-</code> 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到使用繁琐。同时，在构建由 Vue 管理所有模板的<a href="https://en.wikipedia.org/wiki/Single-page_application">单页面应用程序 (SPA - single page application)</a> 时，<code>v-</code> 前缀也变得没那么重要了。因此，Vue 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写：</p>
<h3 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-bind-%E7%BC%A9%E5%86%99"><code>v-bind</code> 缩写</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href&#x3D;&quot;url&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a :[key]&#x3D;&quot;url&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<h3 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a><a href="https://cn.vuejs.org/v2/guide/syntax.html#v-on-%E7%BC%A9%E5%86%99"><code>v-on</code> 缩写</a></h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click&#x3D;&quot;doSomething&quot;&gt;...&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="line">&lt;a @[event]&#x3D;&quot;doSomething&quot;&gt; ... &lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>它们看起来可能与普通的 HTML 略有不同，但 <code>:</code> 与 <code>@</code> 对于 attribute 名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。</p>
]]></content>
      <categories>
        <category>Vue框架</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列产品与RabbitMQ的简介</title>
    <url>/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="MQ常见产品"><a href="#MQ常见产品" class="headerlink" title="MQ常见产品"></a>MQ常见产品</h2><p>目前业界有很多的 MQ 产品，例如 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，也有直接使用 Redis 充当消息队列的案例，而这些消息队列产品，各有侧重，在实际选型时，需要结合自身需求及 MQ 产品特征，综合考虑。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司/社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义</td>
<td>自定义协议，社区封装了http协议支持</td>
</tr>
<tr>
<td>客户端支持语言</td>
<td>官方支持Erlang，Java，Ruby等,社区产出多种API，几乎支持所有语言</td>
<td>Java，C，C++，Python，PHP，Perl，.net等</td>
<td>Java，C++（不成熟）</td>
<td>官方支持Java,社区产出多种API，如PHP，Python等</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级（其次）</td>
<td>万级（最差）</td>
<td>十万级（最好）</td>
<td>十万级（次之）</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微妙级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>功能特性</td>
<td>并发能力强，性能极其好，延时低，社区活跃，管理界面丰富</td>
<td>老牌产品，成熟度高，文档较多</td>
<td>MQ功能比较完备，扩展性佳</td>
<td>只支持主要的MQ功能，毕竟是为大数据领域准备的。</td>
</tr>
</tbody></table>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的</li>
<li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p>
<p>RabbitMQ基础架构如下图：</p>
<img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/02.png" class>

<h3 id="相关概念与基础架构"><a href="#相关概念与基础架构" class="headerlink" title="相关概念与基础架构"></a>相关概念与基础架构</h3><blockquote>
<p>RabbitMQ的相关概念</p>
</blockquote>
<ul>
<li><p> Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker。</p>
</li>
<li><p>Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p>
</li>
<li><p>Connection：publisher／consumer 和 broker 之间的 TCP 连接。</p>
</li>
<li><p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</p>
</li>
<li><p>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</p>
</li>
<li><p>Queue：消息最终被送到这里等待 consumer 取走。</p>
</li>
<li><p>Bingding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</p>
</li>
</ul>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>RabbitMQ 提供了 6 种工作模式：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。</p>
<p><a href="https://www.rabbitmq.com/getstarted.html">官网对应模式介绍</a></p>
 <img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/03.png" class>



<h3 id="AMQP与JMS"><a href="#AMQP与JMS" class="headerlink" title="AMQP与JMS"></a>AMQP与JMS</h3><p>首先明确AMQP是协议，类比HTTP；JMS是API规范接口，类比JDBC。</p>
<h4 id="JMS简介"><a href="#JMS简介" class="headerlink" title="JMS简介"></a>JMS简介</h4><p>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<strong>JMS（JAVA Message Service,Java消息服务）API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p><strong>ActiveMQ 就是基于 JMS 规范实现的。</strong></p>
<h5 id="JMS两种消息模型"><a href="#JMS两种消息模型" class="headerlink" title="JMS两种消息模型"></a>JMS两种消息模型</h5><blockquote>
<p>点到点（P2P）模型</p>
</blockquote>
<img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/04.png" class>



<p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，**<em>一条消息只能被一个消费者使用**</em>，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<blockquote>
<p>发布、订阅（Pub/Sub)模型</p>
</blockquote>
<img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/05.png" class>

<p>发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）</strong>作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<h5 id="JMS五种不同的消息正文格式"><a href="#JMS五种不同的消息正文格式" class="headerlink" title="JMS五种不同的消息正文格式"></a>JMS五种不同的消息正文格式</h5><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java原始值的数据流</li>
<li>MapMessage–一套名称-值对</li>
<li>TextMessage–一个字符串对象</li>
<li>ObjectMessage–一个序列化的 Java对象</li>
<li>BytesMessage–一个字节的数据流</li>
</ul>
<h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p>
<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>
<table>
<thead>
<tr>
<th>对比</th>
<th align="center">JMS</th>
<th>AMQP</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>定义</td>
<td align="center">Java API</td>
<td>协议</td>
</tr>
<tr>
<td>跨语言</td>
<td align="center">否</td>
<td>是</td>
</tr>
<tr>
<td>跨平台</td>
<td align="center">否</td>
<td>是</td>
</tr>
<tr>
<td>支持消息类型</td>
<td align="center">提供两种消息模型：①Peer-2-Peer;②Pub/sub</td>
<td>提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>
</tr>
<tr>
<td>支持消息类型</td>
<td align="center">支持多种消息类型 ，我们在上面提到过</td>
<td>byte[]（二进制</td>
</tr>
</tbody></table>
<p>####总结</p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li>
<li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li>
<li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li>
</ul>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>类文件结构</title>
    <url>/2021/01/16/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>#类文件结构</p>
<h2 id="虚拟机的无关性"><a href="#虚拟机的无关性" class="headerlink" title="虚拟机的无关性"></a>虚拟机的无关性</h2><p>Java的宣传口号是: <strong><em>WRITE ONCE , RUN ANYWHREE</em></strong></p>
<p>java虚拟机力求实现的两种无关性：</p>
<ol>
<li><p>平台无关性</p>
<p>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——–字节码（ByteCode）是构成平台无关性的基础，虚拟机可以载入同一种平台无关的字节码。</p>
</li>
<li><p>语言无关性：</p>
<p><strong>举例</strong>：除了Java之外，Clojure、Groovy、JRuby、Jython、Scala都可以在Java虚拟机上运行</p>
<p>实现语言无关性的基础是Java虚拟机不与任何语言绑定，只与**<em>“Class文件”这种特殊的二进制文件格式**</em>相关联，Class文件包含了Java虚拟机指令集和符号表以及若干其他辅助信息，在Class文件中使用了许多强制性的语法和结构化约束，任何一门语言都可以表示为被JAVA虚拟机锁接受的有效的Class文件。虚拟机只关心Class文件本身，而不关心Class文件的来源是哪种语言。</p>
<p>在Class文件中，各种关键字、变量、和运算符号的语义都是有多条字节码命令组合而成的，字节码命令所能提供的语义描述能力必然要比java语言本身更为强大，所以Java虚拟机提供的支持远比java语言本身强大。</p>
</li>
</ol>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格的按照顺序紧凑的排列在Class文件中，中间没有任何的分隔符，这使得整个Class文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。</p>
<p>Class文件格式采用一种类似于C语言中struct的伪结构来进行存储数据：包括<strong>无符号数+表</strong></p>
<p>1、无符号数：基本数据类型</p>
<p>2、表：有多个无符号数或者其他表作为数据项构成的复合数据类型，习惯性的以__info结尾。表用于描述有层次关系的复合结构的数据。整个class文件本质上就是一张表。</p>
<h3 id="magic-numer与class文件版本"><a href="#magic-numer与class文件版本" class="headerlink" title="magic numer与class文件版本"></a>magic numer与class文件版本</h3><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>###属性表集合</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>系统调用是内核与用户进程进行交互的一组接口，这些接口让应用程序受限制的访问硬件设备，提供了创建新进程并与已有进程进行交互通信的机制，也提供了申请操作系统其他资源的能力。</p>
<p>系统调用在Linux系统中的地位如下图所示：</p>
<img data-src="/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/OIP1.jpg" class>

<h3 id="2-与内核通信"><a href="#2-与内核通信" class="headerlink" title="2.与内核通信"></a>2.与内核通信</h3><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。这样的中间层有如下作用：</p>
<blockquote>
<p>1.为用户空间提供了一种硬件的抽象接口。</p>
</blockquote>
<blockquote>
<p>2.系统调用确保了系统的稳定与安全。内核可以作为硬件设备与用户空间之间的中间人，基于权限、用户类型和一些其他的规则对需要进行的访问做出裁决。</p>
</blockquote>
<blockquote>
<p>3.避免用户空间的应用程序对硬件资源随意访问而内核一无所知，这样既无法实现多任务和虚拟内存，也不能确保良好的稳定性和安全性。</p>
</blockquote>
<p><strong>Linux中：系统调用是用户空间访问内核的唯一手段—-除了异常和陷入外，它们是内核唯一的合法入口</strong></p>
<h3 id="3-API、POSIX、C库"><a href="#3-API、POSIX、C库" class="headerlink" title="3.API、POSIX、C库"></a>3.API、POSIX、C库</h3><p>应用程序通过在用户空间实现的应用编程接口（API）而不是直接通过系统调用。</p>
<blockquote>
<p>1.API实际上并不需要与内核提供的系统调用一一对应，程序员只跟API打交道。</p>
<p>2.内核只跟系统调用打交道，库函数以及应用程序如何使用系统调用不是内核所关心的。</p>
<p>3.API可以实现成一个系统调用，也可以实现多个系统调用，甚至也可以不实现系统调用。</p>
</blockquote>
<p>在UNIX中，最流行的应用编程接口是基于POSIX标准的。</p>
<p>Linux系统调用作为C库的一部分提供。C库实现了Unix系统的主要API，包括标准C库函数和系统调用接口，此外，C库提供了POSIX的绝大部分API。</p>
<h3 id="4-系统调用-syscall"><a href="#4-系统调用-syscall" class="headerlink" title="4.系统调用(syscall)"></a>4.系统调用(syscall)</h3><p><strong>通过在C库中定义的函数调用来执行</strong></p>
<p>系统调用在出现错误的时候C库会将错误码写入errno全局变量。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<p>为了保证32为操作系统和64位操作系统的兼容，系统调用在用户空间和内核空间有着不同的返回值类型。用户空间为int，内核空间为long。系统调用在内核中前面会加上sys_。例如：返回当前进程PID的系统调用get_pid（）在内核中被定义为sys_getpid()。</p>
<h4 id="4-1系统调用号"><a href="#4-1系统调用号" class="headerlink" title="4.1系统调用号"></a>4.1系统调用号</h4><p>在Linux中，每个系统调用都会被赋予一个系统调用号（独一无二的）。进程在执行系统调用时，不需要提及系统调用的名称，只需要使用系统调用号即可。</p>
<p><strong>系统调用号相当重要，一旦分配好就不能再更改，因为会导致之前编译好的应用程序崩溃。</strong>即使这个系统调用被删除，它所占用的系统调用号也不允许被回收利用。</p>
<p>内核记录了系统调用表中的所有已经注册过的系统调用的列表，存储在sys_call_table中，这个表为每一个有效的</p>
<p>系统调用指定了唯一的系统调用号。</p>
<h4 id="4-2系统调用的性能"><a href="#4-2系统调用的性能" class="headerlink" title="4.2系统调用的性能"></a>4.2系统调用的性能</h4><p>Linux系统调用比其他许多的操作系统执行要快。原因如下：</p>
<blockquote>
<p>1.Linux很短的上下文切换时间，进出内核都被优化的极为高效。</p>
<p>2.系统调用处理程序和每个系统调用本身非常简洁。</p>
</blockquote>
<h3 id="5-系统调用处理程序"><a href="#5-系统调用处理程序" class="headerlink" title="5.系统调用处理程序"></a>5.系统调用处理程序</h3><p>应用程序通过<strong>软中断</strong>的方式来告诉内核自己期望执行一个系统调用，希望系统当前可以从用户态切换到内核态，这样内核就可以代表应用程序在内核空间中执行系统调用。</p>
<p><strong>软中断</strong>：通过引起一个异常来促使系统切换到内核态前去执行异常处理程序。此时的异常处理程序其实就是<strong>系统调用处理程序</strong>。</p>
<p>在X86系统中预定义的软中断是中断号128，通过int $0x80来触发中断。这条指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序（系统调用处理程序）。</p>
<h4 id="5-1指定恰当的系统调用"><a href="#5-1指定恰当的系统调用" class="headerlink" title="5.1指定恰当的系统调用"></a>5.1指定恰当的系统调用</h4><p>在陷入内核空间时，要将系统调用号传给内核空间。X86系统，系统调用号是通过eax寄存器传递给内核的。system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。大于或者等于NR_syscalls，函数就返回-ENOSYS,否则，执行相应的系统调用。</p>
<p>系统调用表中的表项是以64位类型存放的，所以内核需要将给定的系统调用号乘4，然后用所得结果在表中查询位置。</p>
<h4 id="5-2参数传递"><a href="#5-2参数传递" class="headerlink" title="5.2参数传递"></a>5.2参数传递</h4><p>部分系统调用除了系统调用号之外，还需要传入一些外部参数，在发生陷入的时候，一并传给内核，同样是放在寄存器中。<strong>给用户空间的返回值同样是通过寄存器来传递的</strong></p>
<h3 id="6-系统调用的实现"><a href="#6-系统调用的实现" class="headerlink" title="6.系统调用的实现"></a>6.系统调用的实现</h3><h4 id="6-1实现系统调用"><a href="#6-1实现系统调用" class="headerlink" title="6.1实现系统调用"></a>6.1实现系统调用</h4><p>要求：</p>
<ul>
<li>Linux中不提倡采用多用途的系统调用（一个系统调用通过传递不同的参数值来完成选择的工作）</li>
<li>系统调用的接口应该力求简洁，参数尽量少。提供标志参数以确保向前兼容。</li>
<li>系统调用的设计越通用越好。</li>
</ul>
<h4 id="6-2参数验证"><a href="#6-2参数验证" class="headerlink" title="6.2参数验证"></a>6.2参数验证</h4><p>系统调用必须检查参数是否合法有效。系统调用在内核空间中执行，任由用户将不合法的输入传递给内核，系统大的安全和稳定性将面临考验。进程不能让内核访问那些他没有权限访问的数据。</p>
<ul>
<li>与文件IO有关的系统调用需要检查文件描述符是否有效，与进程有关的函数必须检查提供的PID是否有效。</li>
<li>检查用户提供的指针是否有效<ul>
<li>指针指向的内存区域只能属于用户空间，进程不能告诉内核去读内核空间中的数据。</li>
<li>指针指向的内存区域在自己的进程中，不能让内核去读其他进程中的数据。</li>
<li>进程不能越过内存访问限制（可读、可写、可执行）</li>
</ul>
</li>
<li>检查是否有合法权限</li>
</ul>
<p>内核提供了两个方法来完成必须的检查和内核空间与用户空间之间的数据来回拷贝</p>
<ul>
<li>写入：copy_to_user()</li>
<li>读取：copy_from_user()</li>
</ul>
<p>这两个方法可能会引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，进程会休眠，直到缺页处理程序将该页从硬盘从新换回物理内存。</p>
<h3 id="7-系统调用上下文"><a href="#7-系统调用上下文" class="headerlink" title="7.系统调用上下文"></a>7.系统调用上下文</h3><p>在进程调用系统调用时，会有进程上下文。既可以被抢占也可以休眠。</p>
<p>可以休眠说明系统调用可以利用内核提供的绝大部分功能。可以被抢占说明该系统调用时可重入的（新的进程同样可以使用相同的系统调用）。</p>
<p>系统调用返回时，控制权仍然在system_call()中，它最终会负责切换到内核工作空间，并让用户进程继续执行下去。</p>
<h4 id="7-1绑定一个系统调用的最后步骤"><a href="#7-1绑定一个系统调用的最后步骤" class="headerlink" title="7.1绑定一个系统调用的最后步骤"></a>7.1绑定一个系统调用的最后步骤</h4><blockquote>
<p>1.在系统调用表中的最后加入一个表项。从0开始算起，系统调用在表中的位置就是他的系统调用号。</p>
</blockquote>
<blockquote>
<p>2.系统调用必须被编译进内核映像（不能被编译成模块）</p>
</blockquote>
<h4 id="7-2从用户空间访问系统调用"><a href="#7-2从用户空间访问系统调用" class="headerlink" title="7.2从用户空间访问系统调用"></a>7.2从用户空间访问系统调用</h4><p>系统调用靠的时C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用。</p>
<p><strong>Linux新系统调用增添频率很低，说明Linux系统是一个相对较为稳定并且功能已经较为完善的操作系统</strong></p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>Linux系统内核设计</tag>
      </tags>
  </entry>
  <entry>
    <title>红队常用行话总结一</title>
    <url>/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/</url>
    <content><![CDATA[<h2 id="漏洞利用术语解读"><a href="#漏洞利用术语解读" class="headerlink" title="漏洞利用术语解读"></a>漏洞利用术语解读</h2><blockquote>
<p>Vulnerability:即漏洞，</p>
</blockquote>
<p>是指计算机软件、硬件、系统、应用、协议等方面的缺陷，使得其保密性、完整性、可用性、访问控制等方面面临威胁。</p>
<ul>
<li><p>基于技术分类，有命令执行、权限绕过、缓存区溢出、注入、解析、弱口令、信息泄露等漏洞</p>
</li>
<li><p>基于时间分类，有0day、1day、Nday等漏洞</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/01.png" class>

<img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/02.png" class>

</li>
</ul>
<blockquote>
<p>Poc (Proof of Content)概念验证</p>
</blockquote>
<p>泛指对某些想法的一个较短而不完整的实现；在网络安全领域，通常指的是一段漏洞验证程序或者说是攻击样例，仅能验证漏洞存在，但并不能对漏洞造成实质性利用。在[计算机安全]术语中，<strong>概念验证</strong>经常被用来作为<a href="https://zh.wikipedia.org/wiki/0day">0day</a>、<a href="https://zh.wikipedia.org/wiki/Exploit">exploit</a>的别名。（通常指并没有充分利用这个漏洞的exploit）</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/03.png" class>

<blockquote>
<p>Exploit 漏洞利用</p>
</blockquote>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/04.png" class>



<p>代表一段有漏洞价值的攻击代码或者漏洞利用过程，目的是获取未经授权的访问或者执行意外操作。常见的漏洞利用手段包括SQL注入、缓存区溢出、远程代码执行等。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/05.png" class>

 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/06.png" class>



<blockquote>
<p>Payload 攻击载荷</p>
</blockquote>
<p>通常是指Exploit在拿下目标之后，攻击者在目标机器上执行的定制代码或者程序，包括但不限于系统命令、会话建立、Shellcode等。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/07.png" class>



<blockquote>
<p>Shellcode</p>
</blockquote>
<ul>
<li><p>shell：泛指系统控制权或者操作界面（CLI/GUI），通常在Exploit漏洞利用之后，首先要做的就是拿shell，以此进行进一步操作。</p>
</li>
<li><p>shellcode：用于获取控制权或者操作界面的攻击载荷代码，通常采用二进制机器代码，shellcode也是payload的一种类型</p>
</li>
<li><p>正反shell：shell需要绑定至指定IP地址后端口号上面，这个动作就是bindshell；有攻击方主动连接至受害者，则为正向shell；反之，由受害者主动连接至攻击方，则为反向shell。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/08.png" class>

</li>
</ul>
<p>shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。</p>
<ul>
<li>本地shellcode：本地运行的shellcode经常用于利用软件<a href="https://zh.wikipedia.org/wiki/%E6%BC%8F%E6%B4%9E">漏洞</a>提升权限。比如在Linux下由普通权限提升至<a href="https://zh.wikipedia.org/wiki/Root%E6%9D%83%E9%99%90">root权限</a>。</li>
<li>远程shellcode：借由抓软件漏洞获得特定的shellcode，再经由C或Python撰写远端攻击程式，进而取得对方电脑之root权限。</li>
</ul>
<h2 id="恶意程序术语解读"><a href="#恶意程序术语解读" class="headerlink" title="恶意程序术语解读"></a>恶意程序术语解读</h2><blockquote>
<p>Malware(Malicious Software) </p>
</blockquote>
<p>即恶意程序或软件，泛指病毒、蠕虫、木马、勒索软件、间谍软件，用于对目标系统进行入侵、控制、窃取、破坏等。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/09.png" class>

<blockquote>
<p>Worm</p>
</blockquote>
<p>Worm即蠕虫病毒，能够独立于其他文件或者程序运行，能够给予网络进行自我复制或者传播，能实现从点到面的超大规模的破坏行为（例如占用CPU或带宽资源、修改删除文件）。</p>
<p>计算机病毒不同的是，计算机蠕虫不需要附在别的程序内，可能不用用户介入操作也能自我复制或运行。计算机蠕虫未必会直接破坏被感染的系统，却几乎都对网络有害。计算机蠕虫可能会执行垃圾代码以发动分布式拒绝服务攻击，令计算机的执行效率极大程度降低，从而影响计算机的正常使用；可能会损毁或修改目标计算机的文件；亦可能只是浪费<a href="https://zh.wikipedia.org/wiki/%E9%A0%BB%E5%AF%AC">带宽</a>。（恶意的）计算机蠕虫可根据其目的分成2类：</p>
<ul>
<li>一种是面对大规模计算机使用网络发动拒绝服务的计算机蠕虫，虽说会绑架计算机，但用户可能还可以正常使用，只是会被占用一部分运算、连网能力。</li>
<li>另一种是针对个人用户的以执行大量垃圾代码的计算机蠕虫。计算机蠕虫多不具有跨平台性，但是在其他平台下，可能会出现其平台特有的非跨平台性的平台版本。</li>
</ul>
<p>计算机蠕虫的传播过程：蠕虫程序常驻于一台或多台机器中，通常它会扫描其他机器是否有感染同种计算机蠕虫，如果没有，就会通过其内置的传播手段进行感染，以达到使计算机瘫痪的目的。其通常会以宿主机器作为扫描源。通常采用：<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6">垃圾邮件</a>、漏洞传播这2种方法来传播</p>
<p>例子：2006年的熊猫烧香，通过网站投毒、局域网共享等方式植入系统并进行传播，Windows用户中毒后，后缀名为.exe的文件无法执行，文件图标会变成熊猫烧香的图案。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/10.png" class>





<blockquote>
<p>Virus病毒</p>
</blockquote>
<p>通常依附于其他文件或者程序上，不进行自我复制获知或者传播，当受害者运行其它程序时则病毒启动，对目标系统造成破坏（例如修改删除文件）。</p>
<p>例子：1998年的<strong>CIH病毒</strong>，能够破坏BIOS和硬盘，是电脑可以完全瘫痪，被公认为有史以来最为危险、破坏力最强的病毒之一。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/11.png" class>

<p>! <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/12.png" class></p>
<p>由于<a href="https://zh.wikipedia.org/wiki/%E4%B8%96%E7%95%8C">世界</a><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>[桌面环境]90%的市场都是使用<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF">微软</a>[Windows] 系列产品 ， 所以病毒作者纷纷把病毒攻击对象选为Windows。制作病毒者首先应该确定要攻击的操作系统版本有何<a href="https://zh.wikipedia.org/wiki/%E6%BC%8F%E6%B4%9E">漏洞</a>，这才是他所写的病毒能够利用的关键。Windows当时并没有有效的安全与防御功能，且用户常以管理员权限运行未经安全检查的软件，这也为Windows下病毒的泛滥提供了温床。<a href="https://zh.wikipedia.org/wiki/Linux">Linux</a>、<a href="https://zh.wikipedia.org/wiki/Mac_OS">Mac OS</a>等<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>，因使用的人群比较少，病毒一般不容易扩散。大多病毒发布作者的目的有多种，包括恶作剧、想搞破坏、报复及想出名与对研究病毒有特殊嗜好。 病毒主要通过<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF">网路</a>浏览以及<a href="https://zh.wikipedia.org/wiki/%E4%B8%8B%E8%BD%BD">下载</a>，<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>以及可移动<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E7%A2%9F">磁盘</a>等途径迅速传播。[<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92#cite_note-mc-4">4</a></p>
<p>Trojan Horse(特洛伊木马)</p>
<p>通常潜伏于“合法”软件中运行（也可以独立运行），不复制传播且高度隐蔽。木马运行时可以创建“后门”或者“隧道”，攻击者通过后门实现对目标系统的远程控制、监听、破坏行为。RAT（Remote Access Trojan）远控木马属于木马的一种，例如灰鸽子、冰河、Gh0st、ZXShell。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/13.png" class>





<blockquote>
<p>Ransomware(勒索软件)</p>
</blockquote>
<p>能够独立于其他文件运行，能够基于网络进行自我复制或者传播，通过对目标系统进行加密劫持，实现对受害者的钱财勒索。在所有的恶意程序类别中，勒索软件时面向个人和机构的最直接、最有效、最野蛮的“敛财方式”。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/14.png" class>

<blockquote>
<p>Spyware(间谍软件)</p>
</blockquote>
<p>流氓软件或者恶意软件，指未经用户许可搜集用户个人信息的恶意程序。通过搜集网站的浏览记录、键盘记录、账号密码等隐私信息，再以网站劫持、网址导航、弹框广告等方式变现盈利。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/15.png" class>



<blockquote>
<p>Rootkits</p>
</blockquote>
<p>可看作升级型的木马病毒，泛指可以获取到<strong>root</strong>权限的恶意程序，以管理员权限运行、修改系统核心文件、绕过杀毒软件，包括系统内核rootkit、硬件固件rootkit、内存rootkit等类型。相比木马，Rootkits通常具备更高权限、更加隐蔽、更难查杀、更大危害等特征。、</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>组件基础</title>
    <url>/2021/03/14/%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>红队攻防入门1</title>
    <url>/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/</url>
    <content><![CDATA[<h2 id="红队攻防入门1–初识红队"><a href="#红队攻防入门1–初识红队" class="headerlink" title="红队攻防入门1–初识红队"></a>红队攻防入门1–初识红队</h2><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F1.png" class>

<p>###红队概念</p>
<p><strong>红队（Red Team）即安全团队最大化模拟真实世界里面的入侵事件，采用入侵者的战术、技术、流程，以此来检验蓝队（Blue Team）的威胁检测和应急响应的机制和效率，最终帮助企业真正提高整个安全建设、安全运营、安全管理等能力。</strong></p>
<p>####1.1红队VS渗透测试</p>
<p>在企业内部的一般的渗透测试，很多就是点到为止，并不会被授予很多的权限。而红队整体来看，在合法合规的前提下，在充分沟通的前提下，授权范围会更加广泛，真实程度更加贴合实战。</p>
<img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F2.jpg" class>

<h4 id="1-2红队VS蓝队"><a href="#1-2红队VS蓝队" class="headerlink" title="1.2红队VS蓝队"></a>1.2红队VS蓝队</h4><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F3.jpg" class>

<p>无论是Red Team 还是Blue Team,这些概念都来自真实的战争领域。</p>
<blockquote>
<p>作为红队，是以攻击方的方式做安全工作的，常见的技术概念有APT攻击、渗透测试、零日漏洞、武器开发。</p>
</blockquote>
<blockquote>
<p>作为蓝队，则以防御方的方式做安全工作，是安全合规、安全运营、应急响应、态势感知、威胁情报等等。</p>
</blockquote>
<p>####1.3 红队常用模型框架</p>
 <img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F4.jpg" class>



<p>#####1.3.1渗透测试执行标准PTES</p>


<p>PTES中文全名【渗透测试执行标准】，他是有2010年由业界网络安全专家共同发起并定义的规范，目标是希望为企业和安全服务商，指定整个渗透测试的标准流程，方便大家工作和沟通。</p>
<p>PTES 包括 7 个标准步骤，即前期交互、情报收集、威胁建模、漏洞分析、渗透利用、报告输出等，一般的渗透测试工作，基本都绕不开这些步骤，可以看成一个标准的工作流。</p>
<p><strong>① 前期交互</strong></p>
<p>前期交互阶段，我们得先拿到客户的授权，并且了解授权范围多少？渗透目标是谁？期望目标是什么？</p>
<p>这些都是前期交互阶段要沟通好的。</p>
<p><strong>② 情报搜集</strong></p>
<p>情报搜集阶段，即根据上面的授权、范围、目标等信息，开始进行一些情报搜集工作。</p>
<p>无论是主动搜集还是被动搜集，我们得知道对方开了哪个端口、提供了什么服务、这些服务的软件版本是什么、这些软件是否曾经出现过漏洞？</p>
<p><strong>③ 威胁建模</strong></p>
<p>哪些信息是真正有价值的？哪个口子用什么攻击方法？哪条攻击路径是最大可能的？</p>
<p>根据情报搜集的汇总，我们得制定出接下来的「作战计划」。</p>
<p>这些就是在威胁建模阶段要分析出来的。</p>
<p><strong>④ 漏洞分析</strong></p>
<p>结合以上情报搜集和威胁建模阶段，此阶段我们要判断出哪些漏洞是最有可能拿到对方权限，打通攻击路径的。</p>
<p>哪些漏洞的攻击效果最佳？</p>
<p>哪些漏洞有最新的工具？</p>
<p>哪些漏洞需要自研渗透代码？</p>
<p><strong>⑤ 渗透利用</strong></p>
<p>前面 4 个阶段都不算真正 Hack 进目标系统，而这个阶段则是真正对目标进行渗透攻击，通过漏洞对应的利用工具等，获取目标控制权。</p>
<p><strong>⑥ 后渗透</strong></p>
<p>在拿到控制权限之后，为了避免对方发现，还需要进行后渗透，实现更持久地控制，更深层次地执行任务。</p>
<p>比如进程迁移、隧道建立、数据获取、擦除痕迹等。</p>
<p><strong>⑦ 报告输出</strong></p>
<p>最后阶段就是输出一份安全报告，即写明渗透测试工作中，企业 IT 基础系统所存在的漏洞和风险点。</p>
<p>以上便是 PTES 渗透测试执行标准。</p>
<h5 id="1-3-2网络杀伤链Cyber-Kill-Chain"><a href="#1-3-2网络杀伤链Cyber-Kill-Chain" class="headerlink" title="1.3.2网络杀伤链Cyber Kill Chain"></a>1.3.2网络杀伤链Cyber Kill Chain</h5><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F6.jpg" class>

<p>网络杀伤链的英文全名是 Cyber Kill Chain，这是 2011 年洛克希德马丁公司提出的网络攻击模型。</p>
<p>跟真实世界的入侵者，对一个目标系统进行攻击的每个阶段都是一一映射的。</p>
<p>这里也分为 7 个步骤 =&gt;</p>
<p><strong>第 1 步，目标侦察，</strong>跟前面 PTES 情报收集阶段是差不多的；</p>
<p><strong>第 2 步，武器研制，</strong>编写各种工具/后门/病毒 Exp / Weapon / Malware；</p>
<p><strong>第 3 步，载荷投递，</strong>通过水坑鱼叉等攻击方式将武器散播出去（<strong>投毒</strong>）；</p>
<p><strong>第 4 步，渗透利用，</strong>通过<strong>漏洞利用</strong>获取对方控制器；</p>
<p><strong>第 5 步，安装执行</strong>，在目标系统将<strong>后门木马</strong>跑起来；</p>
<p><strong>第 6 步，命令控制，</strong>对目标来进行<strong>持久化控制</strong>；</p>
<p><strong>第 7 步，任务执行，</strong>即开始执行<strong>窃取数据、破坏系统</strong>等。</p>
<p>以上便是网络杀伤链，相比 PTES 更加贴合实战阶段。</p>
<h5 id="1-3-3MITRE-ATT-amp-CK框架"><a href="#1-3-3MITRE-ATT-amp-CK框架" class="headerlink" title="1.3.3MITRE ATT&amp;CK框架"></a>1.3.3MITRE ATT&amp;CK框架</h5><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F7.jpg" class>

<p>「<strong>ATT&amp;CK 框架</strong>」，由 MITRE 公司于 2013 年提出来的一个通用知识框架，中文名叫做「<strong>对抗战术、技术、常识</strong> 」 。</p>
<p>ATT&amp;CK 框架是基于真实网络空间攻防案例及数据，采用军事战争中的 <strong>TTPs （Tactics, Techniques &amp; Procedures）</strong>方法论，重新编排的网络安全知识体系，目的是建立一套网络安全的通用语言。</p>
<p>举例，大家经常听到的什么 APT 攻击、威胁情报、态势感知等等，无论个人还是企业，理解上不尽相同，总会有一些偏差的。</p>
<p>有了 ATT&amp;CK 框架，大家不会存在太大的偏差，红队具体怎么去攻击的，蓝队具体到怎么去防御的，使用 ATT&amp;CK 矩阵可以将每个细节标记出来，攻击路线和防御过程都可以图形展现出来，攻防双方就有了一套通用语言了。</p>
<p>网络安全行业的组织、机构、厂家，每年都会造各种 ”新词“，但 MITRE 这个组织推的这套框架，兼具实战和学术价值，具备广泛的应用场景，对安全行业的发展推动是实实在在的。</p>
<p>我认为，在未来 5 年也好 10 年也好 ，它可能会成为一个事实上的标准。</p>
<p>这里看一下左上角图片，它整体有三个部分，一个是 PRE ATT&amp;CK，一个是 ATT&amp;CK for Enterprise，一个是 ATT&amp;CK for Mobile，我们学习和研究时，核心放在 ATT&amp;CK forEnterprise 即可。</p>
<p>大家可以看到，其实左边这里面，也有侦查、武器化、载荷传递、利用、控制、执行、维持等等阶段，是不是跟前面介绍的网络杀伤链是一样的呢？</p>
<p>是的，你可以这么简单理解，其实 ATT&amp;CK 这个框架，刚开始就是在杀伤链的基础上，提供了更加具体的、更细颗粒度的战术、技术、文档、工具、描述等等。</p>
<p>因此，如果要深入学习红队，平常可以多逛逛去 ATT&amp;CK 框架官网。</p>
<img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F8.jpg" class>

<p>接下来，我们来重点看一下 ATT&amp;CK for Enterprise。</p>
<p>这张图里面，横轴代表是战术（Tactics），最新版本里横轴包括的战术有 12 个（原来是 10 个），纵轴代表的是技术（Techniques）有 156 个技术 272 个子技术。</p>
<p>前面我们提到了，它是基于 TTPs 方法来描述的，所以非常标准和通用。</p>
<p>在实际的红蓝对抗、威胁情报分析、安全差距评估等工作场景中，都可以用得上。</p>
<p>另外补充一点，这 12 个战术从左到右，也是按照网络杀伤链的路径来编排的，包括初始访问、执行、持久化、权限提升、防御绕过、凭证访问、发现、横向移动、收集、命令控制、数据获取、影响。</p>
<p>每一个战术下面包括很多技术，每个技术有详细的过程，包括独立的编号、描述、工具等。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>组件进阶篇--深入了解组件</title>
    <url>/2021/03/14/%E7%BB%84%E4%BB%B6%E8%BF%9B%E9%98%B6%E7%AF%87-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>编程范式</title>
    <url>/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>相信绝大部分开发人员、DBA都听过范式这个词，在MySQL中有第一范式、第二范式、第三范式、BCNF范式等，在开发中也有相应的范式，专业词汇叫编程范式(ProgrammingParadigm)。由于笔者能力、精力都有限，本篇主要通过针对同一业务场景，基于编程范式的概念，核心原理以及用例实现来对比不同范式及其实现业务功能的差异。</p>
<p>范式分类</p>
<p>如图1所示，范式可以简单分为三类:</p>
<p>图1: 范式的简单分类</p>
 <img data-src="/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/01.jpg" class>

<p>范式和语言的关系</p>
<p>图2: 范式和语言的关系</p>
 <img data-src="/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/02.jpg" class>

<p>与成百种编程语言相比，编程范式要少得多，如图2所示，共有27种范式。多数范式之间仅相差一个或几个概念，比如图中的函数编程范式，在加入了状态（state）之后就变成了面向对象编程范式。</p>
<p>| 编程范式</p>
<p>图3: 华山派剑气之争</p>
 <img data-src="/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/03.jpg" class>

<blockquote>
<p>过程式编程的核心在于模块化，在实现过程中使用了状态，依赖了外部变量，导致很容易影响附近的代码，可读性较少，后期的维护成本也较高。</p>
</blockquote>
<blockquote>
<p>函数式编程的核心在于“避免副作用”，不改变也不依赖当前函数外的数据。结合不可变数据、函数是第一等公民等特性，使函数带有自描述性，可读性较高。</p>
</blockquote>
<blockquote>
<p>面向对象编程的核心在于抽象，提供清晰的对象边界。结合封装、集成、多态特性，降低了代码的耦合度，提升了系统的可维护性。</p>
</blockquote>
<p>不同的范式的出现，目的就是为了应对不同的场景，但最终的目标都是提高生产力。就如华山派的剑宗、气宗之别，剑宗认为“剑为主，气为辅”，而气宗则反之。每个范式都会有自己的”心法”，但最终殊途同归，达到至高境界后则是剑气双修。</p>
<p>| 小结</p>
<p>阅读完之前内容后，相信各位读者对编程范式有了初步的理解，那么接下来就和笔者一起来实现业务的真实需求。</p>
<p>| 需求</p>
<pre><code> 1.解析并收集shannon, fio 两种 flash卡的温度、寿命等信息。

 2.对实现代码进行单元测试</code></pre>
<p>在用过程式实现之前，笔者先给大家介绍下什么叫过程式编程。</p>
<p>| 过程式编程(Procedural)</p>
<p>过程式编程和面向对象编程的区别并不在于是否使用函数或者类，也就是说用到类或对象的可能是过程式编程，只用函数而没有类的也可能是面向对象编程。那么他们的区别又在哪儿呢？</p>
<p>面向过程其实是最为实际的一种思考方式，可以说面向过程是一种基础的方法，它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。当程序规模不是很大时，面向过程的方法还会体现出一种优势。因为程序的流程很清楚，按着模块与函数的方法可以很好的组织。</p>
<p>关键部分实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shannon_info</span>(<span class="params">output</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取shannon类型flash卡信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_health</span>():</span></span><br><span class="line">        time_left = <span class="built_in">float</span>(sub_info[<span class="string">&quot;life_left&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> time_left &lt; DISK_ALARM_LIFETIME:</span><br><span class="line">            message = <span class="string">&quot;time left is less than &#123;&#125;%&quot;</span>.<span class="built_in">format</span>(DISK_ALARM_LIFETIME)</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        temperature = <span class="built_in">float</span>(sub_info[<span class="string">&quot;temperature&quot;</span>].split()[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> temperature &gt; DISK_ALARM_TEMPERATURE:</span><br><span class="line">            message = <span class="string">&quot;temperature is over than &#123;&#125; C&quot;</span>.<span class="built_in">format</span>(DISK_ALARM_TEMPERATURE)</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;healthy&quot;</span></span><br><span class="line"> </span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    all_info = _get_shannon_info(output)</span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> all_info:</span><br><span class="line">        sub_info = &#123;&#125;</span><br><span class="line">        sub_info[<span class="string">&quot;available_capacity&quot;</span>] = info.get(<span class="string">&quot;disk_capacity&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;device_name&quot;</span>] = info.get(<span class="string">&quot;block_device_node&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;firmware_version&quot;</span>] = info.get(<span class="string">&quot;firmware_version&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;interface&quot;</span>] = <span class="string">&quot;PCIe&quot;</span></span><br><span class="line">        sub_info[<span class="string">&quot;life_left&quot;</span>] = <span class="built_in">str</span>(info.get(<span class="string">&quot;estimated_life_left&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;%&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        sub_info[<span class="string">&quot;pcie_id&quot;</span>] = info.get(<span class="string">&quot;pci_deviceid&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;pcie_length&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">        sub_info[<span class="string">&quot;pcie_type&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">        sub_info[<span class="string">&quot;physical_read&quot;</span>] = info.get(<span class="string">&quot;host_read_data&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;physical_write&quot;</span>] = info.get(<span class="string">&quot;total_write_data&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;serial_number&quot;</span>] = info.get(<span class="string">&quot;serial_number&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;temperature&quot;</span>] = info.get(<span class="string">&quot;controller_temperature&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;type&quot;</span>] = info[<span class="string">&quot;type&quot;</span>]</span><br><span class="line">        sub_info[<span class="string">&quot;error_msg&quot;</span>] = check_health()</span><br><span class="line">        sub_info[<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;ok&quot;</span> <span class="keyword">if</span> sub_info[<span class="string">&quot;error_msg&quot;</span>] == <span class="string">&quot;healthy&quot;</span> <span class="keyword">else</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">if</span> sub_info[<span class="string">&quot;serial_number&quot;</span>]:</span><br><span class="line">            result[sub_info[<span class="string">&quot;serial_number&quot;</span>]] = sub_info</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[sub_info[<span class="string">&quot;device_name&quot;</span>]] = sub_info</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>代码问题</p>
<pre><code>1.逻辑冗长，局部修改必须阅读整段代码

2.对外部变量有依赖

3.内部存在共享变量

4.函数内部存在临时变量</code></pre>
<p>测试代码</p>
<p>过程式的测试代码效果远不如函数式有效，过程式的实现逻辑过于冗长，导致测试效果并不够好。</p>
<p>| 函数式编程(Functional)</p>
<p>当谈论函数式编程，会提到非常多的“函数式”特性。提到不可变数据，第一类对象以及尾调用优化，这些是帮助函数式编程的语言特征。提到mapping（映射），reducing（归纳），piplining（管道），recursing（递归），currying（科里化），以及高阶函数的使用，这些是用来写函数式代码的编程技术。提到并行，惰性计算以及确定性，这些是有利于函数式编程的属性。</p>
<p>最主要的原则是避免副作用，它不会依赖也不会改变当前函数以外的数据。</p>
<p>声明式的函数，让开发者只需要表达 “想要做什么”，而不需要表达 “怎么去做”，这样就极大地简化了开发者的工作。至于具体 “怎么去做”，让专门的任务协调框架去实现，这个框架可以灵活地分配工作给不同的核、不同的计算机，而开发者不必关心框架背后发生了什么。</p>
<p>关键部分实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shannon_info</span>(<span class="params">output</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询shannon类型flash卡信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lines = checks_string_split_by_function(output, is_shannon_flash_device)</span><br><span class="line">    info = <span class="built_in">map</span>(parser_shannon_info, lines)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># map(lambda x: x.setdefault(&quot;type&quot;, &quot;shannon&quot;), info)</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line">        item[<span class="string">&quot;type&quot;</span>] = <span class="string">&quot;shannon&quot;</span></span><br><span class="line"> </span><br><span class="line">    data = <span class="built_in">map</span>(modify_the_properties, info)</span><br><span class="line">    <span class="keyword">return</span> reduce(combining_data, <span class="built_in">map</span>(convert_data_format, data))</span><br></pre></td></tr></table></figure>
<p>以上代码带有自描述性，通过函数名就可知在做什么，这也是函数式的一个特性: 代码是在描述要干什么，而不是怎么干。</p>
<p>测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;line, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash car&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash card a&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash card&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash card.&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_is_shannon_flash_device</span>(<span class="params">line, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.is_shannon_flash_device(line) == result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;line, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;a=1&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;b=2&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;c=2333&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;d x=abcde&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE=1&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abcdedfew=&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot; =Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;=Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE=&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE= &quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_is_effective_value</span>(<span class="params">line, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.is_effective_value(line) == result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;line, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;a=1&quot;</span>, &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;1&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;b=2&quot;</span>, &#123;<span class="string">&quot;b&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;a=a&quot;</span>, &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abc=a&quot;</span>, &#123;<span class="string">&quot;abc&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abc=abcde&quot;</span>, &#123;<span class="string">&quot;abc&quot;</span>: <span class="string">&quot;abcde&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_gets_the_index_name_and_value</span>(<span class="params">line, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.gets_the_index_name_and_value(line) == result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;output, filter_func, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abcd\nbcd\nabcd\nbcd\naa\naa&quot;</span>, <span class="keyword">lambda</span> x: <span class="string">&quot;a&quot;</span> <span class="keyword">in</span> x, [<span class="string">&quot;abcd\nbcd&quot;</span>, <span class="string">&quot;abcd\nbcd&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>]</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="built_in">open</span>(<span class="params">os.path.join(<span class="params">project_path, <span class="string">&quot;fixtures&quot;</span>, <span class="string">&quot;shannon-status.txt&quot;</span></span>)</span>).read(<span class="params"></span>), functional.is_shannon_flash_device, [</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="params">    <span class="built_in">open</span>(<span class="params">os.path.join(<span class="params">project_path, <span class="string">&quot;fixtures&quot;</span>, <span class="string">&quot;shannon-sctb.txt&quot;</span></span>)</span>).read(<span class="params"></span>),</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="params">    <span class="built_in">open</span>(<span class="params">os.path.join(<span class="params">project_path, <span class="string">&quot;fixtures&quot;</span>, <span class="string">&quot;shannon-scta.txt&quot;</span></span>)</span>).read(<span class="params"></span>)</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="params">]</span>)</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_checks_string_split_by_function</span>(<span class="params">output, filter_func, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.checks_string_split_by_function(output, filter_func) == result</span><br></pre></td></tr></table></figure>
<p>| 面向对象编程(Object-Oriented)</p>
<p>并不是使用类才是面向对象编程。如果你专注于状态改变和密封抽象，你就是在用面向对象编程。类只是帮助简化面向对象编程的工具，并不是面向对象编程的要求或指示器。封装是一个过程，它分隔构成抽象的结构和行为的元素。封装的作用是分离抽象的概念接口及其实现。类只是帮助简化面向对象编程的工具，并不是面向对象编程的要求或指示器。</p>
<p>随着系统越来越复杂，系统就会变得越来越容易崩溃，分而治之，解决复杂性的技巧。面对对象思想的产生是为了让你能更方便的理解代码。有了那些封装，多态，继承，能让你专注于部分功能，而不需要了解全局。</p>
<p>关键部分实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IFlash</span>(<span class="params">six.with_metaclass(<span class="params">abc.ABCMeta</span>)</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;收集flash卡物理信息</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlashShannon</span>(<span class="params">IFlash</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宝存的Flash卡</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, txt_path, command, printer</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FlashShannon, self).__init__()</span><br><span class="line">        self.txt_path = txt_path</span><br><span class="line"> </span><br><span class="line">        self.command = command</span><br><span class="line">        self.printer = printer</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> self._get_shannon_info():</span><br><span class="line">            life_left = <span class="built_in">str</span>(info.get(<span class="string">&quot;estimated_life_left&quot;</span>, <span class="string">&quot;&quot;</span>)).replace(<span class="string">&quot;%&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            temperature = info.get(<span class="string">&quot;controller_temperature&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            error_msg = self._get_health_message(life_left, temperature)</span><br><span class="line">            sub_info = &#123;</span><br><span class="line">                <span class="string">&quot;available_capacity&quot;</span>: info.get(<span class="string">&quot;disk_capacity&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;device_name&quot;</span>: info.get(<span class="string">&quot;block_device_node&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;firmware_version&quot;</span>: info.get(<span class="string">&quot;firmware_version&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;interface&quot;</span>: <span class="string">&quot;PCIe&quot;</span>,</span><br><span class="line">                <span class="string">&quot;life_left&quot;</span>: life_left,</span><br><span class="line">                <span class="string">&quot;pcie_id&quot;</span>: info.get(<span class="string">&quot;pci_deviceid&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;pcie_length&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;pcie_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;physical_read&quot;</span>: info.get(<span class="string">&quot;host_read_data&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;physical_write&quot;</span>: info.get(<span class="string">&quot;total_write_data&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;serial_number&quot;</span>: info.get(<span class="string">&quot;serial_number&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;temperature&quot;</span>: temperature,</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: info[<span class="string">&quot;type&quot;</span>],</span><br><span class="line">                <span class="string">&quot;error_msg&quot;</span>: error_msg,</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span> <span class="keyword">if</span> error_msg == <span class="string">&quot;healthy&quot;</span> <span class="keyword">else</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> sub_info[<span class="string">&quot;serial_number&quot;</span>]:</span><br><span class="line">                result[sub_info[<span class="string">&quot;serial_number&quot;</span>]] = sub_info</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[sub_info[<span class="string">&quot;device_name&quot;</span>]] = sub_info</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlashFio</span>(<span class="params">IFlash</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;fio的Flash卡</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, txt_path</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FlashFio, self).__init__()</span><br><span class="line">        self.txt_path = txt_path</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span>(<span class="params">self</span>):</span></span><br><span class="line">        disk_info = &#123;&#125;</span><br><span class="line">        adapter_info = self._get_adapter_info()</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> adapter_info:</span><br><span class="line">            serial_number = info[<span class="string">&quot;fio_serial_number&quot;</span>]</span><br><span class="line">            <span class="keyword">for</span> io <span class="keyword">in</span> info[<span class="string">&quot;iomemory&quot;</span>]:</span><br><span class="line">                data = self._combining_io_memory(io)</span><br><span class="line">                data[<span class="string">&quot;serial_number&quot;</span>] = serial_number</span><br><span class="line">                disk_info[serial_number] = data</span><br><span class="line">        <span class="keyword">return</span> disk_info</span><br></pre></td></tr></table></figure>
<p>| 编程范式带来的好处</p>
<p>范式就像武功心法，可以更快的练成绝世神功，但还是离不开基础功。代码也一样，通过遵循相关范式和良好的设计后，会带来可读性、扩展性和可维护性更好的代码，进而提升软件的质量。</p>
<p>| 总结</p>
<p>命令式编程、面向对象编程、函数式编程，虽然受人追捧的时间点各不相同，但是本质上并没有优劣之分。 面向对象和函数式、过程式编程也不是完成独立和有严格的界限，在抽象出各个独立的对象后，每个对象的具体行为实现还是有函数式和过程式完成。</p>
<p>现代的程序员应该很少有门派之见了，应该集百家之所长，学习其它范式(语言)的优秀设计理念，集成到自己的代码(产品、语言)中，提升工作效率。</p>
]]></content>
      <categories>
        <category>计算机常识</category>
      </categories>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机种类</title>
    <url>/2021/03/14/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>表单输入绑定</title>
    <url>/2021/03/14/%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>计算属性与监听器setter</title>
    <url>/2021/03/14/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%9B%91%E5%90%AC%E5%99%A8setter/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>设计消息队列--&gt;2</title>
    <url>/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>持久性是事务的一个特性，然而只满足持久性却不一定能满足事务的特性。还是拿扣钱/加钱的例子讲。满足事务的一致性特征，则必须要么都不进行，要么都能成功。 解决方案从大方向上有两种：</p>
<blockquote>
<p>两阶段提交，分布式事务。</p>
</blockquote>
<blockquote>
<p>本地事务，本地落地，补偿发送。</p>
</blockquote>
<p>分布式事务存在的最大问题是成本太高，两阶段提交协议，对于仲裁down机或者单点故障，几乎是一个无解的黑洞。对于交易密集型或者I/O密集型的应用，没有办法承受这么高的网络延迟，系统复杂性。 并且成熟的分布式事务一定构建与比较靠谱的商用DB和商用中间件上，成本也太高。 那如何使用本地事务解决分布式事务的问题呢？以本地和业务在一个数据库实例中建表为例子，与扣钱的业务操作同一个事务里，将消息插入本地数据库。如果消息入库失败，则业务回滚；如果消息入库成功，事务提交。 然后发送消息（注意这里可以实时发送，不需要等定时任务检出，以提高消息实时性）。以后的问题就是前文的最终一致性问题所提到的了，只要消息没有发送成功，就一直靠定时任务重试。 这里有一个关键的点，本地事务做的，是业务落地和消息落地的事务，而不是业务落地和RPC成功的事务。这里很多人容易混淆，如果是后者，无疑是事务嵌套RPC，是大忌，会有长事务死锁等各种风险。 而消息只要成功落地，很大程度上就没有丢失的风险（磁盘物理损坏除外）。而消息只要投递到服务端确认后本地才做删除，就完成了producer-&gt;broker的可靠投递，并且当消息存储异常时，业务也是可以回滚的。 本地事务存在两个最大的使用障碍：</p>
<blockquote>
<p>配置较为复杂，“绑架”业务方，必须本地数据库实例提供一个库表。</p>
</blockquote>
<blockquote>
<p>对于消息延迟高敏感的业务不适用。</p>
</blockquote>
<p>话说回来，不是每个业务都需要强事务的。扣钱和加钱需要事务保证，但下单和生成短信却不需要事务，不能因为要求发短信的消息存储投递失败而要求下单业务回滚。所以，一个完整的消息队列应该定义清楚自己可以投递的消息类型，如事务型消息，本地非持久型消息，以及服务端不落地的非可靠消息等。对不同的业务场景做不同的选择。另外事务的使用应该尽量低成本、透明化，可以依托于现有的成熟框架，如Spring的声明式事务做扩展。业务方只需要使用@Transactional标签即可。</p>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><h3 id="异步、同步"><a href="#异步、同步" class="headerlink" title="异步、同步"></a>异步、同步</h3><p>首先澄清一个概念，异步，同步和oneway是三件事。异步，归根结底你还是需要关心结果的，但可能不是当时的时间点关心，可以用轮询或者回调等方式处理结果；同步是需要当时关心 的结果的；而oneway是发出去就不管死活的方式，这种对于某些完全对可靠性没有要求的场景还是适用的，但不是我们重点讨论的范畴。 回归来看，任何的RPC都是存在客户端异步与服务端异步的，而且是可以任意组合的：客户端同步对服务端异步，客户端异步对服务端异步，客户端同步对服务端同步，客户端异步对服务端同步。 对于客户端来说，同步与异步主要是拿到一个Result，还是Future(Listenable)的区别。实现方式可以是线程池，NIO或者其他事件机制，这里先不展开讲。 服务端异步可能稍微难理解一点，这个是需要RPC协议支持的。参考servlet 3.0规范，服务端可以吐一个future给客户端，并且在future done的时候通知客户端。 整个过程可以参考下面的代码：</p>
<blockquote>
<p>客户端同步服务端异步</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = request(server);<span class="comment">//server立刻返回future</span></span><br><span class="line"><span class="keyword">synchronized</span>(future)&#123;</span><br><span class="line"><span class="keyword">while</span>(!future.isDone())&#123;</span><br><span class="line">   future.wait();<span class="comment">//server处理结束后会notify这个future，并修改isdone标志</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> future.get();</span><br></pre></td></tr></table></figure>


<blockquote>
<p>客户端同步服务端同步</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result result = request(server);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>客户端异步服务端同步（使用线程池方式）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = executor.submit(<span class="keyword">new</span> Callable()&#123;<span class="keyword">public</span> <span class="keyword">void</span> call&lt;Result&gt;()&#123;</span><br><span class="line">    result = request(server);</span><br><span class="line">&#125;&#125;)</span><br><span class="line"><span class="keyword">return</span> future;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>客户端异步服务端异步</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = request(server);<span class="comment">//server立刻返回future</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> future</span><br></pre></td></tr></table></figure>
<p>上面说了这么多，其实是想让大家脱离两个误区：</p>
<ul>
<li><p>RPC只有客户端能做异步，服务端不能。</p>
</li>
<li><p>异步只能通过线程池。</p>
</li>
</ul>
<p>那么，服务端使用异步最大的好处是什么呢？说到底，是解放了线程和I/O。试想服务端有一堆I/O等待处理，如果每个请求都需要同步响应，每条消息都需要结果立刻返回，那么就几乎没法做I/O合并 （当然接口可以设计成batch的，但可能batch发过来的仍然数量较少）。而如果用异步的方式返回给客户端future，就可以有机会进行I/O的合并，把几个批次发过来的消息一起落地（这种合并对于MySQL等允许batch insert的数据库效果尤其明显），并且彻底释放了线程。不至于说来多少请求开多少线程，能够支持的并发量直线提高。 来看第二个误区，返回future的方式不一定只有线程池。换句话说，可以在线程池里面进行同步操作，也可以进行异步操作，也可以不使用线程池使用异步操作（NIO、事件）。 回到消息队列的议题上，我们当然不希望消息的发送阻塞主流程（前面提到了，server端如果使用异步模型，则可能因消息合并带来一定程度上的消息延迟），所以可以先使用线程池提交一个发送请求，主流程继续往下走。 但是线程池中的请求关心结果吗？Of course，必须等待服务端消息成功落地，才算是消息发送成功。所以这里的模型，准确地说事客户端半同步半异步（使用线程池不阻塞主流程，但线程池中的任务需要等待server端的返回），server端是纯异步。客户端的线程池wait在server端吐回的future上，直到server端处理完毕，才解除阻塞继续进行。 总结一句，同步能够保证结果，异步能够保证效率，要合理的结合才能做到最好的效率。</p>
<h2 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h2><p>谈到批量就不得不提生产者消费者模型。但生产者消费者模型中最大的痛点是：消费者到底应该何时进行消费。大处着眼来看，消费动作都是事件驱动的。主要事件包括：</p>
<ol>
<li>攒够了一定数量。</li>
<li>到达了一定时间。</li>
<li>队列里有新的数据到来。</li>
</ol>
<p>对于及时性要求高的数据，可用采用方式3来完成，比如客户端向服务端投递数据。只要队列有数据，就把队列中的所有数据刷出，否则将自己挂起，等待新数据的到来。 在第一次把队列数据往外刷的过程中，又积攒了一部分数据，第二次又可以形成一个批量。伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">final</span> BlockingQueue&lt;Message&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Runnable task = <span class="keyword">new</span> Runnable(&#123;<span class="comment">//这里由于共享队列，Runnable可以复用，故做成全局的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;Message&gt; messages  = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">      queue.drainTo(messages，<span class="number">20</span>);</span><br><span class="line">      doSend(messages);<span class="comment">//阻塞，在这个过程中会有新的消息到来，如果4个线程都占满，队列就有机会囤新的消息</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    queue.offer(message);</span><br><span class="line">    executor.submit(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是消息延迟和批量的一个比较好的平衡，但优先响应低延迟。延迟的最高程度由上一次发送的等待时间决定。但可能造成的问题是发送过快的话批量的大小不够满足性能的极致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">final</span> BlockingQueue&lt;Message&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> last = System.currentMills();</span><br><span class="line">Executors.newSingleThreadScheduledExecutor().submit(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">   flush();</span><br><span class="line">&#125;，<span class="number">500</span>，<span class="number">500</span>，TimeUnits.MILLS);</span><br><span class="line"><span class="keyword">private</span> Runnable task = <span class="keyword">new</span> Runnable(&#123;<span class="comment">//这里由于共享队列，Runnable可以复用，顾做成全局的。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;Message&gt; messages  = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">      queue.drainTo(messages，<span class="number">20</span>);</span><br><span class="line">      doSend(messages);<span class="comment">//阻塞，在这个过程中会有新的消息到来，如果4个线程都占满，队列就有机会屯新的消息。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    last = System.currentMills();</span><br><span class="line">    queue.offer(message);</span><br><span class="line">    flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(queue.size&gt;<span class="number">200</span>||System.currentMills()-last&gt;<span class="number">200</span>)&#123;</span><br><span class="line">       executor.submit(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相反对于可以用适量的延迟来换取高性能的场景来说，用定时/定量二选一的方式可能会更为理想，既到达一定数量才发送，但如果数量一直达不到，也不能干等，有一个时间上限。 具体说来，在上文的submit之前，多判断一个时间和数量，并且Runnable内部维护一个定时器，避免没有新任务到来时旧的任务永远没有机会触发发送条件。对于server端的数据落地，使用这种方式就非常方便。</p>
<p>最后啰嗦几句，曾经有人问我，为什么网络请求小包合并成大包会提高性能？主要原因有两个：</p>
<ul>
<li><p>减少无谓的请求头，如果你每个请求只有几字节，而头却有几十字节，无疑效率非常低下。</p>
</li>
<li><p>减少回复的ack包个数。把请求合并后，ack包数量必然减少，确认和重发的成本就会降低。</p>
</li>
</ul>
<h3 id="push还是pull"><a href="#push还是pull" class="headerlink" title="push还是pull"></a>push还是pull</h3><p>上文提到的消息队列，大多是针对push模型的设计。现在市面上有很多经典的也比较成熟的pull模型的消息队列，如Kafka、MetaQ等。这跟JMS中传统的push方式有很大的区别，可谓另辟蹊径。 我们简要分析下push和pull模型各自存在的利弊。</p>
<h4 id="慢消费"><a href="#慢消费" class="headerlink" title="慢消费"></a>慢消费</h4><p>慢消费无疑是push模型最大的致命伤，穿成流水线来看，如果消费者的速度比发送者的速度慢很多，势必造成消息在broker的堆积。假设这些消息都是有用的无法丢弃的，消息就要一直在broker端保存。当然这还不是最致命的，最致命的是broker给consumer推送一堆consumer无法处理的消息，consumer不是reject就是error，然后来回踢皮球。 反观pull模式，consumer可以按需消费，不用担心自己处理不了的消息来骚扰自己，而broker堆积消息也会相对简单，无需记录每一个要发送消息的状态，只需要维护所有消息的队列和偏移量就可以了。所以对于建立索引等慢消费，消息量有限且到来的速度不均匀的情况，pull模式比较合适。</p>
<h3 id="消息延迟与忙等"><a href="#消息延迟与忙等" class="headerlink" title="消息延迟与忙等"></a>消息延迟与忙等</h3><p>这是pull模式最大的短板。由于主动权在消费方，消费方无法准确地决定何时去拉取最新的消息。如果一次pull取到消息了还可以继续去pull，如果没有pull取到则需要等待一段时间重新pull。 但等待多久就很难判定了。你可能会说，我可以有xx动态pull取时间调整算法，但问题的本质在于，有没有消息到来这件事情决定权不在消费方。也许1分钟内连续来了1000条消息，然后半个小时没有新消息产生， 可能你的算法算出下次最有可能到来的时间点是31分钟之后，或者60分钟之后，结果下条消息10分钟后到了，是不是很让人沮丧？ 当然也不是说延迟就没有解决方案了，业界较成熟的做法是从短时间开始（不会对broker有太大负担），然后指数级增长等待。比如开始等5ms，然后10ms，然后20ms，然后40ms……直到有消息到来，然后再回到5ms。 即使这样，依然存在延迟问题：假设40ms到80ms之间的50ms消息到来，消息就延迟了30ms，而且对于半个小时来一次的消息，这些开销就是白白浪费的。 在阿里的RocketMq里，有一种优化的做法-长轮询，来平衡推拉模型各自的缺点。基本思路是:消费者如果尝试拉取失败，不是直接return,而是把连接挂在那里wait,服务端如果有新的消息到来，把连接notify起来，这也是不错的思路。但海量的长连接block对系统的开销还是不容小觑的，还是要合理的评估时间间隔，给wait加一个时间上限比较好~</p>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>如果push模式的消息队列，支持分区，单分区只支持一个消费者消费，并且消费者只有确认一个消息消费后才能push送另外一个消息，还要发送者保证全局顺序唯一，听起来也能做顺序消息，但成本太高了，尤其是必须每个消息消费确认后才能发下一条消息，这对于本身堆积能力和慢消费就是瓶颈的push模式的消息队列，简直是一场灾难。 反观pull模式，如果想做到全局顺序消息，就相对容易很多：</p>
<ol>
<li>producer对应partition，并且单线程。</li>
<li>consumer对应partition，消费确认（或批量确认），继续消费即可。</li>
</ol>
<p>所以对于日志push送这种最好全局有序，但允许出现小误差的场景，pull模式非常合适。如果你不想看到通篇乱套的日志~~ Anyway，需要顺序消息的场景还是比较有限的而且成本太高，请慎重考虑。</p>
<p>本文从为何使用消息队列开始讲起，然后主要介绍了如何从零开始设计一个消息队列，包括RPC、事务、最终一致性、广播、消息确认等关键问题。并对消息队列的push、pull模型做了简要分析，最后从批量和异步角度，分析了消息队列性能优化的思路。 </p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>过度与动画</title>
    <url>/2021/03/14/%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/01/13/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。习惯于用头节点来代表整个单链表。</p>
<p>下面是一个单链表的例子：</p>
<p> <img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\Desktop\screen-shot-2018-04-12-at-152754.png" alt="screen-shot-2018-04-12-at-152754"></p>
<p>蓝色箭头显示单个链接列表中的结点是如何组合在一起的。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglyListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    SinglyListNode next;    <span class="comment">//定义对象，下一个节点</span></span><br><span class="line">    SinglyListNode(<span class="keyword">int</span> x)&#123;val=x;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单列表的操作"><a href="#单列表的操作" class="headerlink" title="单列表的操作"></a>单列表的操作</h3><p>与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费 O(N) 时间，其中 N 是链表的长度。</p>
<p>例如，在上面的示例中，头结点是 23。访问第 3 个结点的唯一方法是使用头结点中的“next”字段到达第 2 个结点（结点 6）; 然后使用结点 6 的“next”字段，我们能够访问第 3 个结点。</p>
<p>你可能想知道为什么链表很有用，尽管它在通过索引访问数据时（与数组相比）具有如此糟糕的性能。 在 插入和删除中，链表具有良好的性能。</p>
<h4 id="操作一：添加元素cur在prev之后"><a href="#操作一：添加元素cur在prev之后" class="headerlink" title="操作一：添加元素cur在prev之后"></a>操作一：添加元素cur在prev之后</h4><p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113091359911.png" alt="image-20210113091359911"></p>
<p>与数组对比，插入新元素不需要将插入节点后的所有元素都后移，因此，时间复杂度为O(1),</p>
<p><strong><em>特殊情况</em></strong></p>
<p>在开头添加结点：在列表开头添加新节点时更新头节点head至关重要。</p>
<ol>
<li>初始化一个新结点 <code>cur</code> ；</li>
<li>将新结点链接到我们的原始头结点 <code>head</code>。</li>
<li>将 <code>cur</code> 指定为 <code>head</code> 。</li>
</ol>
<p>在结尾添加节点</p>
<h4 id="操作二：从单链表中删除现有结点cur"><a href="#操作二：从单链表中删除现有结点cur" class="headerlink" title="操作二：从单链表中删除现有结点cur"></a>操作二：从单链表中删除现有结点cur</h4><p>删除操作 - 单链表<br>如果我们想从单链表中删除现有结点 cur，可以分两步完成：</p>
<p>找到 cur 的上一个结点 prev 及其下一个结点 next ；</p>
<p>接下来链接 prev 到 cur 的下一个节点 next 。</p>
<p>在我们的第一步中，我们需要找出 prev 和 next。使用 cur 的参考字段很容易找出 next，但是，我们必须<strong>从头结点遍历链表，以找出 prev</strong>，它的平均时间是 O(N)，其中 N 是链表的长度。因此，删除结点的时间复杂度将是 <u>O(N)</u>。</p>
<p>空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。</p>
<p>示例</p>
<p>让我们尝试把结点 6从上面的单链表中删除。</p>
<ol>
<li><p>从头遍历链表，直到我们找到前一个结点 prev，即结点 23</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092734343.png" alt="image-20210113092734343"></p>
</li>
<li><p>将 prev（结点 23）与 next（结点 15）链接</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092712828.png" alt="image-20210113092712828"></p>
</li>
</ol>
<p>结点 6 现在不在我们的单链表中。</p>
<p><strong>特殊情况</strong></p>
<p>删除第一个结点<br>如果我们想删除第一个结点，策略会有所不同。</p>
<p>正如之前所提到的，我们使用头结点 head 来表示链表。我们的头是下面示例中的黑色结点 23。</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092928077.png" alt="image-20210113092928077"></p>
<p>如果想要删除第一个结点，我们可以简单地将下一个结点分配给 head。也就是说，删除之后我们的头将会是结点 6。</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092949088.png" alt="image-20210113092949088"></p>
<p>链表从头结点开始，因此结点 23 不再在我们的链表中。</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>与单链表的区别在于：双链表除了有数据域和指向其后继的指针外，还有指向其前驱的指针。</p>
<p><strong>所以，根据链接数的不同，可以将链表分为单链表、双链表、多重链表</strong></p>
<h3 id="LC设计链表"><a href="#LC设计链表" class="headerlink" title="LC设计链表"></a>LC设计链表</h3><p>链表时一个包含零个或多个元素的数据结构。每个元素都包含一个值和到另一个元素的链接。根据链接数的不同，可以分为单链表，双链表和多重链表。</p>
<p>单链表是最简单的一种，它提供了在常数时间内的 addAtHead 操作和在线性时间内的 addAtTail 的操作。双链表是最常用的一种，因为它提供了在常数时间内的 addAtHead 和 addAtTail 操作，并且优化的插入和删除。</p>
<p>双链表在 Java 中的实现为 LinkedList，在 Python 中为 list。这些结构都比较常用，有两个要点：</p>
<p>1、<strong>哨兵节点</strong>：<br>哨兵节点在树和链表中被广泛用作<u>伪头、伪尾</u>等，通常不保存任何数据。</p>
<p>我们将使用伪头来简化我们简化插入和删除。在接下来的两种方法中应用此方法。</p>
<p>2、双链表的<u>双向搜索</u>：我们可以从头部或尾部进行搜索。</p>
<p>####在链表类中实现这些功能：</p>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<h4 id="方式一：单链表实现"><a href="#方式一：单链表实现" class="headerlink" title="方式一：单链表实现"></a>方式一：单链表实现</h4><p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113095508745.png" alt="image-20210113095508745"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;      <span class="comment">//声明结点</span></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    ListNode head;  <span class="comment">//sentinel node as pseudo-head</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   <span class="comment">//声明链表，用哨兵做伪头，这样确保链表中节点永远不为空</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  ListNode head;  <span class="comment">// sentinel node as pseudo-head</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// index steps needed </span></span><br><span class="line">    <span class="comment">// to move from sentinel node to wanted index</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;   <span class="comment">//与删除不同，如果要获取指定索引处的节点，必须前进index+1步</span></span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(size, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)  index = <span class="number">0</span>;</span><br><span class="line">		++size;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be added</span></span><br><span class="line">    ListNode pred = head;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;   <span class="comment">//从头开始找给定索引处的前一个元素pred，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// node to be added</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);    <span class="comment">//新建一个节点</span></span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    toAdd.next = pred.next;  </span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be deleted</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;  <span class="comment">//找到的是要删除节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    pred.next = pred.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/design-linked-list/solution/she-ji-lian-biao-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>#####复杂度分析</p>
<p>时间复杂度：<br>addAtHead： \mathcal{O}(1)O(1)<br>addAtInder，get，deleteAtIndex: \mathcal{O}(k)O(k)，其中 kk 指的是元素的索引。<br>addAtTail：\mathcal{O}(N)O(N)，其中 NN 指的是链表的元素个数。<br>空间复杂度：所有的操作都是 O(1)O(1)。</p>
<p>####方式二：双链表实现</p>
<p>双链表比单链表快得多，测试用例花费的时间比单链表快了两倍。但是它更加复杂，它包含了 <code>size</code>，记录链表元素个数，和伪头伪尾。</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113105525613.png" alt="image-20210113105525613"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;   <span class="comment">//后继结点</span></span><br><span class="line">  ListNode prev;   <span class="comment">//前驱节点</span></span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">// sentinel nodes as pseudo-head and pseudo-tail  --伪元素充当头结点和尾节点</span></span><br><span class="line">  ListNode head, tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// choose the fastest way: to move from the head</span></span><br><span class="line">    <span class="comment">// or to move from the tail    ----从后或者从前遍历，选择一个比较快速的遍历方向</span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">if</span> (index + <span class="number">1</span> &lt; size - index)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      curr = tail;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) curr = curr.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode pred = head, succ = head.next;</span><br><span class="line"></span><br><span class="line">    ++size;      <span class="comment">//记得把链表长度更新一下</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode succ = tail, pred = tail.prev;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be added   找到节点的前驱和后继</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) </span><br><span class="line">          pred = pred.next;</span><br><span class="line">      succ = pred.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//先找到待插入元素的前驱与后继，然后在进行节点指向的变更</span></span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    ++size;        <span class="comment">//注意长度的更新</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be deleted</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index - <span class="number">1</span>; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    --size;</span><br><span class="line">    pred.next = succ;</span><br><span class="line">    succ.prev = pred;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>伪头和伪尾总是存在，MyLinkedList 中所有节点都包含：值 + 指向前一个节点的指针 + 指向后一个节点的指针。</p>
<p>#####复杂度分析</p>
<p>时间复杂度：<br>addAtHead，addAtTail： \mathcal{O}(1)O(1)<br>get，addAtIndex，delete：\mathcal{O}(\min(k, N - k))O(min(k,N−k))，其中 kk 指的是元素的索引。<br>空间复杂度：所有的操作都是 \mathcal{O}(1)O(1)。</p>
<p> <strong>说明</strong>:不论是单链表还是双链表，在进行遍历时，如果想要通过index来get某一结点元素，for循环中的终止条件是<strong>i&lt;index+1</strong></p>
<p>如果是删除或者添加，for循环中的终止条件是**i&lt;index</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表刷题总结（easy篇）</title>
    <url>/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="链表知识刷题总结（easy篇）"><a href="#链表知识刷题总结（easy篇）" class="headerlink" title="链表知识刷题总结（easy篇）"></a>链表知识刷题总结（easy篇）</h1><p>###1.返回链表的倒数第k个结点</p>
<p>###题目描述：</p>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例：</p>
<p>输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2<br>输出： 4<br>说明：</p>
<p>给定的 k 保证是有效的。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="题解一-双指针"><a href="#题解一-双指针" class="headerlink" title="题解一:双指针"></a>题解一:双指针</h4><p> 这题要求链表的倒数第k个节点，最简单的方式就是使用两个指针，第一个指针先移动k步，然后第二个指针再从头开始，这个时候这两个指针同时移动，当第一个指针到链表的末尾的时候，返回第二个指针即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">    	ListNode second = head;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">while</span>(k-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first =  first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> second.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>####题解二：使用栈求解(一看到倒数某某元素，要先想到栈)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthTolast</span><span class="params">(ListNode head , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表结点压栈处理</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出栈串成新的链表</span></span><br><span class="line">        ListNode firstnode = stack.pop();</span><br><span class="line">        <span class="keyword">while</span>(--k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ListNode temp = stack.pop();</span><br><span class="line">            temp.next = firstNode;     <span class="comment">//这一步是不必要的，除非要求返回最后一个到倒数第k个结点链表，需要从新连接构建</span></span><br><span class="line">            firstNode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstnode.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-删除中间结点"><a href="#2-删除中间结点" class="headerlink" title="2.删除中间结点"></a>2.删除中间结点</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="3-合并两个有序列表"><a href="#3-合并两个有序列表" class="headerlink" title="3.合并两个有序列表"></a>3.合并两个有序列表</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例 1：</p>
<p><img data-src="/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210120112941925.png" alt="image-20210120112941925"></p>
<p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p>
<p>输入：l1 = [], l2 = []<br>输出：[]<br>示例 3：</p>
<p>输入：l1 = [], l2 = [0]<br>输出：[0]</p>
<h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><h5 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h5><p>思路</p>
<p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：<br>    <img data-src="/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210120113648210.png" alt="image-20210120113648210"></p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p>
<p>算法</p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p>
<p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><h3 id="4-回文链表"><a href="#4-回文链表" class="headerlink" title="4.回文链表"></a>4.回文链表</h3><p>####题目描述</p>
<h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>#####题解一：将链表中的值复制到数组中在用双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        List&lt;Interger&gt; vals = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表中的值赋值到数组中</span></span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            vals.add(currentNode.val);        <span class="comment">//复制的是currentNode的值，而不是其本身</span></span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用双指针判断回文</span></span><br><span class="line">        <span class="keyword">int</span> front=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back = vals.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;back)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vals.get(front).equals(vals.get(back)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front++;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><p><img data-src="/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210120205633023.png" alt="image-20210120205633023"></p>
<h5 id="题解二：递归"><a href="#题解二：递归" class="headerlink" title="题解二：递归"></a>题解二：递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云ECS部署服务器</title>
    <url>/2021/01/22/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="阿里云ECS部署Tomcat、Nginx服务器"><a href="#阿里云ECS部署Tomcat、Nginx服务器" class="headerlink" title="阿里云ECS部署Tomcat、Nginx服务器"></a>阿里云ECS部署Tomcat、Nginx服务器</h2><h3 id="Nginx服务器"><a href="#Nginx服务器" class="headerlink" title="Nginx服务器"></a>Nginx服务器</h3><p>####一、简介</p>
<p>Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。它最常的用途是提供反向代理服务。</p>
<h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><p>Nginx的安装依赖于以下三个包，意思就是在安装Nginx之前首先必须安装一下的三个包，注意安装顺序如下：</p>
<p>　　1 SSL功能需要openssl库，直接通过yum安装: #yum install openssl</p>
<p>　　2 gzip模块需要zlib库，直接通过yum安装: #yum install zlib</p>
<p>　　3 rewrite模块需要pcre库，直接通过yum安装: #yum install pcre</p>
<h2 id="2、安装Nginx依赖项和Nginx"><a href="#2、安装Nginx依赖项和Nginx" class="headerlink" title="2、安装Nginx依赖项和Nginx"></a>2、安装Nginx依赖项和Nginx</h2><p>1 、使用yum安装nginx需要包括Nginx的库，安装Nginx的库</p>
<p>rpm -Uvh <a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</a></p>
<p>2 、使用下面命令安装nginx</p>
<p> yum install nginx</p>
<p>3、 启动Nginx</p>
<p>service nginx start（Centos 6.0）,如果是Centos7.0以上，使用systemctl start nginx启动。</p>
<p>4、直接浏览器访问localhost就会出现Nginx的欢迎界面表示你安装成功了，否则就是安装失败了</p>
<p>　　默认80端口加入防火墙访问白名单中：firewall-cmd –permanent –zone=public –add-port=80/tcp</p>
<p>　　使用firewall-cmd –reload命令使其生效</p>
<p>5、配置Nginx</p>
<p>CentOS安装Nginx后，安装在了 /etc/nginx/目录下，你可以打开/etc/nginx/conf.d/default/conf查看里面的配置，包括监听端口，域名和nginx访问的根目录</p>
<p><strong>如果出现nginx启动之后，通过自己服务器的公网IP地址无法访问，是服务器端口没有开放访问权限的缘故，可以参考博客：<a href="https://blog.csdn.net/inite/article/details/73658214">https://blog.csdn.net/inite/article/details/73658214</a></strong></p>
<p>####三、配置</p>
<p>以上安装方法nginx的配置文件位于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<p>Nginx配置文件常见结构的从外到内依次是「http」「server」「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。</p>
<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p>接收请求的服务器需要将不同的请求按规则转发到不同的后端服务器上，在 nginx 中我们可以通过构建虚拟主机（server）的概念来将这些不同的服务配置隔离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们笔戈玩下的两个子项目 passport 和 wan 就可以通过在 nginx 的配置文件中配置两个 server，servername 分别为 passport.bigertech.com 和 wan.bigertech.com。这样的话不同的 url 请求就会对应到 nginx 相应的设置，转发到不同的后端服务器上。</p>
<p>这里的 listen 指监听端口，server_name 用来指定IP或域名，多个域名对应统一规则可以空格分开，index 用于设定访问的默认首页地址，root 指令用于指定虚拟主机的网页跟目录，这个地方可以是相对地址也可以是绝对地址。</p>
<p>通常情况下我们可以在 nginx.conf 中配置多个server，对不同的请求进行设置。就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  host1;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  host2;</span><br><span class="line">root   &#x2F;data&#x2F;www&#x2F;html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当 server 超过2个时，建议将不同对虚拟主机的配置放在另一个文件中，然后通过在主配置文件 nginx.conf 加上 include 指令包含进来。更便于管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include vhosts&#x2F;*.conf;</span><br></pre></td></tr></table></figure>
<p>就可以把vhosts的文件都包含进去啦。</p>
<p>#####Localtion</p>
<p>每个 url 请求都会对应的一个服务，nginx 进行处理转发或者是本地的一个文件路径，或者是其他服务器的一个服务路径。而这个路径的匹配是通过 location 来进行的。我们可以将 server 当做对应一个域名进行的配置，而 location 是在一个域名下对更精细的路径进行配置。</p>
<p>以上面的例子，可以将root和index指令放到一个location中，那么只有在匹配到这个location时才会访问root后的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;data&#x2F;www&#x2F;host2;</span><br><span class="line">      index  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">location 匹配规则</span><br><span class="line"></span><br><span class="line">~      波浪线表示执行一个正则匹配，区分大小写</span><br><span class="line">~*    表示执行一个正则匹配，不区分大小写</span><br><span class="line">^~    ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</span><br><span class="line">&#x3D;      进行普通字符精确匹配</span><br><span class="line">匹配例子：</span><br><span class="line"></span><br><span class="line">  location  &#x3D; &#x2F; &#123;</span><br><span class="line"># 只匹配&quot;&#x2F;&quot;.</span><br><span class="line">[ configuration A ] </span><br><span class="line">  &#125;</span><br><span class="line">location  &#x2F; &#123;</span><br><span class="line"># 匹配任何请求，因为所有请求都是以&quot;&#x2F;&quot;开始</span><br><span class="line"># 但是更长字符匹配或者正则表达式匹配会优先匹配</span><br><span class="line">[ configuration B ] </span><br><span class="line">&#125;</span><br><span class="line">location ^~ &#x2F;images&#x2F; &#123;</span><br><span class="line"> #匹配任何以 &#x2F;images&#x2F; 开始的请求，并停止匹配 其它location</span><br><span class="line">[ configuration C ] </span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line"># 匹配以 gif, jpg, or jpeg结尾的请求. </span><br><span class="line"># 但是所有 &#x2F;images&#x2F; 目录的请求将由 [Configuration C]处理.   </span><br><span class="line">[ configuration D ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">请求:</span><br><span class="line">&#x2F; -&gt; 符合configuration A</span><br><span class="line">&#x2F;documents&#x2F;document.html -&gt; 符合configuration B</span><br><span class="line">&#x2F;images&#x2F;1.gif -&gt; 符合configuration C</span><br><span class="line">&#x2F;documents&#x2F;1.jpg -&gt;符合 configuration D</span><br></pre></td></tr></table></figure>
<p>#####静态文件映射</p>
<p>访问文件的配置主要有 root 和 aliasp’s 两个指令。这两个指令的区别容易弄混：</p>
<p>alias<br>alias后跟的指定目录是准确的，并且末尾必须加 /。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;c&#x2F; &#123;</span><br><span class="line">    alias &#x2F;a&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果访问站点<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://location/c">http://location/c</a>访问的就是/a/目录下的站点信息。</p>
<p>#####root</p>
<p>root后跟的指定目录是上级目录，并且该上级目录下要含有和location后指定名称的同名目录才行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;c&#x2F; &#123;</span><br><span class="line">    root &#x2F;a&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时访问站点<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://location/c">http://location/c</a>访问的就是/a/c目录下的站点信息。</p>
<p>如果你需要将这个目录展开，在这个location的末尾加上「autoindex on; 」就可以了</p>
<p>#####转发</p>
<p>配置起来很简单比如我要将所有的请求到转移到真正提供服务的一台机器的 8001 端口，只要这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass 172.16.1.1:8001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样访问host时，就都被转发到 172.16.1.1的8001端口去了。</p>
<p>#####负载均衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver; &#123;</span><br><span class="line">ip_hash;    </span><br><span class="line">server 172.16.1.1:8001;</span><br><span class="line">server 172.16.1.2:8002;</span><br><span class="line">server 172.16.1.3;</span><br><span class="line">server 172.16.1.4;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;myserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 upstream 中指定了一组机器，并将这个组命名为 myserver，这样在 proxypass 中只要将请求转移到 myserver 这个 upstream 中我们就实现了在四台机器的反向代理加负载均衡。其中的 ip_hash 指明了我们均衡的方式是按照用户的 ip 地址进行分配。另外还有轮询、指定权重轮询、fair、url_hash几种调度算法。</p>
<p>###Tomcat服务器</p>
<h4 id="一、下载Tomcat"><a href="#一、下载Tomcat" class="headerlink" title="一、下载Tomcat"></a>一、下载Tomcat</h4>]]></content>
      <categories>
        <category>阿里云ECS</category>
      </categories>
      <tags>
        <tag>阿里云ECS部署</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/03/02/%E5%9F%BA%E4%BA%8EXML%E7%9A%84DI/JVM%E5%90%AC%E8%AF%BE%E7%AC%94%E8%AE%B0%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>java的指令是根据栈来设计的，不适用基于寄存器的，是因为基于寄存器与CPU耦合度太高，不太好实现跨平台运行</p>
<img data-src="https://tse1-mm.cn.bing.net/th/id/OIP.f3N7J7-cCRt2cBZM2z-XlQHaGV?w=223&h=191&c=7&o=5&dpr=1.5&pid=1.7" alt=" JVM内存结构 的图像结果" style="zoom: 200%;">]]></content>
  </entry>
  <entry>
    <title>Tomcat服务器</title>
    <url>/2021/02/25/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="CATALINA-HOME-与CATALINA-BASE的区别"><a href="#CATALINA-HOME-与CATALINA-BASE的区别" class="headerlink" title="CATALINA_HOME 与CATALINA_BASE的区别"></a>CATALINA_HOME 与CATALINA_BASE的区别</h2><p><strong>如何创建多个Tomcat服务器实例</strong></p>
<p>到底CATALINA_HOME和CATALINA_BASE有什么区别呢，之前因为都是小打小闹的在服务器上安装一个tomcat就得了，然后根据前人的配置，将CATALINA_HOME和CATALINA_BASE两个值设为了tomcat的目录（其实此处描述很不精确），今天无意间看到了公司的安装文档说明，里面提到了多个tomcat实例运行的配置，才弄明白到底这两者之间有什么区别。</p>
<p>我们可以从Tomcat 5.5的配置文档（<a href="http://tomcat.apache.org/tomcat-5.5-doc/config/host.html%EF%BC%89">http://tomcat.apache.org/tomcat-5.5-doc/config/host.html）</a> 中找到答案：</p>
<p>The description below uses the variable name $CATALINA_HOME to refer to the directory into which you have installed Tomcat 5, and is the base directory against which most relative paths are resolved. However, if you have configured Tomcat 5 for multiple instances by setting a CATALINA_BASE directory, you should use $CATALINA_BASE instead of $CATALINA_HOME for each of these references.</p>
<p>从这段描述可以看出CATALINA_HOME和CATALINA_BASE的区别。简单的说，CATALINA_HOME是Tomcat的安装目 录，CATALINA_BASE是Tomcat的工作目录。如果我们想要运行Tomcat的 多个实例，但是不想安装多个Tomcat软件副本。那么我们可以配置多个工作 目录，每个运行实例独占一个工作目录，但是共享同一个安装目录。</p>
<p>Tomcat每个运行实例需要使用自己的conf、logs、temp、webapps、work和shared目录，因此CATALINA_BASE就 指向这些目录。 而其他目录主要包括了Tomcat的二进制文件和脚本，CATALINA_HOME就指向这些目录。</p>
<p>如果我们希望再运行另一个Tomcat实例，那么我们可以建立一个目录，把conf、logs、temp、webapps、work和shared拷贝 到该目录下，然后让CATALINA_BASE指向该目录即可。</p>
<p>在一台服务器上，可以运行多个tomcat实例，不需要安装多个tomcat，可以采用不同的用户，以test用户为例，拷贝/usr/local/apache-tomcat-6.0.18目录到/home/test下，删除/home/test/apache-tomcat-6.0.18/bin子目录（此目录不需要），编辑/home/test/.bash_profile文件,设置CATALINA_HOME指向刚才的安装目录/usr/local/apache-tomcat-6.0.18,设置JAVA_HOME指向刚才的安装目录/usr/java/jdk1.6.0_11。设置CATALINA_BASE指向/home/test/apache-tomcat-6.0.18，设置CATALINA_OPTS跟/root/.bash_profile的一致（jmx管理端口用不同的端口号）</p>
<h2 id="bat和-sh文件的区别"><a href="#bat和-sh文件的区别" class="headerlink" title=".bat和.sh文件的区别"></a>.bat和.sh文件的区别</h2><p>bat文件是<a href="https://baike.baidu.com/item/dos/32025">dos</a>下的<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6/5363369">批处理文件</a>。批处理文件是无格式的<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/747597">文本文件</a>，它包含一条或多条<a href="https://baike.baidu.com/item/%E5%91%BD%E4%BB%A4/13020279">命令</a>。它的<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D/1270230">文件扩展名</a>为 .bat 或 .cmd。在命令提示下输入批处理文件的名称，或者双击该批处理文件，系统就会调用cmd.exe按照该文件中各个命令出现的顺序来逐个运行它们 [1] 。使用批处理文件（也被称为<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F/2192936">批处理程序</a>或<a href="https://baike.baidu.com/item/%E8%84%9A%E6%9C%AC/399">脚本</a>），可以简化日常或重复性任务。入侵者常常通过批处理文件的编写来实现多工具的组合入侵、自动入侵及结果提取等功能。</p>
<p>sh文件是UNIX/LINUX 操作系统的脚本文件，用记事本就可以打开。</p>
<h2 id="Tomcat安装对Java配置的要求"><a href="#Tomcat安装对Java配置的要求" class="headerlink" title="Tomcat安装对Java配置的要求"></a>Tomcat安装对Java配置的要求</h2><p>【问题】</p>
<p>Tomcat的启动到底需要JDK还是JRE呢？</p>
<p>【环境】</p>
<p>电脑上装有JDK和JRE，还有解压缩的Tomcat</p>
<p>【尝试】</p>
<p>1.当环境变量中没有JAVA_HOME和JRE_HOME，但是Path中有JDK的bin目录，也就是说cmd下java和javac命令都可以执行，</p>
<p>此时进入Tomcat的bin目录下执行startup.bat会提示无JRE_HOME或JAVA_HOME，见图：<br> <img data-src="/2021/02/25/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/01.png" class></p>
<p>2.给环境变量中添加JRE_HOME之后在执行startup.bat，Tomcat启动成功，见图：</p>
<p>JRE_HOME：<br> <img data-src="/2021/02/25/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/02.png" class><br>Tomcat启动：</p>
<img data-src="/2021/02/25/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/03.png" class>

<p>3.将JRE_HOME删除之后，添加JAVA_HOME，执行startup.bat，Tomcat启动成功，见图：</p>
<p>JAVA_HOME：<br> <img data-src="/2021/02/25/Tomcat%E6%9C%8D%E5%8A%A1%E5%99%A8/04.png" class></p>
<p>Tomcat启动：</p>


<p>【总结】</p>
<p>1.Tomcat启动需要环境变量中有JRE_HOME或者JAVA_HOME；</p>
<p>2.有JRE_HOME就可以启动说明Tomcat只需要JRE就可以运行；<br>3.Tomcat安装和启动：a.安装JRE并添加JRE_HOME，b.安装并解压缩Tomcat，c.运行startup.bat</p>
<h2 id="Tomcat下第一个webapp的部署"><a href="#Tomcat下第一个webapp的部署" class="headerlink" title="Tomcat下第一个webapp的部署"></a>Tomcat下第一个webapp的部署</h2><p>在描述如何组织源代码目录之前，检查Web应用程序的运行时组织非常有用。在Servlet API规范2.2版之前，服务器平台之间几乎没有一致性。但是，要求符合2.2（或更高版本）规范的服务器接受标准格式的 <em>Web应用程序存档</em>，</p>
<p>Web应用程序被定义为标准布局中目录和文件的层次结构。可以以“未打包”形式（其中每个目录和文件分别存在于文件系统中）或以称为Web ARchive或WAR文件的“打包”形式来访问这种层次结构。前一种格式在开发期间更有用，而后一种格式在分发要安装的应用程序时使用</p>
<p>Web应用程序层次结构的顶级目录也是应用程序的 <em>文档根</em>。在这里，您将放置构成应用程序用户界面的HTML文件和JSP页面。当系统管理员将您的应用程序部署到特定服务器上时，他或她会为您的应用程序分配<em>上下文路径</em>，因此，如果系统管理员将您的应用程序分配给上下文路径 <code>/catalog</code>，则引用的请求URI 将从您的文档根目录<code>/catalog/index.html</code>检索<code>index.html</code>文件。</p>
<h3 id="标准目录布局"><a href="#标准目录布局" class="headerlink" title="标准目录布局"></a>标准目录布局</h3><p>为了便于以所需格式创建Web应用程序存档文件，可以将Web应用程序的“可执行”文件（即Tomcat在执行应用程序时实际使用的文件）安排在与WAR格式本身。为此，您将在应用程序的“文档根目录”目录中获得以下内容：</p>
<ul>
<li><strong>.html。</strong> jsp<strong>等</strong>-HTML和JSP页面以及应用程序的客户端浏览器必须可见的其他文件（例如JavaScript，样式表文件和图像）。在较大的应用程序中，您可以选择将这些文件划分为子目录层次结构，但是对于较小的应用程序，通常只为这些文件维护一个目录要简单得多。</li>
</ul>
<ul>
<li>*<em>/WEB-INF/web.xml-**您的应用程序的</em>Web应用程序部署描述符*。这是一个XML文件，描述了组成应用程序的servlet和其他组件，以及您希望服务器为您强制执行的所有初始化参数和容器管理的安全性约束。 </li>
</ul>
<ul>
<li><strong>/ WEB-INF / classes /</strong> -此目录包含您的应用程序所需的所有Java类文件（和相关资源），包括未合并到JAR文件中的servlet和非servlet类。如果您的类被组织为Java包，则必须在目录层次结构下将其反映出来 <code>/WEB-INF/classes/</code>。例如，一个名为的Java类 <code>com.mycompany.mypackage.MyServlet</code> 将需要存储在一个名为的文件中 <code>/WEB-INF/classes/com/mycompany/mypackage/MyServlet.class</code>。</li>
</ul>
<ul>
<li><strong>/ WEB-INF / lib /</strong> -此目录包含JAR文件，这些文件包含您的应用程序所需的Java类文件（和相关资源），例如第三方类库或JDBC驱动程序。</li>
</ul>
<p>当您将应用程序安装到Tomcat（或任何其他2.2或更高版本的Servlet容器）中时，该<code>WEB-INF/classes/</code> 目录中的类以及该目录中找到的JAR文件中的所有类对于 <code>WEB-INF/lib/</code>您的特定Web应用程序中的其他类都是可见的。因此，如果在这些位置之一中包含所有必需的库类（请确保检查许可证以获取对您使用的任何第三方库的再发行权），则将简化Web应用程序的安装-无需对系统进行任何调整类路径（或在服务器中安装全局库文件）将是必需的。</p>
<h3 id="共享库文件"><a href="#共享库文件" class="headerlink" title="共享库文件"></a>共享库文件</h3><p>像大多数servlet容器一样，Tomcat还支持一种机制，可以一次安装库JAR文件（或解压缩的类），并使它们对所有已安装的Web应用程序可见（不必包含在Web应用程序本身中）。“<a href="https://tomcat.apache.org/tomcat-10.0-doc/class-loader-howto.html">类装入器方法”</a>文档中介绍了有关Tomcat如何查找和共享此类的详细信息 。在Tomcat安装中，共享代码通常使用的位置是 <strong>$ CATALINA_HOME / lib</strong>。放置在此处的JAR文件对于Web应用程序和内部Tomcat代码均可见。这是放置应用程序或内部Tomcat使用（例如DataSourceRealm）所需的JDBC驱动程序的好地方。</p>
<h3 id="web应用程序部署描述符"><a href="#web应用程序部署描述符" class="headerlink" title="web应用程序部署描述符"></a>web应用程序部署描述符</h3><p>该<code>/WEB-INF/web.xml</code>文件包含您的应用程序的Web应用程序部署描述符。就像文件名扩展名所暗示的那样，此文件是XML文档，定义了服务器需要了解的与应用程序有关的所有内容（<em>上下文路径</em>除外，该<em>上下文路径</em>是在部署应用程序时由系统管理员分配的），预计将提供开发工具来为您创建和编辑部署描述符。同时，为了提供一个起点，提供了一个<a href="https://tomcat.apache.org/tomcat-10.0-doc/appdev/web.xml.txt">基本的web.xml文件</a> 。该文件包含描述每个包含元素目的的注释。</p>
<p><strong>注释说明（DTD文档类型描述符）</strong></p>
<p> Servlet规范包括用于Web应用程序部署描述符的文档类型描述符（DTD），并且Tomcat在处理应用程序的<code>/WEB-INF/web.xml</code>文件时会强制执行此处定义的规则 。特别是，你<strong>必须</strong>由DTD定义的顺序输入你的描述符元素（如<code>&lt;filter&gt;</code>， <code>&lt;servlet&gt;</code>和<code>&lt;servlet-mapping&gt;</code>由DTD定义的顺序。</p>
<h2 id="具体的使用Tomcat进行部署"><a href="#具体的使用Tomcat进行部署" class="headerlink" title="具体的使用Tomcat进行部署"></a>具体的使用Tomcat进行部署</h2><p><em>下面的描述使用变量名$ CATALINA_BASE来引用可解决大多数**</em>相对路径*<em>的基本目录。如果尚未通过设置CATALINA_BASE目录为多个实例配置Tomcat，则$ CATALINA_BASE将设置为$ CATALINA_HOME的值，该目录已将Tomcat安装到该目录中。</em></p>
<h3 id="JAR和WAR包的区别"><a href="#JAR和WAR包的区别" class="headerlink" title="JAR和WAR包的区别"></a>JAR和WAR包的区别</h3><p>war是一个web模块，其中需要包括WEB-INF，是可以直接运行的WEB模块。而jar一般只是包括一些class文件，在声明了Main_class之后是可以用java命令运行的.<br>它们都是压缩的包,拿Tomcat来说,将war文件包放置它的\webapps\目录下，启动Tomcat,这个包可以自动进行解压，也就是你的web目录，相当于发布了。</p>
<p>war包:是做好一个web应用后，通常是网站，打成包部署到容器中。<br>jar包：通常是开发时要引用通用类，打成包便于存放管理。<br>ear包：企业级应用，通常是EJB打成ear包。</p>
<p>所有的包都是用jar打的，只不过目标文件的扩展名不一样。<br>WAR是Sun提出的一种Web应用程序格式，与JAR类似，也是许多文件的一个压缩包。这个包中的文件按一定目录结构来组织：通常其根目录下包含有Html和Jsp文件或者包含这两种文件的目录，另外还会有一个WEB-INF目录，这个目录很重要。通常在WEB-INF目录下有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的Servlet类和Jsp或Servlet所依赖的其它类（如JavaBean）。通常这些所依赖的类也可以打包成JAR放到WEB-INF下的lib目录下，当然也可以放到系统的CLASSPATH中，但那样移植和管理起来不方便。</p>
<h3 id="Tomcat-Web应用程序部署"><a href="#Tomcat-Web应用程序部署" class="headerlink" title="Tomcat Web应用程序部署"></a>Tomcat Web应用程序部署</h3><p>部署是用于将Web应用程序（第三方WAR或您自己的自定义Web应用程序）安装到Tomcat服务器的过程的术语。</p>
<p>Web应用程序部署可以在Tomcat服务器中以多种方式完成。</p>
<ul>
<li>静态地 在启动Tomcat之前先设置Web应用程序</li>
<li>动态地 通过直接操作已经部署的Web应用程序（依靠<em>自动部署</em> 功能）或通过使用Tomcat Manager Web应用程序远程</li>
</ul>
<p>在<a href="https://tomcat.apache.org/tomcat-10.0-doc/manager-howto.html">Tomcat管理器</a>是一个可以交互使用（通过HTML GUI）或以编程方式（通过基于URL的API）来部署和管理Web应用程序的Web应用程序。</p>
<p>有多种方法可以执行依赖于Manager Web应用程序的部署。Apache Tomcat提供了用于Apache Ant构建工具的任务。 <a href="https://tomcat.apache.org/maven-plugin.html">Apache Tomcat Maven插件</a> 项目提供了与Apache Maven的集成。还有一个名为Client Deployer的工具，可以从命令行使用它，并提供其他功能，例如编译和验证Web应用程序以及将Web应用程序打包到Web应用程序资源（WAR）文件中。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>静态部署Web应用程序不需要安装，因为Tomcat是开箱即用的。尽管需要某些配置（如<a href="https://tomcat.apache.org/tomcat-10.0-doc/manager-howto.html">Tomcat Manager手册</a>中所述），但使用Tomcat Manager进行部署功能也不需要进行任何安装 。但是，如果您想使用Tomcat Client Deployer（TCD），则需要进行安装。</p>
<p>TCD没有与Tomcat核心发行版一起打包，因此必须从“下载”区域单独下载。该下载通常标有 <em>apache-tomcat-10.0.x-deployer</em>。</p>
<h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>在谈论Web应用程序的部署时，需要理解<em>上下文</em>的概念 。上下文是Tomcat所谓的Web应用程序。</p>
<p>为了在Tomcat中配置上下文， 需要<em>上下文描述符</em>。上下文描述符只是一个XML文件，其中包含与Tomcat相关的Context配置，例如命名资源或会话管理器配置。在早期版本的Tomcat中，上下文描述符配置的内容通常存储在Tomcat的主要配置文件<em>server.xml中，</em>但是现在不建议这样做（尽管目前仍然可以使用）。</p>
<p>上下文描述符不仅帮助Tomcat知道如何配置上下文，而且其他工具（例如Tomcat Manager和TCD）经常使用这些上下文描述符来正确执行其角色。</p>
<p>上下文描述符的位置为：</p>
<ol>
<li>$ CATALINA_BASE / conf / [引擎名称] / [主机名] / [webappname] .xml</li>
<li>$ CATALINA_BASE / webapps / [webappname] /META-INF/context.xml</li>
</ol>
<p>（1）中的文件名为[webappname] .xml，但（2）中的文件命名为context.xml。如果未为上下文提供上下文描述符，则Tomcat使用默认值配置上下文。</p>
<h3 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h3><h4 id="静态部署：在Tomcat启动时进行部署"><a href="#静态部署：在Tomcat启动时进行部署" class="headerlink" title="静态部署：在Tomcat启动时进行部署"></a>静态部署：在Tomcat启动时进行部署</h4><p>如果您对使用Tomcat Manager或TCD不感兴趣，则需要将Web应用程序静态部署到Tomcat，然后再启动Tomcat。您将Web应用程序部署到此类型的部署的位置称为“ <code>appBase</code>每个主机指定的位置”。您可以将所谓的<em>爆炸式Web应用程序</em>（即未压缩的<em>Web应用程序）</em>复制到此位置，也可以将压缩的Web应用程序资源.WAR文件复制到该位置。</p>
<p><code>appBase</code>仅在主机<code>deployOnStartup</code>属性为“ true”时，才会在Tomcat启动时部署 由主机（默认主机为“ localhost”）属性（默认appBase为“ $ CATALINA_BASE / webapps”）指定的位置中存在的Web应用程序。</p>
<p>在这种情况下，将在Tomcat启动时执行以下部署顺序：</p>
<ol>
<li>任何上下文描述符都将首先部署。</li>
<li>然后将部署未由任何上下文描述符引用的爆炸性Web应用程序。如果他们在appBase中具有关联的.WAR文件，并且该文件比分解的Web应用程序新，则分解的目录将被删除，并且将从.WAR重新部署该Webapp。</li>
<li>.WAR文件将被部署</li>
</ol>
<h4 id="动态部署：对正在运行的Tomcat服务器上进行部署"><a href="#动态部署：对正在运行的Tomcat服务器上进行部署" class="headerlink" title="动态部署：对正在运行的Tomcat服务器上进行部署"></a>动态部署：对正在运行的Tomcat服务器上进行部署</h4><p>可以将Web应用程序部署到正在运行的Tomcat服务器。</p>
<p>如果Host<code>autoDeploy</code>属性为“ true”，则Host将尝试根据需要动态地部署和更新Web应用程序，例如，如果将新的.WAR放到了.WAR中<code>appBase</code>。为此，主机需要启用后台处理，这是默认配置。</p>
<p><code>autoDeploy</code> 设置为“ true”，并且正在运行的Tomcat允许：</p>
<ul>
<li>部署.WAR文件复制到主机中<code>appBase</code>。</li>
<li>部署爆炸性Web应用程序，并将其复制到Host中<code>appBase</code>。</li>
<li>当提供新的.WAR时，重新部署已经从.WAR部署的Web应用程序。在这种情况下，将删除爆炸的Web应用程序，然后再次扩展.WAR。请注意，如果配置了主机，则不会以<code>unpackWARs</code> 设置为“ false”的属性爆炸.WAR ，在这种情况下，Web应用程序将简单地重新部署为压缩归档文件，则不会发生爆炸。</li>
<li>如果/WEB-INF/web.xml文件（或定义为WatchedResource的任何其他资源）已更新，则重新加载Web应用程序。</li>
<li>如果更新了从中部署Web应用程序的上下文描述符文件，则重新部署Web应用程序。</li>
<li>如果更新了Web应用程序使用的全局或每个主机的上下文描述符文件，则重新部署从属Web应用程序。</li>
<li>如果将上下文描述符文件（文件名与先前部署的Web应用程序的Context路径相对应）添加到该<code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code> 目录中，则重新部署该Web应用程序 。</li>
<li>如果删除了Web应用程序的文档库（docBase），则将其取消部署。请注意，在Windows上，这假定启用了防锁定功能（请参阅上下文配置），否则无法删除正在运行的Web应用程序的资源。</li>
</ul>
<p>请注意，也可以在加载程序中配置Web应用程序的重新加载，在这种情况下，将跟踪已加载的类以进行更改。</p>
<h4 id="Tomcat-Manager-使用Tomcat管理器进行部署"><a href="#Tomcat-Manager-使用Tomcat管理器进行部署" class="headerlink" title="Tomcat Manager: 使用Tomcat管理器进行部署"></a>Tomcat Manager: 使用Tomcat管理器进行部署</h4><h4 id="TCD-使用客户端部署程序包进行部署"><a href="#TCD-使用客户端部署程序包进行部署" class="headerlink" title="TCD: 使用客户端部署程序包进行部署"></a>TCD: 使用客户端部署程序包进行部署</h4><p>可以使用Tomcat Client Deployer来实现Web应用程序的部署。这是一个软件包，可用于验证，编译，压缩为.WAR并将Web应用程序部署到生产或开发Tomcat服务器。应当注意，此功能使用Tomcat管理器，因此目标Tomcat服务器应正在运行。</p>
<p>假定用户将熟悉使用Apache TCD的Apache Ant。Apache Ant是一个脚本化的构建工具。TCD预先打包了一个构建脚本以供使用。只需要对Apache Ant有一定的了解（如本页面前面列出的安装，并且熟悉使用操作系统命令外壳程序和配置环境变量）。</p>
<p>TCD包括Ant任务，在部署之前用于JSP编译的Jasper页面编译器，以及验证Web应用程序上下文描述符的任务。验证程序任务（类 <code>org.apache.catalina.ant.ValidatorTask</code>）仅允许一个参数：展开的Web应用程序的基本路径。</p>
<p>TCD使用爆炸的Web应用程序作为输入（请参阅下面使用的属性列表）。通过部署程序以编程方式部署的Web应用程序可能在中包含Context Descriptor <code>/META-INF/context.xml</code>。</p>
<p>TCD包含一个现成的Ant脚本，其目标如下：</p>
<ul>
<li><code>compile</code>（默认）：编译和验证Web应用程序。这可以独立使用，不需要运行中的Tomcat服务器。编译后的应用程序将仅在关联的 <em>Tomcat XYZ</em>服务器版本上运行，并且不能保证可以在另一个Tomcat版本上运行，因为Jasper生成的代码取决于其运行时组件。还应注意，此目标还将自动编译位于<code>/WEB-INF/classes</code>Web应用程序文件夹中的任何Java源文件 。</li>
<li><code>deploy</code>：将Web应用程序（已编译或未编译）部署到Tomcat服务器。</li>
<li><code>undeploy</code>：取消部署Web应用程序</li>
<li><code>start</code>：启动Web应用程序</li>
<li><code>reload</code>：重新加载Web应用程序</li>
<li><code>stop</code>：停止Web应用程序</li>
</ul>
<p>为了配置部署，请<code>deployer.properties</code>在TCD安装目录根目录中创建一个名为的文件。在此文件中，每行添加以下“名称=值”对：</p>
<p>此外，您将需要确保已为目标Tomcat Manager（TCD使用的目标用户）设置了用户，否则TCD将不会通过Tomcat Manager进行身份验证，并且部署将失败。为此，请参见“ Tomcat管理器”页面。</p>
<ul>
<li><code>build</code>：默认情况下，使用的构建文件夹为 <code>$&#123;build&#125;/webapp/$&#123;path&#125;</code>（<code>$&#123;build&#125;</code>，默认情况下，指向<code>$&#123;basedir&#125;/build</code>）。<code>compile</code>目标执行结束后，Web应用程序.WAR将位于 <code>$&#123;build&#125;/webapp/$&#123;path&#125;.war</code>。</li>
<li><code>webapp</code>：包含展开的Web应用程序的目录，将对其进行编译和验证。默认情况下，该文件夹为 <code>myapp</code>。</li>
<li><code>path</code>：默认情况下，Web应用程序的已部署上下文路径<code>/myapp</code>。</li>
<li><code>url</code>：指向正在运行的Tomcat服务器的Tomcat Manager Web应用程序的绝对URL，它将用于部署和取消部署Web应用程序。默认情况下，部署者将尝试访问在localhost上运行的Tomcat实例 <code>http://localhost:8080/manager/text</code>。</li>
<li><code>username</code>：Tomcat Manager用户名（用户应具有manager-script角色）</li>
<li><code>password</code>：Tomcat管理器密码。</li>
</ul>
]]></content>
      <categories>
        <category>Java web</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>设计消息队列--&gt;1</title>
    <url>/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>明确了消息队列的使用场景，下一步就是如何设计与实现一个消息队列了。</p>
 <img data-src="/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.png" class>

<p>基于消息的系统模型，不一定需要broker(消息队列服务端)。市面上的的Akka（actor模型）、ZeroMQ等，其实都是基于消息的系统设计范式，但是没有broker。 我们之所以要设计一个消息队列，并且配备broker，无外乎要做两件事情：</p>
<blockquote>
<p>消息的转储，在更合适的时间点投递，或者通过一系列手段辅助消息最终能送达消费机。</p>
</blockquote>
<blockquote>
<p>规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求。 掰开了揉碎了看，最简单的消息队列可以做成一个消息转发器，把一次RPC做成两次RPC。发送者把消息投递到服务端（以下简称broker），服务端再将消息转发一手到接收端，就是这么简单。</p>
</blockquote>
<p>一般来讲，设计消息队列的整体思路是先build一个整体的数据流,例如producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等。 利用RPC将数据流串起来。然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。 之后考虑如何承载消息堆积，然后在合适的时机投递消息，而处理堆积的最佳方式，就是存储，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素。 为了实现广播功能，我们必须要维护消费关系，可以利用zk/config server等保存消费关系。 在完成了上述几个功能后，消息队列基本就实现了。然后我们可以考虑一些高级特性，如可靠投递，事务特性，性能优化等。 下面我们会以设计消息队列时重点考虑的模块为主线，穿插灌输一些消息队列的特性实现方法，来具体分析设计实现一个消息队列时的方方面面。</p>
<img data-src="/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/02.png" class>

<h2 id="实现队列基本功能"><a href="#实现队列基本功能" class="headerlink" title="实现队列基本功能"></a>实现队列基本功能</h2><h3 id="RPC通信协议"><a href="#RPC通信协议" class="headerlink" title="RPC通信协议"></a>RPC通信协议</h3><p>所谓消息队列，无外乎两次RPC加一次转储，当然需要消费端最终做消费确认的情况是三次RPC。既然是RPC，就必然牵扯出一系列话题，什么负载均衡啊、服务发现啊、通信协议啊、序列化协议啊，等等。在这一块，我的强烈建议是不要重复造轮子。利用公司现有的RPC框架：Thrift也好，Dubbo也好，或者是其他自定义的框架也好。因为消息队列的RPC，和普通的RPC没有本质区别。当然了，自主利用Memchached或者Redis协议重新写一套RPC框架并非不可（如MetaQ使用了自己封装的Gecko NIO框架，卡夫卡也用了类似的协议）。但实现成本和难度无疑倍增。排除对效率的极端要求，都可以使用现成的RPC框架。 简单来讲，服务端提供两个RPC服务，一个用来接收消息，一个用来确认消息收到。并且做到不管哪个server收到消息和确认消息，结果一致即可。当然这中间可能还涉及跨IDC的服务的问题。这里和RPC的原则是一致的，尽量优先选择本机房投递。你可能会问，如果producer和consumer本身就在两个机房了，怎么办？首先，broker必须保证感知的到所有consumer的存在。其次，producer尽量选择就近的机房就好了。</p>
<img data-src="/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/03.png" class>

<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p> 其实所有的高可用，是依赖于RPC和存储的高可用来做的。先来看RPC的高可用，美团的基于MTThrift的RPC框架，阿里的Dubbo等，其本身就具有服务自动发现，负载均衡等功能。而消息队列的高可用，只要保证broker接受消息和确认消息的接口是幂等的，并且consumer的几台机器处理消息是幂等的，这样就把消息队列的可用性，转交给RPC框架来处理了。 那么怎么保证幂等呢？最简单的方式莫过于共享存储。broker多机器共享一个DB或者一个分布式文件/kv系统，则处理消息自然是幂等的。就算有单点故障，其他节点可以立刻顶上。另外failover可以依赖定时任务的补偿，这是消息队列本身天然就可以支持的功能。存储系统本身的可用性我们不需要操太多心，放心大胆的交给DBA们吧！ 对于不共享存储的队列，如Kafka使用分区加主备模式，就略微麻烦一些。需要保证每一个分区内的高可用性，也就是每一个分区至少要有一个主备且需要做数据的同步，关于这块HA的细节，可以参考下篇pull模型消息系统设计。</p>
<h3 id="服务端承载消息堆积的能力"><a href="#服务端承载消息堆积的能力" class="headerlink" title="服务端承载消息堆积的能力"></a>服务端承载消息堆积的能力</h3><p>消息到达服务端如果不经过任何处理就到接收者了，broker就失去了它的意义。为了满足我们错峰/流控/最终可达等一系列需求，把消息存储下来，然后选择时机投递就显得是顺理成章的了。 只是这个存储可以做成很多方式。比如存储在内存里，存储在分布式KV里，存储在磁盘里，存储在数据库里等等。但归结起来，主要有持久化和非持久化两种。 持久化的形式能更大程度地保证消息的可靠性（如断电等不可抗外力），并且理论上能承载更大限度的消息堆积（外存的空间远大于内存）。 但并不是每种消息都需要持久化存储。很多消息对于投递性能的要求大于可靠性的要求，且数量极大（如日志）。这时候，消息不落地直接暂存内存，尝试几次failover，最终投递出去也未尝不可。 市面上的消息队列普遍两种形式都支持。当然具体的场景还要具体结合公司的业务来看。</p>
<h3 id="存储子系统的选择"><a href="#存储子系统的选择" class="headerlink" title="存储子系统的选择"></a>存储子系统的选择</h3><p>我们来看看如果需要数据落地的情况下各种存储子系统的选择。理论上，从速度来看，文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库，而可靠性却截然相反。还是要从支持的业务场景出发作出最合理的选择，如果你们的消息队列是用来支持支付/交易等对可靠性要求非常高，但对性能和量的要求没有这么高，而且没有时间精力专门做文件存储系统的研究，DB是最好的选择。 但是DB受制于IOPS，如果要求单broker 5位数以上的QPS性能，基于文件的存储是比较好的解决方案。整体上可以采用数据文件+索引文件的方式处理，具体这块的设计比较复杂，可以参考下篇的存储子系统设计。 分布式KV（如MongoDB，HBase）等，或者持久化的Redis，由于其编程接口较友好，性能也比较可观，如果在可靠性要求不是那么高的场景，也不失为一个不错的选择。</p>
<h3 id="消费关系解析"><a href="#消费关系解析" class="headerlink" title="消费关系解析"></a>消费关系解析</h3><p>现在我们的消息队列初步具备了转储消息的能力。下面一个重要的事情就是解析发送接收关系，进行正确的消息投递了。 市面上的消息队列定义了一堆让人晕头转向的名词，如JMS 规范中的Topic/Queue，Kafka里面的Topic/Partition/ConsumerGroup，RabbitMQ里面的Exchange等等。抛开现象看本质，无外乎是单播与广播的区别。所谓单播，就是点到点；而广播，是一点对多点。当然，对于互联网的大部分应用来说，组间广播、组内单播是最常见的情形。 消息需要通知到多个业务集群，而一个业务集群内有很多台机器，只要一台机器消费这个消息就可以了。 当然这不是绝对的，很多时候组内的广播也是有适用场景的，如本地缓存的更新等等。另外，消费关系除了组内组间，可能会有多级树状关系。这种情况太过于复杂，一般不列入考虑范围。所以，一般比较通用的设计是支持组间广播，不同的组注册不同的订阅。组内的不同机器，如果注册一个相同的ID，则单播；如果注册不同的ID(如IP地址+端口)，则广播。 至于广播关系的维护，一般由于消息队列本身都是集群，所以都维护在公共存储上，如config server、zookeeper等。维护广播关系所要做的事情基本是一致的:</p>
<ol>
<li>发送关系的维护。</li>
<li>发送关系变更时的通知。</li>
</ol>
<h2 id="队列高级特性设计"><a href="#队列高级特性设计" class="headerlink" title="队列高级特性设计"></a>队列高级特性设计</h2><p>上面都是些消息队列基本功能的实现，下面来看一些关于消息队列特性相关的内容，不管可靠投递/消息丢失与重复以及事务乃至于性能，不是每个消息队列都会照顾到，所以要依照业务的需求，来仔细衡量各种特性实现的成本，利弊，最终做出最为合理的设计。</p>
<h3 id="可靠投递（最终一致性）"><a href="#可靠投递（最终一致性）" class="headerlink" title="可靠投递（最终一致性）"></a>可靠投递（最终一致性）</h3><p>完全不丢消息，究竟可不可能？答案是，完全可能，前提是消息可能会重复，并且，在异常情况下，要接受消息的延迟。 方案说简单也简单，就是每当要发生不可靠的事情（RPC等）之前，先将消息落地，然后发送。当失败或者不知道成功失败（比如超时）时，消息状态是待发送，定时任务不停轮询所有待发送消息，最终一定可以送达。 具体来说：</p>
<blockquote>
<p>producer往broker发送消息之前，需要做一次落地。</p>
</blockquote>
<blockquote>
<p>请求到server后，server确保数据落地后再告诉客户端发送成功。</p>
</blockquote>
<blockquote>
<p>支持广播的消息队列需要对每个待发送的endpoint，持久化一个发送状态，直到所有endpoint状态都OK才可删除消息。</p>
</blockquote>
<p>对于各种不确定（超时、down机、消息没有送达、送达后数据没落地、数据落地了回复没收到），其实对于发送方来说，都是一件事情，就是消息没有送达。 重推消息所面临的问题就是消息重复。重复和丢失就像两个噩梦，你必须要面对一个。好在消息重复还有处理的机会，消息丢失再想找回就难了。 Anyway，作为一个成熟的消息队列，应该尽量在各个环节减少重复投递的可能性，不能因为重复有解决方案就放纵的乱投递。 最后说一句，不是所有的系统都要求最终一致性或者可靠投递，比如一个论坛系统、一个招聘系统。一个重复的简历或话题被发布，可能比丢失了一个发布显得更让用户无法接受。不断重复一句话，任何基础组件要服务于业务场景。</p>
<h3 id="消费确认"><a href="#消费确认" class="headerlink" title="消费确认"></a>消费确认</h3><p>当broker把消息投递给消费者后，消费者可以立即响应我收到了这个消息。但收到了这个消息只是第一步，我能不能处理这个消息却不一定。或许因为消费能力的问题，系统的负荷已经不能处理这个消息；或者是刚才状态机里面提到的消息不是我想要接收的消息，主动要求重发。 把消息的送达和消息的处理分开，这样才真正的实现了消息队列的本质-解耦。所以，允许消费者主动进行消费确认是必要的。当然，对于没有特殊逻辑的消息，默认Auto Ack也是可以的，但一定要允许消费方主动ack。 对于正确消费ack的，没什么特殊的。但是对于reject和error，需要特别说明。reject这件事情，往往业务方是无法感知到的，系统的流量和健康状况的评估，以及处理能力的评估是一件非常复杂的事情。举个极端的例子，收到一个消息开始build索引，可能这个消息要处理半个小时，但消息量却是非常的小。所以reject这块建议做成滑动窗口/线程池类似的模型来控制， 消费能力不匹配的时候，直接拒绝，过一段时间重发，减少业务的负担。 但业务出错这件事情是只有业务方自己知道的，就像上文提到的状态机等等。这时应该允许业务方主动ack error，并可以与broker约定下次投递的时间。</p>
<h3 id="重复消息和顺序消息"><a href="#重复消息和顺序消息" class="headerlink" title="重复消息和顺序消息"></a>重复消息和顺序消息</h3><p>上文谈到重复消息是不可能100%避免的，除非可以允许丢失，那么，顺序消息能否100%满足呢? 答案是可以，但条件更为苛刻：</p>
<ol>
<li>允许消息丢失。</li>
<li>从发送方到服务方到接受者都是单点单线程。</li>
</ol>
<p>所以绝对的顺序消息基本上是不能实现的，当然在METAQ/Kafka等pull模型的消息队列中，单线程生产/消费，排除消息丢失，也是一种顺序消息的解决方案。 一般来讲，一个主流消息队列的设计范式里，应该是不丢消息的前提下，尽量减少重复消息，不保证消息的投递顺序。 谈到重复消息，主要是两个话题：</p>
<ol>
<li>如何鉴别消息重复，并幂等的处理重复消息。</li>
<li>一个消息队列如何尽量减少重复消息的投递。</li>
</ol>
<p>先来看看第一个话题，每一个消息应该有它的唯一身份。不管是业务方自定义的，还是根据IP/PID/时间戳生成的MessageId，如果有地方记录这个MessageId，消息到来是能够进行比对就 能完成重复的鉴定。数据库的唯一键/bloom filter/分布式KV中的key，都是不错的选择。由于消息不能被永久存储，所以理论上都存在消息从持久化存储移除的瞬间上游还在投递的可能（上游因种种原因投递失败，不停重试，都到了下游清理消息的时间）。这种事情都是异常情况下才会发生的，毕竟是小众情况。两分钟消息都还没送达，多送一次又能怎样呢？幂等的处理消息是一门艺术，因为种种原因重复消息或者错乱的消息还是来到了，说两种通用的解决方案： 1. 版本号。 2. 状态机。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>举个简单的例子，一个产品的状态有上线/下线状态。如果消息1是下线，消息2是上线。不巧消息1判重失败，被投递了两次，且第二次发生在2之后，如果不做重复性判断，显然最终状态是错误的。 但是，如果每个消息自带一个版本号。上游发送的时候，标记消息1版本号是1，消息2版本号是2。如果再发送下线消息，则版本号标记为3。下游对于每次消息的处理，同时维护一个版本号。 每次只接受比当前版本号大的消息。初始版本为0，当消息1到达时，将版本号更新为1。消息2到来时，因为版本号&gt;1.可以接收，同时更新版本号为2.当另一条下线消息到来时，如果版本号是3.则是真实的下线消息。如果是1，则是重复投递的消息。 如果业务方只关心消息重复不重复，那么问题就已经解决了。但很多时候另一个头疼的问题来了，就是消息顺序如果和想象的顺序不一致。比如应该的顺序是12，到来的顺序是21。则最后会发生状态错误。 参考TCP/IP协议，如果想让乱序的消息最后能够正确的被组织，那么就应该只接收比当前版本号大一的消息。并且在一个session周期内要一直保存各个消息的版本号。 如果到来的顺序是21，则先把2存起来，待1到来后，先处理1，再处理2，这样重复性和顺序性要求就都达到了。</p>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>基于版本号来处理重复和顺序消息听起来是个不错的主意，但凡事总有瑕疵。使用版本号的最大问题是：</p>
<ol>
<li>对发送方必须要求消息带业务版本号。</li>
<li>下游必须存储消息的版本号，对于要严格保证顺序的。</li>
</ol>
<p>还不能只存储最新的版本号的消息，要把乱序到来的消息都存储起来。而且必须要对此做出处理。试想一个永不过期的”session”，比如一个物品的状态，会不停流转于上下线。那么中间环节的所有存储 就必须保留，直到在某个版本号之前的版本一个不丢的到来，成本太高。 就刚才的场景看，如果消息没有版本号，该怎么解决呢？业务方只需要自己维护一个状态机，定义各种状态的流转关系。例如，”下线”状态只允许接收”上线”消息，“上线”状态只能接收“下线消息”，如果上线收到上线消息，或者下线收到下线消息，在消息不丢失和上游业务正确的前提下。要么是消息发重了，要么是顺序到达反了。这时消费者只需要把“我不能处理这个消息”告诉投递者，要求投递者过一段时间重发即可。而且重发一定要有次数限制，比如5次，避免死循环，就解决了。 举例子说明，假设产品本身状态是下线，1是上线消息，2是下线消息，3是上线消息，正常情况下，消息应该的到来顺序是123，但实际情况下收到的消息状态变成了3123。 那么下游收到3消息的时候，判断状态机流转是下线-&gt;上线，可以接收消息。然后收到消息1，发现是上线-&gt;上线，拒绝接收，要求重发。然后收到消息2，状态是上线-&gt;下线，于是接收这个消息。 此时无论重发的消息1或者3到来，还是可以接收。另外的重发，在一定次数拒绝后停止重发，业务正确。</p>
<h3 id="中间件对于重复消息的处理"><a href="#中间件对于重复消息的处理" class="headerlink" title="中间件对于重复消息的处理"></a>中间件对于重复消息的处理</h3><p>回归到消息队列的话题来讲。上述通用的版本号/状态机/ID判重解决方案里，哪些是消息队列该做的、哪些是消息队列不该做业务方处理的呢？其实这里没有一个完全严格的定义，但回到我们的出发点，我们保证不丢失消息的情况下尽量少重复消息，消费顺序不保证。那么重复消息下和乱序消息下业务的正确，应该是由消费方保证的，我们要做的是减少消息发送的重复。 我们无法定义业务方的业务版本号/状态机，如果API里强制需要指定版本号，则显得过于绑架客户了。况且，在消费方维护这么多状态，就涉及到一个消费方的消息落地/多机间的同步消费状态问题，复杂度指数级上升，而且只能解决部分问题。 减少重复消息的关键步骤：</p>
<ol>
<li>broker记录MessageId，直到投递成功后清除，重复的ID到来不做处理，这样只要发送者在清除周期内能够感知到消息投递成功，就基本不会在server端产生重复消息。</li>
<li>对于server投递到consumer的消息，由于不确定对端是在处理过程中还是消息发送丢失的情况下，有必要记录下投递的IP地址。决定重发之前询问这个IP，消息处理成功了吗？如果询问无果，再重发。</li>
</ol>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
</search>
