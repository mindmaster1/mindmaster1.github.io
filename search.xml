<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DFS与BFS</title>
    <url>/2021/03/25/DFS%E4%B8%8EBFS/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>深度优先遍历（Depth  First Search, 简称 DFS） 与广度优先遍历（Breath First  Search）是图论中两种非常重要的算法，生产上广泛用于拓扑排序，寻路（走迷宫），搜索引擎，爬虫等，也频繁出现在  leetcode，高频面试题中。</p>
<p>本文将会从以下几个方面来讲述深度优先遍历，广度优先遍历，相信大家看了肯定会有收获。</p>
<ul>
<li>深度优先遍历，广度优先遍历简介</li>
<li>习题演练</li>
<li>DFS，BFS 在搜索引擎中的应用</li>
</ul>
<h2 id="深度优先遍历，广度优先遍历简介"><a href="#深度优先遍历，广度优先遍历简介" class="headerlink" title="深度优先遍历，广度优先遍历简介"></a>深度优先遍历，广度优先遍历简介</h2><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>深度优先遍历主要思路是从图中一个未访问的顶点 V 开始，沿着一条路一直走到底，然后从这条路尽头的节点回退到上一个节点，再从另一条路开始走到底…，不断递归重复此过程，直到所有的顶点都遍历完成，它的特点是<strong>不撞南墙不回头</strong>，先走完一条路，再换一条路继续走。</p>
<p>树是图的一种特例（连通无环的图就是树），接下来我们来看看树用深度优先遍历该怎么遍历。</p>
 <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/01.png" class>
<p>1、我们从根节点 1 开始遍历，它相邻的节点有 2，3，4，先遍历节点 2，再遍历 2 的子节点 5，然后再遍历 5 的子节点 9。</p>
  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/02.png" class>
<p>2、上图中一条路已经走到底了（9是叶子节点，再无可遍历的节点），此时就从 9 回退到上一个节点 5，看下节点 5 是否还有除 9 以外的节点，没有继续回退到 2，2 也没有除 5 以外的节点，回退到 1，1 有除 2 以外的节点 3，所以从节点 3 开始进行深度优先遍历，如下<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/03.png" class><br>3、同理从 10 开始往上回溯到 6, 6 没有除 10 以外的子节点，再往上回溯，发现 3 有除 6 以外的子点 7，所以此时会遍历 7<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/04.png" class><br>3、从 7 往上回溯到 3， 1，发现 1 还有节点 4 未遍历，所以此时沿着 4， 8 进行遍历,这样就遍历完成了</p>
<p>完整的节点的遍历顺序如下（节点上的的蓝色数字代表）<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/05.png" class><br>相信大家看到以上的遍历不难发现这就是树的前序遍历,实际上不管是前序遍历，还是中序遍历，亦或是后序遍历，都属于深度优先遍历。</p>
<p>那么深度优先遍历该怎么实现呢，有递归和非递归两种表现形式，接下来我们以二叉树为例来看下如何分别用递归和非递归来实现深度优先遍历。</p>
<p><strong>1、递归实现</strong><br>递归实现比较简单，由于是前序遍历，所以我们依次遍历当前节点，左节点，右节点即可，对于左右节点来说，依次遍历它们的左右节点即可，依此不断递归下去，直到叶节点（递归终止条件），代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    private static class Node &#123;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 节点值</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public int value;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 左节点</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public Node left;</span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 右节点</span><br><span class="line">         *&#x2F;</span><br><span class="line">        public Node right;</span><br><span class="line"></span><br><span class="line">        public Node(int value, Node left, Node right) &#123;</span><br><span class="line">            this.value &#x3D; value;</span><br><span class="line">            this.left &#x3D; left;</span><br><span class="line">            this.right &#x3D; right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void dfs(Node treeNode) &#123;</span><br><span class="line">        if (treeNode &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 遍历节点</span><br><span class="line">        process(treeNode)</span><br><span class="line">        &#x2F;&#x2F; 遍历左节点</span><br><span class="line">        dfs(treeNode.left);</span><br><span class="line">        &#x2F;&#x2F; 遍历右节点</span><br><span class="line">        dfs(treeNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归的表达性很好，也很容易理解，不过如果层级过深，很容易导致栈溢出。所以我们重点看下非递归实现</p>
<p><strong>2、非递归实现</strong></p>
<p>仔细观察深度优先遍历的特点，对二叉树来说，由于是先序遍历（先遍历当前节点，再遍历左节点，再遍历右节点），所以我们有如下思路</p>
<p>1、对于每个节点来说，先遍历当前节点，然后把右节点压栈，再压左节点（这样弹栈的时候会先拿到左节点遍历，符合深度优先遍历要求）<br>2、弹栈，拿到栈顶的节点，如果节点不为空，重复步骤 1， 如果为空，结束遍历。</p>
<p>我们以以下二叉树为例来看下如何用栈来实现 DFS。<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/06.png" class><br>整体动图如下<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/07.png" class></p>
<p>整体思路还是比较清晰的，使用栈来将要遍历的节点压栈，然后出栈后检查此节点是否还有未遍历的节点，有的话压栈，没有的话不断回溯（出栈），有了思路，不难写出如下用栈实现的二叉树的深度优先遍历代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用栈来实现 dfs</span><br><span class="line"> * @param root</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void dfsWithStack(Node root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; stack &#x3D; new Stack&lt;&gt;();</span><br><span class="line">    &#x2F;&#x2F; 先把根节点压栈</span><br><span class="line">    stack.push(root);</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        Node treeNode &#x3D; stack.pop();</span><br><span class="line">        &#x2F;&#x2F; 遍历节点</span><br><span class="line">        process(treeNode)</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 先压右节点</span><br><span class="line">        if (treeNode.right !&#x3D; null) &#123;</span><br><span class="line">            stack.push(treeNode.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 再压左节点</span><br><span class="line">        if (treeNode.left !&#x3D; null) &#123;</span><br><span class="line">            stack.push(treeNode.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到用栈实现深度优先遍历其实代码也不复杂，而且也不用担心递归那样层级过深导致的栈溢出问题。</p>
<h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>广度优先遍历，指的是从图的一个未遍历的节点出发，先遍历这个节点的相邻节点，再依次遍历每个相邻节点的相邻节点。</p>
<p>上文所述树的广度优先遍历动图如下，每个节点的值即为它们的遍历顺序。所以广度优先遍历也叫层序遍历，先遍历第一层（节点 1），再遍历第二层（节点 2，3，4），第三层（5，6，7，8），第四层（9，10）。<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/08.png" class><br>深度优先遍历用的是栈，而广度优先遍历要用队列来实现，我们以下图二叉树为例来看看如何用队列来实现广度优先遍历<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/10.png" class><br>动图如下</p>
  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/11.png" class>

<p>相信看了以上动图，不难写出如下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 使用队列实现 bfs</span><br><span class="line"> * @param root</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static void bfs(Node root) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; stack &#x3D; new LinkedList&lt;&gt;();</span><br><span class="line">    stack.add(root);</span><br><span class="line"></span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        Node node &#x3D; stack.poll();</span><br><span class="line">        System.out.println(&quot;value &#x3D; &quot; + node.value);</span><br><span class="line">        Node left &#x3D; node.left;</span><br><span class="line">        if (left !&#x3D; null) &#123;</span><br><span class="line">            stack.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">        Node right &#x3D; node.right;</span><br><span class="line">        if (right !&#x3D; null) &#123;</span><br><span class="line">            stack.add(right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DFS，BFS-在搜索引擎中的应用"><a href="#DFS，BFS-在搜索引擎中的应用" class="headerlink" title="DFS，BFS 在搜索引擎中的应用"></a>DFS，BFS 在搜索引擎中的应用</h2><p>我们几乎每天都在 Google, Baidu 这些搜索引擎，那大家知道这些搜索引擎是怎么工作的吗，简单来说有三步</p>
<p><strong>1、网页抓取</strong></p>
<p>搜索引擎通过爬虫将网页爬取，获得页面 HTML 代码存入数据库中</p>
<p><strong>2、预处理</strong></p>
<p>索引程序对抓取来的页面数据进行文字提取，中文分词，（倒排）索引等处理，以备排名程序使用</p>
<p><strong>3、排名</strong></p>
<p>用户输入关键词后，排名程序调用索引数据库数据，计算相关性，然后按一定格式生成搜索结果页面。</p>
<p>我们重点看下第一步，网页抓取。</p>
<p>这一步的大致操作如下：给爬虫分配一组起始的网页，我们知道网页里其实也包含了很多超链接，爬虫爬取一个网页后，解析提取出这个网页里的所有超链接，再依次爬取出这些超链接，再提取网页超链接。。。，如此不断重复就能不断根据超链接提取网页。如下图示<br>  <img data-src="/2021/03/25/DFS%E4%B8%8EBFS/12.png" class><br>如上所示，最终构成了一张图，于是问题就转化为了如何遍历这张图，显然可以用深度优先或广度优先的方式来遍历。</p>
<p>如果是广度优先遍历，先依次爬取第一层的起始网页，再依次爬取每个网页里的超链接，如果是深度优先遍历，先爬取起始网页 1，再爬取此网页里的链接…，爬取完之后，再爬取起始网页 2…</p>
<p>实际上爬虫是深度优先与广度优先两种策略一起用的，比如在起始网页里，有些网页比较重要（权重较高），那就先对这个网页做深度优先遍历，遍历完之后再对其他（权重一样的）起始网页做广度优先遍历。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Grapth</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP报文</title>
    <url>/2022/02/23/HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1> 

<p>HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的**<em>元信息**</em>（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着<strong>可选的数据部分</strong>。这些报文在客户端、服务器和代理之间流动。</p>




<h2 id="报文的组成部分"><a href="#报文的组成部分" class="headerlink" title="报文的组成部分"></a>报文的组成部分</h2><p>不论是请求还是响应，由三部分组成；</p>
<blockquote>
<p>起始行(start line)、包含属性的首部(header)块，可选的、包含数据的主体（body）</p>
</blockquote>


<p>起始行和首部就是由行分隔的ASCII文本。每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符（ASCII码13）和一个换行符（ASCII码10）。 这个行终止序列可以写做CRLF.需要指出的是，尽管HTTP规范中说明应该用 CRLF来表示行终止，但稳健的应用程序也应该接受单个换行符作为行的终止。有 些老的，或不完整的HTTP应用程序并不总是既发送回车符，又发送换行符。</p>
<h3 id="报文的语法"><a href="#报文的语法" class="headerlink" title="报文的语法"></a>报文的语法</h3><p>分为：【**<em>请求报文和响应报文**</em>】</p>


<p> <strong><em>浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式</em></strong></p>






<h3 id="HTTP的协议格式"><a href="#HTTP的协议格式" class="headerlink" title="HTTP的协议格式"></a>HTTP的协议格式</h3> 



<h4 id="ABNF-扩充巴科斯-瑙尔范式-操作符"><a href="#ABNF-扩充巴科斯-瑙尔范式-操作符" class="headerlink" title="ABNF(扩充巴科斯-瑙尔范式)操作符"></a>ABNF(扩充巴科斯-瑙尔范式)操作符</h4> 

<p><strong><em>ABNF的核心规则</em></strong></p>
 



<blockquote>
<p>基于ABNF描述的HTTP协议格式 + 具体实例</p>
</blockquote>
 







<h3 id="起始行-【Start-line】"><a href="#起始行-【Start-line】" class="headerlink" title="起始行 【Start-line】"></a>起始行 【Start-line】</h3><h4 id="请求行-【Request-line】"><a href="#请求行-【Request-line】" class="headerlink" title="请求行 【Request-line】"></a>请求行 【Request-line】</h4><p>请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为请求行，包含了一个<strong>方法</strong>和一个<strong>请求URL</strong>,这个方法描述了服务器应该执行的操作，请求URL 描述了要对哪个资源执行这个方法。请求行中还包含<strong>HTTP的版本</strong>，用来告知服务 器，客户端使用的是哪种HTTP。</p>
<h4 id="响应行-【Response-line】"><a href="#响应行-【Response-line】" class="headerlink" title="响应行 【Response-line】"></a>响应行 【Response-line】</h4><p>响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行，包含了响应报文使用的HTTP版本、数字状态码，以及描述操作状态的文本形式的原因短语。</p>
<p><strong><em>对起始行和响应行中的具体内容进行描述</em></strong></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
<th>是否包含主体</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>从服务器获取一份文档</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>HEAD</td>
<td>只从服务器获取文档的首部</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>POST</td>
<td>向服务器发送需要处理的数据</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>PUT</td>
<td>将请求的主体部分存储在服务器上</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>TRACE</td>
<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>OPTIONS</td>
<td>决定可以在服务器上执行哪些方法</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器上删除–份文档</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>HEAD</strong>: lHEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检査。</p>
<ul>
<li>在不获取资源的情况下了解资源的情况（比如，判断其类型）</li>
<li>通过査看响应中的状态码，看看某个对象是否存在</li>
<li>通过査看首部，测试资源是否被修改了。</li>
</ul>
</li>
<li><p><strong>PUT</strong>：PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名 的新文档，或者，如果那个URL已经存在的话，就用这个主体来替代它。</p>
<p>因为PUT允许用户对内容进行修改，所以很多Web服务器都要求在执行PUT之 前，用密码登录。</p>
 
</li>
<li><p><strong>POST</strong>:POST方法起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。</p>




</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。 状态码位于响应的起始行中。</p>
<table>
<thead>
<tr>
<th>整体范围</th>
<th>已定义范围</th>
<th>分 类</th>
</tr>
</thead>
<tbody><tr>
<td>100 ~ 199</td>
<td>100 ~ 101</td>
<td>信息提示</td>
</tr>
<tr>
<td>200 - 299</td>
<td>200 〜206</td>
<td>成功</td>
</tr>
<tr>
<td>300 ~ 399</td>
<td>300 ~ 305</td>
<td>重定向</td>
</tr>
<tr>
<td>400 ~ 499</td>
<td>400 ~ 415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>500 ~ 599</td>
<td>500 ~ 505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p>【**<em>原因短语**</em>】：原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者 将其传送给用户，用以说明在请求期间发生了什么情况。</p>
<h3 id="首部-【header-field】"><a href="#首部-【header-field】" class="headerlink" title="首部 【header-field】"></a>首部 【header-field】</h3>

<p>每个HTTP首部都有-种简单的语法：名字后面跟着冒号（：），然后跟上**<em>可选的空格**</em>，再跟上字段值，最后是一个CRLF。</p>
<table>
<thead>
<tr>
<th>首部实例</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>Date：Tue,30ct 1997 02:16:03 GMT</td>
<td>服务器产生响应的日期</td>
</tr>
<tr>
<td>Content-length：15040</td>
<td>实体的主体部分包含了 15 040字节的数据</td>
</tr>
<tr>
<td>Content-type:image/gif</td>
<td>实体的主体部分是一个GIF图片</td>
</tr>
</tbody></table>
<p> 首部延续行：</p>
<p>将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或制表符（tab）。</p>
 



<h3 id="Messege-body"><a href="#Messege-body" class="headerlink" title="Messege-body"></a>Messege-body</h3><p>HTTP报文的第三部分是可选的实体主体部分。实体的主体是HTTP报文的负荷。 就是HTTP要传输的内容。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP连接</title>
    <url>/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="HTTP连接"><a href="#HTTP连接" class="headerlink" title="HTTP连接"></a>HTTP连接</h1><p>HTTP连接实际上就是TCP连接和一些使用连接的规则。</p>
<p>TCP为HTTP提供了一条可靠的比特传输管道。从TCP连接一端填入的字节会从另 一端以原有的顺序、正确地传送出来</p>
<p><img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224094620498.png" alt="image-20220224094620498"></p>
<p>安全版本**<em>HTTPS**</em>就是在HTTP和TCP之间插入了一个〈称为TLS或SSL 的）密码加密层。</p>
<p><img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224094734829.png" alt="image-20220224094734829"></p>
<p>HTTP要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的TCP连 接按序传输。TCP收到数据流之后，会将数据流砍成被称作段的小数据块，并将段 封装在IP分组中，通过因特网进行传输。</p>
<p><strong><em>每个TCP段都是由IP分组承载</em></strong>，从一个IP地址发送到另一个IP地址的。每个IP 分组中都包括：</p>
<ul>
<li><p> 一个IP分组首部（通常为20字节）</p>
</li>
<li><p> 一个TCP段首部（通常为20字节）</p>
</li>
<li><p>一个TCP数据块（0个或多个字节）。</p>
</li>
</ul>
<img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224095120890.png" alt="image-20220224095120890" style="zoom:50%;">

<p><strong>承载TCP段的IP分组，承载了TCP数据流中的小块数据</strong></p>
<p>TCP连接通过4个值来识别：【**<em>唯一标识连接**</em>】</p>
<p><img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224095247616.png" alt="image-20220224095247616"></p>
<h2 id="HTTP连接的管理"><a href="#HTTP连接的管理" class="headerlink" title="HTTP连接的管理"></a>HTTP连接的管理</h2><h3 id="Connection首部"><a href="#Connection首部" class="headerlink" title="Connection首部"></a>Connection首部</h3><p><strong><em>防止无意中对本地首部的转发，“对首部的保护”</em></strong></p>
<p><img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224103350199.png" alt="image-20220224103350199"></p>
<h3 id="串行事务处理时延"><a href="#串行事务处理时延" class="headerlink" title="串行事务处理时延"></a>串行事务处理时延</h3><p>如果只对连接进行简单的管理，TCP的性能时延可能会叠加起来。</p>
<p>假设有一个包含了 3个嵌入图片的Web页面。浏览器需要发起4个HTTP事务来显示此页面: 1个用于顶层的HTML页面，3个用于嵌入的图片。如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来。</p>
<p><img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224103539476.png" alt="image-20220224103539476"></p>
<p>同时，用户更希望同时加载多幅图片，而不是一张一张的加载。</p>
<blockquote>
<p>串行加载的另一个缺点是，有些浏览器在对象加载完毕之前无法获知对象的尺寸， 而且它们可能需要尺寸信息来决定将对象放在屏幕的什么位置上，所以在加载了足够多的对象之前，无法在屏幕上显示任何内容。在这种情况下，可能浏览器串行装 载对象的进度很正常，但用户面对的却是一个空白的屏幕，对装载的进度一无所知。</p>
</blockquote>
<p><strong><em>解决方案</em></strong></p>
<ul>
<li><p>并行连接</p>
<p>通过多条TCP连接发起并发的HTTP请求。</p>
</li>
<li><p>持久连接</p>
<p>重用TCP连接，以消除连接及关闭时延。</p>
</li>
<li><p>管道化连接</p>
<p>通过共享的TCP连接发起并发的HTTP请求。</p>
</li>
<li><p>复用连接</p>
<p>通过共享的TCP连接发起并发的HTTP请求。</p>
</li>
</ul>
<h2 id="并行连接"><a href="#并行连接" class="headerlink" title="并行连接"></a>并行连接</h2><p> HTTP允许客户端打开多条连接，并行地执行多个HTTP事务。在 这个例子中，**<em>并行加载**</em>了四幅嵌入式图片，每个事务都有自己的TCP连接。</p>
<p><img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224104152923.png" alt="image-20220224104152923"></p>
<h3 id="并行连接可能会提高页面加载速度"><a href="#并行连接可能会提高页面加载速度" class="headerlink" title="并行连接可能会提高页面加载速度"></a>并行连接可能会提高页面加载速度</h3><p>包含嵌入对象的组合页面如果能（通过并行连接）克服单条连接的<strong>空载时间和带宽限制</strong>，加载速度也会有所提高。<strong>时延可以重叠</strong>起来，而且如果单条连接没有充分利用客户端的因特网带宽，可以将未用带宽分配来装载其他对象。</p>
<p><img data-src="/2022/02/24/HTTP%E8%BF%9E%E6%8E%A5/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220224104412136.png" alt="image-20220224104412136"></p>
<h3 id="并行连接不一定会更快"><a href="#并行连接不一定会更快" class="headerlink" title="并行连接不一定会更快"></a>并行连接不一定会更快</h3><blockquote>
<p>如果并行加载多个对象， 每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载，这样带来的性能提升就很小，甚至没什么提升。 </p>
</blockquote>
<blockquote>
<p>打开大量连接会消耗很多内存资源，从而引发自身的性能问题。</p>
</blockquote>
<p>实际上，浏览器确实使用了并行连接，但它们会将并行连接的总数限制为一个较小的值（通常是4个）。服务器可以随意关闭来自特定客户端的超量连接。</p>
<p>但并行连接确实可以让用户感觉到</p>
<h2 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h2><h2 id="管道化连接"><a href="#管道化连接" class="headerlink" title="管道化连接"></a>管道化连接</h2>]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP/1.1深入学习（一）</title>
    <url>/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="HTTP解决了什么问题"><a href="#HTTP解决了什么问题" class="headerlink" title="HTTP解决了什么问题"></a>HTTP解决了什么问题</h2><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source_posts\HTTP-1-1深入学习\image01.png" alt="image-20220216145214793"></p>
<p>解决 WWW 信息交互必须面对的需求：</p>
<ul>
<li><p> 低门槛 </p>
</li>
<li><p>可扩展性：巨大的用户群体，超长的寿命 </p>
</li>
<li><p> 分布式系统下的 Hypermedia：大粒度数据的网络传输 </p>
</li>
<li><p>Internet 规模 </p>
<ul>
<li><p>无法控制的 scalability </p>
<ul>
<li><p>不可预测的负载、非法格式的数据、恶意消息 </p>
</li>
<li><p>客户端不能保持所有服务器信息，服务器不能保持多个请求间的状态信息</p>
<p>独立的组件部署：新老组件并存</p>
<p>向前兼容：自 1993 年起 HTTP0.9\1.0（1996）已经被广泛使用</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source_posts\HTTP-1-1深入学习\image02.png" alt="image-20220216145500667"></p>
<h2 id="浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式"><a href="#浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式" class="headerlink" title="浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式"></a>浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式</h2><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source\_posts\HTTP-1-1深入学习\image03.png" alt="image-20220216143022772" style="zoom:150%;">

<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143059824.png" alt="image-20220216143059824"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143217688.png" alt="image-20220216143217688"></p>
<p>一种无状态的、应用层的、以<strong>请求/应答方式</strong>运行的协议，使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。</p>
<h3 id="HTTP的协议格式"><a href="#HTTP的协议格式" class="headerlink" title="HTTP的协议格式"></a>HTTP的协议格式</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143444135.png" alt="image-20220216143444135"></p>
<h4 id="ABNF-扩充巴科斯-瑙尔范式-操作符"><a href="#ABNF-扩充巴科斯-瑙尔范式-操作符" class="headerlink" title="ABNF(扩充巴科斯-瑙尔范式)操作符"></a>ABNF(扩充巴科斯-瑙尔范式)操作符</h4><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143600821.png" alt="image-20220216143600821"></p>
<p><strong><em>ABNF的核心规则</em></strong></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143608965.png" alt="image-20220216143608965"></p>
<blockquote>
<p>基于ABNF描述的HTTP协议格式 + 具体实例</p>
</blockquote>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143758587.png" alt="image-20220216143758587"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143824981.png" alt="image-20220216143824981"></p>
<h2 id="网络分层：OSI模型与TCP-IP模型"><a href="#网络分层：OSI模型与TCP-IP模型" class="headerlink" title="网络分层：OSI模型与TCP/IP模型"></a>网络分层：OSI模型与TCP/IP模型</h2><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144746312.png" alt="image-20220216144746312"></p>
<h3 id="OSI模型与TCP模型的对照"><a href="#OSI模型与TCP模型的对照" class="headerlink" title="OSI模型与TCP模型的对照"></a>OSI模型与TCP模型的对照</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144826027.png" alt="image-20220216144826027"></p>
<h3 id="在不同层之间的报文头部封装"><a href="#在不同层之间的报文头部封装" class="headerlink" title="在不同层之间的报文头部封装"></a>在不同层之间的报文头部封装</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144956500.png" alt="image-20220216144956500"></p>
<p>注意一下在图中表明的各层的报文分别叫什么名字。</p>
<h2 id="评估Web架构的关键属性"><a href="#评估Web架构的关键属性" class="headerlink" title="评估Web架构的关键属性"></a>评估Web架构的关键属性</h2><p>HTTP 协议应当在以下属性中取得可接受的均衡：</p>
<ul>
<li><strong>性能</strong> Performance：影响高可用的关键因素 </li>
<li><strong>可伸缩性</strong> Scalability：支持部署可以互相交互的大量组件 </li>
<li><strong>简单性</strong> Simplicity：易理解、易实现、易验证 </li>
<li><strong>可见性</strong> Visiable：对两个组件间的交互进行监视或者仲裁的能力。如缓存、分层设计等</li>
<li><strong>可移植性</strong> Portability：在不同的环境下运行的能力 </li>
<li><strong>可靠性</strong> Reliability：出现部分故障时，对整体影响的程度 </li>
<li><strong>可修改性</strong> Modifiability：对系统作出修改的难易程度，由可进化性、可定制性、可扩展性、可配置性、可重用性构成</li>
</ul>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154311688.png" alt="image-20220216154311688"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154333582.png" alt="image-20220216154333582"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154407111.png" alt="image-20220216154407111"></p>
<h2 id="从五种架构风格推导出HTTP的REST架构"><a href="#从五种架构风格推导出HTTP的REST架构" class="headerlink" title="从五种架构风格推导出HTTP的REST架构"></a>从五种架构风格推导出HTTP的REST架构</h2><p> <img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154624220.png" alt="image-20220216154624220"></p>
<h3 id="数据流风格-Data-flow-Styles"><a href="#数据流风格-Data-flow-Styles" class="headerlink" title="数据流风格 Data-flow Styles"></a>数据流风格 Data-flow Styles</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154806375.png" alt="image-20220216154806375"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154827521.png" alt="image-20220216154827521"></p>
<h3 id="复制风格"><a href="#复制风格" class="headerlink" title="复制风格"></a>复制风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155000320.png" alt="image-20220216155000320"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155007623.png" alt="image-20220216155007623"></p>
<h3 id="分层风格"><a href="#分层风格" class="headerlink" title="分层风格"></a>分层风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155144846.png" alt="image-20220216155144846"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155211840.png" alt="image-20220216155211840"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155244132.png" alt="image-20220216155244132"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155251415.png" alt="image-20220216155251415"></p>
<h3 id="移动代码风格-Mobile-Code-Styles"><a href="#移动代码风格-Mobile-Code-Styles" class="headerlink" title="移动代码风格 Mobile Code Styles"></a>移动代码风格 Mobile Code Styles</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155401997.png" alt="image-20220216155401997"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155440972.png" alt="image-20220216155440972"></p>
<h3 id="点对点风格"><a href="#点对点风格" class="headerlink" title="点对点风格"></a>点对点风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155509897.png" alt="image-20220216155509897"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155556884.png" alt="image-20220216155556884"></p>
<h3 id="不同风格之间的演化"><a href="#不同风格之间的演化" class="headerlink" title="不同风格之间的演化"></a>不同风格之间的演化</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155625246.png" alt="image-20220216155625246"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC创建对象</title>
    <url>/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制反转（<strong>IoC，Inversion of Control</strong>），是一个概念，是一种思想。指将传统上由程序代 码直接操控的对象调用权交给容器，通过容器来实现对象的装配和管理。控制反转就是对对 象控制权的转移，从程序代码本身反转到了外部容器。通过容器实现对象的创建，属性赋值， 依赖的管理。</p>
<p>IoC 是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式是依赖 注入。应用广泛。</p>
<blockquote>
<p>依赖注入</p>
</blockquote>
<p><strong>依赖</strong>：classA 类中含有 classB 的实例，在 classA 中调用 classB 的方法完成功能，即 classA 对 classB 有依赖。</p>
<blockquote>
<p>Ioc 的实现：</p>
</blockquote>
<p> ➢ 依赖注入：DI(Dependency Injection)，程序代码不做定位查询，这些工作由容器自行 完成。</p>
<p>依赖注入 DI 是指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，<u>由外部容器创建后传递给程序</u>。</p>
<p>Spring 的依赖注入对调用者与被调用者几乎没有任何要求，完全支持对象之间依赖关 的管理。</p>
<p>Spring 容器是一个超级大工厂，负责创建、管理所有的 Java 对象，这些 Java 对象被称为 Bean。Spring 容器管理着容器中 Bean 之间的依赖关系，Spring 使用“依赖注入”的方式 来管理 Bean 之间的依赖关系。使用 IoC 实现对象之间的解耦和。</p>
<h3 id="开发工具准备"><a href="#开发工具准备" class="headerlink" title="开发工具准备"></a>开发工具准备</h3><blockquote>
<p>开发工具：idea2017 以上  依赖管理：maven3 以上     jdk:1.8 以上</p>
</blockquote>
<p>需要设置maven本机仓库</p>
 <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/01.png" class>



<h3 id="Spring的第一个程序"><a href="#Spring的第一个程序" class="headerlink" title="Spring的第一个程序"></a>Spring的第一个程序</h3><h4 id="创建Maven项目"><a href="#创建Maven项目" class="headerlink" title="创建Maven项目"></a>创建Maven项目</h4> <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/02.png" class>



<h4 id="引入maven依赖pom-xml"><a href="#引入maven依赖pom-xml" class="headerlink" title="引入maven依赖pom.xml"></a>引入maven依赖pom.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> 				<span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="定义接口与实体类"><a href="#定义接口与实体类" class="headerlink" title="定义接口与实体类"></a>定义接口与实体类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeServiceImpl</span> <span class="keyword">implements</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SomeServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;SomeServiceImpl无参数构造方法&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;====业务方法doSome()===&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="创建spring配置文件"><a href="#创建spring配置文件" class="headerlink" title="创建spring配置文件"></a>创建spring配置文件</h4><p>在 src/main/resources/目录现创建一个 xml 文件，文件名可以随意，但 Spring 建议的名称为applicationContext.xml。</p>
<p>spring 配置中需要加入约束文件才能正常使用，约束文件是 xsd 扩展名。</p>
 <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/03.png" class>

<img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/04.png" class>

<p><bean>：用于定义一个实例对象。一个实例对应一个 bean 元素</bean></p>
<p><strong>id</strong>：该属性是 Bean 实例的唯一标识，程序通过 id 属性访问 Bean，Bean 与 Bean 间的依 赖关系也是通过 id 属性关联的。</p>
<p><strong>class</strong>：指定该 Bean 所属的类，注意这里只能是类，不能是接口。</p>
<h4 id="定义测试类"><a href="#定义测试类" class="headerlink" title="定义测试类"></a>定义测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//spring创建对象默认调用的是类的无参数构造方法</span></span><br><span class="line"> <span class="comment">//使用spring创建好的对象</span></span><br><span class="line"> <span class="comment">//指定spring配置文件的名称</span></span><br><span class="line">     String config = <span class="string">&quot;beans.xml&quot;</span>;</span><br><span class="line"> <span class="comment">//创建表示spring容器的对象，ApplicationContext,表示spring容器，通过容器加载对象</span></span><br><span class="line">     <span class="comment">//ClassPathXmlApplicationContext:表示从类路径中加载spring的配置文件</span></span><br><span class="line">     ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(config);  <span class="comment">//Spring创建对象时机：在创建spring容器时，创建spring配置文件中的所有对象</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//从容器中获取对象，需要调用对象的方法</span></span><br><span class="line">     <span class="comment">//getbean(&quot;配置文件中的bean的id值&quot;),返回的是object类型，需要强转一下</span></span><br><span class="line">     SomeService service = (SomeService) ac.getBean(<span class="string">&quot;someService&quot;</span>);</span><br><span class="line"></span><br><span class="line">     service.dosome();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="使用spring创建非自定义类对象"><a href="#使用spring创建非自定义类对象" class="headerlink" title="使用spring创建非自定义类对象"></a>使用spring创建非自定义类对象</h4><p>spring 配置文件加入 java.util.Date 定义：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>MyTest 测试类中： 调用 getBean(“myDate”); 获取日期类对象。</p>
<h4 id="容器接口和实现类"><a href="#容器接口和实现类" class="headerlink" title="容器接口和实现类"></a>容器接口和实现类</h4><blockquote>
<p>ApplicationContext接口（容器）</p>
</blockquote>
<p>ApplicationContext 用于加载 Spring 的配置文件，在程序中充当“容器”的角色。其实现类有两个。</p>
 <img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/05.png" class>



<ul>
<li><p>配置文件在类路径下</p>
<p>若 Spring 配置文件存放在项目的类路径下，则使用 ClassPathXmlApplicationContext 实现 类进行加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//spring配置文件在类路径下(classpath)</span></span><br><span class="line">    String resource = <span class="string">&quot;applicationContext.xml&quot;</span>;</span><br><span class="line">    ApplicationContext ac = ClassPathXmlApplicationContext(resource);</span><br><span class="line">    SomeService service = (SomeService) ac.getbean(<span class="string">&quot;someService&quot;</span>);</span><br><span class="line">    service.dosome();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>ApplicationContext容器中对象的装配时机</p>
<p>ApplicationContext 容器，会在容器对象初始化时，将其中的所有对象一次性全部装配好。 以后代码中若要使用到这些对象，只需从内存中直接获取即可。执行效率较高。但占用内存。</p>
</li>
<li><p>使用spring容器创建的Java对象</p>
<img data-src="/2021/02/28/IOC%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/06.png" class>



</li>
</ul>
<ul>
<li><p>使用spring提供的方法获取对象信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取Spring容器中Java对象的信息</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String config = <span class="string">&quot;beans.xml&quot;</span>;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(config); <span class="comment">//这里的参数传入不能加双引号</span></span><br><span class="line">        <span class="comment">//使用spring提供的方法，获取容器中定义的对象的数量与名称</span></span><br><span class="line">        <span class="keyword">int</span> nums = ac.getBeanDefinitionCount();</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中定义的对象数量&quot;</span>+nums);</span><br><span class="line"></span><br><span class="line">        String[] beanDefinitionNames = ac.getBeanDefinitionNames();</span><br><span class="line">        <span class="keyword">for</span>(String name:beanDefinitionNames)&#123;</span><br><span class="line">            System.out.println(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
















</li>
</ul>
]]></content>
      <categories>
        <category>spring框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>IPVS</title>
    <url>/2021/03/25/IPVS/</url>
    <content><![CDATA[<h1 id="一、LVS简介"><a href="#一、LVS简介" class="headerlink" title="一、LVS简介"></a>一、LVS简介</h1><p>LVS是Linux Virtual Server的简称，也就是Linux虚拟服务器, 是一个由章文嵩博士发起的自由软件项目，现在已经是 Linux标准内核的一部分。LVS是一种叫基于TCP/IP的负载均衡技术，转发效率极高，具有处理百万计并发连接请求的能力。</p>
<p>LVS的IP负载均衡技术是通过IPVS模块实现的。IPVS模块是LVS集群的核心软件模块，它安装在LVS集群作为负载均衡的主节点上，虚拟出一个IP地址和端口对外提供服务。用户通过访问这个虚拟服务（VS），然后访问请求由负载均衡器（LB）调度到后端真实服务器（RS）中，由RS实际处理用户的请求给返回响应。</p>
 <img data-src="/2021/03/25/IPVS/01.png" class>

<h1 id="二、IPVS的三种转发模式"><a href="#二、IPVS的三种转发模式" class="headerlink" title="二、IPVS的三种转发模式"></a>二、IPVS的三种转发模式</h1><p>根据负载均衡器转发客户端请求以及RS返回响应机制的不同，将IPVS的转发模式分为三种：NAT，DR，FULLNAT。（还有一种IP TUNNEL模式，IP通道技术，接触比较少）</p>
<h2 id="1-DR模式（Direct-Routing）"><a href="#1-DR模式（Direct-Routing）" class="headerlink" title="1. DR模式（Direct Routing）"></a>1. DR模式（Direct Routing）</h2><p>DR模式下，客户端的请求包到达负载均衡器的虚拟服务IP端口后，负载均衡器不会改写请求包的IP和端口，但是会改写请求包的MAC地址为后端RS的MAC地址，然后将数据包转发；真实服务器处理请求后，响应包直接回给客户端，不再经过负载均衡器。所以DR模式的转发效率是最高的，特别适合下行流量较大的业务场景，比如请求视频等大文件。</p>
<h3 id="DR模式的特点："><a href="#DR模式的特点：" class="headerlink" title="DR模式的特点："></a>DR模式的特点：</h3><p><strong>数据包在LB转发过程中，源/目的IP端口都不会变化</strong></p>
<p>LB只是将数据包的MAC地址改写为RS的MAC地址，然后转发给相应的RS。</p>
<p><strong>每台RS上都必须在环回网卡上绑定LB的虚拟服务IP</strong></p>
<p>因为LB转发时并不会改写数据包的目的IP，所以RS收到的数据包的目的IP仍是LB的虚拟服务IP。为了保证RS能够正确处理该数据包，而不是丢弃，必须在RS的环回网卡上绑定LB的虚拟服务IP。这样RS会认为这个虚拟服务IP是自己的IP，自己是能够处理这个数据包的。否则RS会直接丢弃该数据包！</p>
<p><strong>RS上的业务进程必须监听在环回网卡的虚拟服务IP上，且端口必须和LB上的虚拟服务端口一致</strong></p>
<p>因为LB不会改写数据包的目的端口，所以RS服务的监听端口必须和虚拟服务端口一致，否则RS会直接拒绝该数据包。</p>
<p><strong>RS处理完请求后，响应直接回给客户端，不再经过LB</strong></p>
<p>因为RS收到的请求数据包的源IP是客户端的IP，所以理所当然RS的响应会直接回给客户端，而不会再经过LB。这时候要求RS和客户端之间的网络是可达的。</p>
<p><strong>LB和RS须位于同一个子网</strong></p>
<p>因为LB在转发过程中需要改写数据包的MAC为RS的MAC地址，所以要能够查询到RS的MAC。而要获取到RS的MAC，则需要保证二者位于一个子网，否则LB只能获取到RS网关的MAC地址。</p>
  <img data-src="/2021/03/25/IPVS/02.png" class>

<h2 id="2-NAT模式（Network-Address-Translation）"><a href="#2-NAT模式（Network-Address-Translation）" class="headerlink" title="2. NAT模式（Network Address Translation）"></a>2. NAT模式（Network Address Translation）</h2><p>NAT模式下，请求包和响应包都需要经过LB处理。当客户端的请求到达虚拟服务后，LB会对请求包做目的地址转换（DNAT），将请求包的目的IP改写为RS的IP。当收到RS的响应后，LB会对响应包做源地址转换（SNAT），将响应包的源IP改写为LB的IP。</p>
<h3 id="NAT模式的特点："><a href="#NAT模式的特点：" class="headerlink" title="NAT模式的特点："></a>NAT模式的特点：</h3><p><strong>LB会修改数据包的地址</strong></p>
<p>对于请求包，会进行DNAT；对于响应包，会进行SNAT。</p>
<p><strong>LB会透传客户端IP到RS（DR模式也会透传）</strong></p>
<p>虽然LB在转发过程中做了NAT转换，但是因为只是做了部分地址转发，所以RS收到的请求包里是能看到客户端IP的。</p>
<p><strong>需要将RS的默认网关地址配置为LB的浮动IP地址</strong></p>
<p>因为RS收到的请求包源IP是客户端的IP，为了保证响应包在返回时能走到LB上面，所以需要将RS的默认网关地址配置为LB的虚拟服务IP地址。当然，如果客户端的IP是固定的，也可以在RS上添加明细路由指向LB的虚拟服务IP，不用改默认网关。</p>
<p><strong>LB和RS须位于同一个子网，并且客户端不能和LB/RS位于同一子网</strong></p>
<p>因为需要将RS的默认网关配置为LB的虚拟服务IP地址，所以需要保证LB和RS位于同一子网。</p>
<p>又因为需要保证RS的响应包能走回到LB上，则客户端不能和RS位于同一子网。否则RS直接就能获取到客户端的MAC，响应包就直接回给客户端了，不会走网关，也就走不到LB上面了。这时候由于没有LB做SNAT，客户端收到的响应包源IP是RS的IP，而客户端的请求包目的IP是LB的虚拟服务IP，这时候客户端无法识别响应包，会直接丢弃。</p>
  <img data-src="/2021/03/25/IPVS/03.png" class>

<h2 id="3-FULLNAT模式"><a href="#3-FULLNAT模式" class="headerlink" title="3. FULLNAT模式"></a>3. FULLNAT模式</h2><p>FULLNAT模式下，LB会对请求包和响应包都做SNAT+DNAT。</p>
<h3 id="FULLNAT模式的特点："><a href="#FULLNAT模式的特点：" class="headerlink" title="FULLNAT模式的特点："></a>FULLNAT模式的特点：</h3><p><strong>LB完全作为一个代理服务器</strong></p>
<p>FULLNAT下，客户端感知不到RS，RS也感知不到客户端，它们都只能看到LB。此种模式和七层负载均衡有点相似，只不过不会去解析应用层协议，而是在TCP层将消息转发</p>
<p><strong>LB和RS对于组网结构没有要求</strong></p>
<p>不同于NAT和DR要求LB和RS位于一个子网，FULLNAT对于组网结构没有要求。只需要保证客户端和LB、LB和RS之间网络互通即可。</p>
  <img data-src="/2021/03/25/IPVS/04.png" class>

<p>三种转发模式性能从高到低：DR &gt; NAT &gt;FULLNAT。</p>
<p>虽然FULLNAT模式的性能比不上DR和NAT，但是FULLNAT模式没有组网要求，允许LB和RS部署在不同的子网中，这给运维带来了便利。并且 FULLNAT模式具有更好的可拓展性，可以通过增加更多的LB节点，提升系统整体的负载均衡能力。</p>
<img data-src="/2021/03/25/IPVS/05.png" class>

<h1 id="三、IPVS支持的调度算法"><a href="#三、IPVS支持的调度算法" class="headerlink" title="三、IPVS支持的调度算法"></a>三、IPVS支持的调度算法</h1><p>对于后端的RS集群，LB是如何决策应该把消息调度到哪个RS节点呢？这是由负载均衡调度算法决定的。IPVS常用的调度算法有：</p>
<p>轮询（Round Robin）</p>
<p>LB认为集群内每台RS都是相同的，会轮流进行调度分发。从数据统计上看，RR模式是调度最均衡的。</p>
<p>加权轮询（Weighted Round Robin）</p>
<p>LB会根据RS上配置的权重，将消息按权重比分发到不同的RS上。可以给性能更好的RS节点配置更高的权重，提升集群整体的性能。</p>
<p>最小连接数（Least Connections）</p>
<p>LB会根据和集群内每台RS的连接数统计情况，将消息调度到连接数最少的RS节点上。在长连接业务场景下，LC算法对于系统整体负载均衡的情况较好；但是在短连接业务场景下，由于连接会迅速释放，可能会导致消息每次都调度到同一个RS节点，造成严重的负载不均衡。</p>
<p>加权最小连接数（Weighted Least Connections）</p>
<p>最小连接数算法的加权版~</p>
<p>地址哈希（Address Hash）</p>
<p>LB上会保存一张哈希表，通过哈希映射将客户端和RS节点关联起来</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>IPVS</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB存储引擎</title>
    <url>/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h2><h3 id="InnoDB体系架构"><a href="#InnoDB体系架构" class="headerlink" title="InnoDB体系架构"></a>InnoDB体系架构</h3><p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114112823026.png" alt="image-20210114112823026"></p>
<p>InnoDB存储引擎有多个内存块，这些内存块组成了一个大的内存池</p>
<p>后台线程的主要作用就是负责刷新内存池中的数据，保证缓存池中的内存缓存的是最近的数据。此外，还将已经修改的数据文件刷新到磁盘文件，同时保证在数据库发生异常的情况下，InnoDB可以恢复运行到最佳状态。</p>
<h4 id="后台线程（InnDB是一个多线程模型"><a href="#后台线程（InnDB是一个多线程模型" class="headerlink" title="后台线程（InnDB是一个多线程模型)"></a>后台线程（InnDB是一个多线程模型)</h4><p>#####Master Thread</p>
<p><strong>作用：</strong></p>
<p>​    一个非常核心的后台进程，负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓存、UNDO页的回收等。</p>
<h5 id="IO-Therad"><a href="#IO-Therad" class="headerlink" title="IO Therad"></a>IO Therad</h5><p>  在InnoDB存储引擎中大量使用了AIO（Async IO）—异步时间非阻塞IO，这样可以极大程度上提高数据库的性能。IO Thread的主要工作就是负责这些IO请求的回调</p>
<p>共有四个IO Thread:write 、read、insert buffer、log IO thread</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114114130216.png" alt="image-20210114114130216"></p>
<p>通过命令SHOW ENGINE INNODB STASTUS\G来观察IO Thread</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114114405936.png" alt="image-20210114114405936"></p>
<p>有四个write和read IO Thread</p>
<p>通过innodb_read_io_threads和innodb_write_io_threads参数来进行设置</p>
<h5 id="Purge-Thread"><a href="#Purge-Thread" class="headerlink" title="Purge Thread"></a>Purge Thread</h5><p><strong>作用</strong>：</p>
<p>​    Purge Thread回收已经使用并且已经分配的undo页（事务提交之后，其所使用的Undolog可能就不再需要）</p>
<p>用户需要在<strong>MySQL数据库的配置文件</strong>中添加如下命令来启用独立的Purge Thread: </p>
<p>​        innodb_purge_threads=1</p>
<h5 id="Page-Cleaner-Thread"><a href="#Page-Cleaner-Thread" class="headerlink" title="Page Cleaner Thread"></a>Page Cleaner Thread</h5><p><strong>作用</strong>：</p>
<p>​    将脏页的刷新操作放在单独的线程中完成。减轻Master Thread的工作以及对于用户查询线程的阻塞</p>
<h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><h5 id="缓存池"><a href="#缓存池" class="headerlink" title="缓存池"></a>缓存池</h5><p>Innodb存储引擎是基于磁盘存储的（Disk-base Database），将其中的记录按照页来管理。</p>
<p>缓存池的出现，就是为了解决CPU速度和磁盘速度之间的差异，通过内存的速度来弥补磁盘速度较慢对数据库性能的影响。读取文件时，首先判断给文件是否在缓存池中（没有就去磁盘上找）。</p>
<p>在修改缓存池中的页时，先以一定频率刷新到缓存池上，然后通过Checkpoint刷新回磁盘。</p>
<p>数据库服务器最好采用64位操作系统，可以使用更多的内存（512GB），32位（只有64GB）。</p>
<p>缓存池的配置通过参数innodb_buffer_pool_size来设置。</p>
<h6 id="缓存池中缓存的数据页类型："><a href="#缓存池中缓存的数据页类型：" class="headerlink" title="缓存池中缓存的数据页类型："></a>缓存池中缓存的数据页类型：</h6><p>​    索引页、数据页、Undo页、插入缓存页、自适应哈希索引页（adaptive hash index）、InnoDB存储的锁信息、数据字典信息等。</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114131120313.png" alt="image-20210114131120313"></p>
<p><strong>允许有多个缓存池实例</strong>：每个页根据hashcode平均分配到不同的缓存池实例中，减少数据库内部资源的竞争，增加数据库的并发能力。可以通过inodb_buffer_pool_instances来进行配置，通过命令SHOW ENGINE INNODB STATUS可以观察到每个缓存池实例对象运行的状态，还可以通过查看表InnoDB_BUFFER_POOL_STATS来观察缓存的状态(要求在information_schema架构下)</p>
<h5 id="LRU-LIST-、FREE-LIST-、FLUSH-LIST"><a href="#LRU-LIST-、FREE-LIST-、FLUSH-LIST" class="headerlink" title="LRU LIST 、FREE LIST 、FLUSH LIST"></a>LRU LIST 、FREE LIST 、FLUSH LIST</h5><p><strong>LRU</strong>算法用来管理已经读取的页</p>
<p>数据库中的缓存池是通过LRU（Latest Recent Used,最近最少使用）算法来管理内部的各种类型的页。</p>
<p><strong>LRU解释</strong>：将最频繁使用的页放在LRU列表的前端，最少使用的页放在LRU列表的尾端。当缓存池不能存放新读取到的页时，将优先删除列表尾端的页（默认大小为16KB）。</p>
<p><strong>改进</strong>：</p>
<p>1、（midpoint insertion strategy）：InnoDB中在LRU中加入了midpoint位置，将新读取到的页放在midpoint，而不是直接放在LRU列表首部。<strong>默认位置在LRU列表长度63%处</strong>（可以通过innodb_old_blocks_pct来控制）</p>
<p>2、设置了参数innodb_old_blocks_time,用于表示页读取到mid位置后需要等待多久才会加入到LRU列表的热端</p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114133522544.png" alt="image-20210114133522544"></p>
<p><img data-src="/2021/01/14/InnoDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114133412580.png" alt="image-20210114133412580"></p>
<p><strong>为什么要对朴素的LRU算法进行改良</strong>？</p>
<h5 id="重做日志缓存"><a href="#重做日志缓存" class="headerlink" title="重做日志缓存"></a>重做日志缓存</h5><h5 id="额外的内存池"><a href="#额外的内存池" class="headerlink" title="额外的内存池"></a>额外的内存池</h5>]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>InnoDB存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <url>/2021/02/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h3 id="1-内存管理那些事"><a href="#1-内存管理那些事" class="headerlink" title="1.内存管理那些事"></a>1.内存管理那些事</h3><p>C、C++：在内存管理领域，没有所谓的内存动态分配机制和垃圾收集技术，他们即拥有每一个对象的所有权，又担负着每一个对象从开始到终结的维护责任。</p>
<p>Java：在虚拟机自动内存管理机制的帮助下，不再需要为每一个new的对象写相配对的delete和free代码，也不容易出现内存泄漏和内存溢出的问题。</p>
<p>关于这两者之间对于内存管理之间的区别，从语言本身来说，指针的使用就可以表明二者在内存管理、使用、维护上的巨大差异。</p>
<h3 id="2-运行时数据区域"><a href="#2-运行时数据区域" class="headerlink" title="2.运行时数据区域"></a>2.运行时数据区域</h3><p>Java虚拟机在执行Java程序的同时会把他创建的内存分为若干个不同的数据区域，如下图所示：</p>
<img data-src="/2021/02/05/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/%E6%95%B0%E6%8D%AE%E5%8C%BA.png" class>

<h4 id="2-1程序计数器-Program-Counter-Register"><a href="#2-1程序计数器-Program-Counter-Register" class="headerlink" title="2.1程序计数器(Program Counter Register)"></a>2.1程序计数器(Program Counter Register)</h4><p>这是一块较小的内存区域。可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时，就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，包括分支、循环、判断、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成。</p>
<p>Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式实现的，在任何一个时刻，一个处理器指挥执行一条线程中的指令。<strong>为了线程切换后可以恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，且各个线程之间计数器互相不影响，独立存储</strong>。所以说程序计数器是线程私有的一块内存。</p>
<p><em>这是一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</em></p>
<ul>
<li><p>如果线程执行的是Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址；</p>
</li>
<li><p>如果正在执行的是Native方法，这个计数器值为空(Undefined)。</p>
</li>
</ul>
<h4 id="2-2Java虚拟机栈-Java-Virtual-Machine-Stacks"><a href="#2-2Java虚拟机栈-Java-Virtual-Machine-Stacks" class="headerlink" title="2.2Java虚拟机栈(Java Virtual Machine Stacks)"></a>2.2Java虚拟机栈(Java Virtual Machine Stacks)</h4><p>Java虚拟机栈是线程私有的，生命周期与线程相同。</p>
<blockquote>
<p>虚拟机栈描述的是**<em>Java方法**</em>执行的内存模型：每个方法在执行的同时会创建一个栈桢(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈桢在虚拟机栈中从出栈到入栈。</p>
</blockquote>
<p>局部变量表存放了：</p>
<ul>
<li><p>编译时期可知的各种基本数据类型（boolean\byte\char\short\int\float\long\duoble）</p>
</li>
<li><p>对象引用（reference类型，不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄和其他与此对象相关的位置）</p>
</li>
<li><p>returnAddress类型(指向了一条字节码指令的地址)。</p>
</li>
</ul>
<p>该区域可能会出现的异常情况：</p>
<p>1.StackOverFlowError:线程请求的栈深度大于虚拟机所允许的深度</p>
<p>2.OutOfMemoryError: 如果虚拟机可以实现动态扩展，但是在扩展时无法申请到足够的内存。</p>
<p>####2.3本地方法栈(Native Method Stack)</p>
<p>本地方法栈与虚拟机栈发挥的作用很相似，区别就是虚拟机栈为虚拟机执行Java方法（也就是字节码服务），而本地方法作为虚拟机使用到的Native方法服务。具体的虚拟机可以自由实现。HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。它的异常类型同样是上述两种。</p>
<h4 id="2-4Java堆"><a href="#2-4Java堆" class="headerlink" title="2.4Java堆"></a>2.4Java堆</h4><p>Java堆(Java Heap)是Java虚拟机管理内存区域中最大的一块。Java堆是被所有线程共享的一块儿内存区域，在虚拟机启动时被创建。</p>
<p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</strong></p>
<p>Java堆是垃圾收集器管理的主要区域，被称为GC堆(Garbage Collected Heap)。</p>
<blockquote>
<p>从内存回收的角度来看，基于现在收集器基本上都采用分代收集算法，Java堆可以细分为新生代和老年代；再细致一点有Eden空间、From Survivor空间、To Survivor空间</p>
</blockquote>
<blockquote>
<p>从内存分配的角度来看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区(<strong>Thread Local Allocation Buffer   TLAB</strong>)。</p>
</blockquote>
<p><strong><em>不论如何划分，都与存放内容无关无论哪个区域，存放的都是对象实例</em></strong>，进一步划分的目的是为了更好的回收内存，或者更快的分配内存</p>
<p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续的即可。</p>
<p>在实现时，既可以实现成固定大小的，也可以是可扩展的，不过主流的虚拟机都是按照可扩展来实现的（控制参数：-Xmx和-Xms控制）。如果堆中没有内存可以完成实例分配，并且堆也无法扩展时，将会抛出OutOfMemoryError异常。</p>
<h4 id="2-5方法区-Method-Area"><a href="#2-5方法区-Method-Area" class="headerlink" title="2.5方法区(Method Area)"></a>2.5方法区(Method Area)</h4><p>方法区与Java堆一样，是各个线程所共享的内存区域，<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述成为堆的一个逻辑部分，但是方法区还有一个别名叫做Non-Heap，目的就是与堆区分开。</p>
<p>Java虚拟机堆方法区的限制十分宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。但并非意味着数据进入了方法去就永久存在，这个区域的回收目标主要是针对常量池的回收和对类型的卸载，而回收的成绩难以令人满意，尤其是类型的卸载，条件更是相当苛刻，但是，<strong>这个区域的回收确实是必要的</strong>，可以一定程度上避免内存泄漏。</p>
<p>当方法区无法满足内存分配要求时，会报出OutOfMemoryError异常。</p>
<h4 id="2-6运行时常量池-Runtime-Constant-Pool"><a href="#2-6运行时常量池-Runtime-Constant-Pool" class="headerlink" title="2.6运行时常量池(Runtime Constant Pool)"></a>2.6运行时常量池(Runtime Constant Pool)</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项就是常量池(Constant Pool Table），用于存放<strong>编译期生成的各种字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<ul>
<li><p>对于运行时常量池，Java虚拟机规范并没有做任何细节的要求，不同的虚拟机提供厂商实现的虚拟机可以按站自己的需要来实现这个内存区域。除了保存Class文件中描述的符号引用外，还会将翻译的直接引用也存储在运行时常量池中。</p>
</li>
<li><p>运行时常量池相对于class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是说并非预置于Class文件中常量池的内容才可以进入方法去运行时常量池，运行期间也可能将新的常量放入池中。例如String类的intern()方法。</p>
</li>
<li><p>运行时常量池会受到方法区内存的限制，当常量池无法申请到内存是会报OutOfMemoryError异常。</p>
</li>
</ul>
<h4 id="2-7直接内存"><a href="#2-7直接内存" class="headerlink" title="2.7直接内存"></a>2.7直接内存</h4><p>直接内存就是本机的物理内存，服务器管理员在配置虚拟机参数时，要根据实际内存设置-Xmx等参数信息，避免使得各个内存区域大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError异常。</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>Java内存区域</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS负载均衡</title>
    <url>/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<blockquote>
<h3 id="LVS是什么"><a href="#LVS是什么" class="headerlink" title="LVS是什么?"></a>LVS是什么?</h3></blockquote>
<p>LVS，全称Linux Virtual Server，是国人章文嵩发起的一个开源项目。<br> 在社区具有很大的热度，是一个基于四层、具有强大性能的反向代理服务器。<br> <code>早期使用lvs需要修改内核才能使用，但是由于性能优异，现在已经被收入内核。</code></p>
<p>LVS通过工作于内核的ipvs模块来实现功能，其主要工作于netfilter 的INPUT链上。<br> 而用户需要对ipvs进行操作配置则需要使用ipvsadm这个工具。<br> ipvsadm主要用于设置lvs模型、调度方式以及指定后端主机。</p>
<blockquote>
<h3 id="LVS中的角色"><a href="#LVS中的角色" class="headerlink" title="LVS中的角色"></a>LVS中的角色</h3></blockquote>
<h5 id="LVS的一些相关术语"><a href="#LVS的一些相关术语" class="headerlink" title="LVS的一些相关术语"></a><strong>LVS的一些相关术语</strong></h5><p>LVS的模型中有两个角色：<br> **调度器:**Director，又称为Dispatcher，Balancer<br> <code>调度器主要用于接受用户请求。</code><br> **真实主机:**Real Server，简称为RS。<br> <code>用于真正处理用户的请求。</code></p>
<p>而为了更好地理解，我们将所在角色的IP地址分为以下三种：<br> <strong>Director Virtual IP:**调度器用于与客户端通信的IP地址，简称为VIP<br> **Director IP</strong>:调度器用于与RealServer通信的IP地址，简称为DIP。<br> <strong>Real Server :</strong> 后端主机的用于与调度器通信的IP地址，简称为RIP。</p>
<img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/02.webp" class>

<p>基本模型</p>
<blockquote>
<h3 id="LVS的三种调度模式"><a href="#LVS的三种调度模式" class="headerlink" title="LVS的三种调度模式"></a>LVS的三种调度模式</h3></blockquote>
<h3 id="LVS-NATNetwork-Address-Transform"><a href="#LVS-NATNetwork-Address-Transform" class="headerlink" title="LVS-NATNetwork Address Transform"></a>LVS-NAT<code>Network Address Transform</code></h3><h6 id="示意图和调度步骤"><a href="#示意图和调度步骤" class="headerlink" title="示意图和调度步骤"></a><strong>示意图和调度步骤</strong></h6><img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/01.webp" class>

<p>LVS-NAT</p>
<h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h6><p>基于ip伪装<code>MASQUERADES</code>，原理是多目标DNAT。<br> 所以请求和响应都经由Director调度器。</p>
<h6 id="LVS-NAT的优点与缺点"><a href="#LVS-NAT的优点与缺点" class="headerlink" title="LVS-NAT的优点与缺点"></a><strong>LVS-NAT的优点与缺点</strong></h6><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>支持端口映射</li>
<li>RS可以使用任意操作系统</li>
<li>节省公有IP地址。<br> <code>RIP和DIP都应该使用同一网段私有地址，而且RS的网关要指向DIP。</code><br> <code>使用nat另外一个好处就是后端的主机相对比较安全。</code></li>
</ul>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>请求和响应报文都要经过Director转发;极高负载时，Director可能成为系统瓶颈。<br> <code>就是效率低的意思。</code></li>
</ul>
<h3 id="LVS-TUNIP-Tuneling"><a href="#LVS-TUNIP-Tuneling" class="headerlink" title="LVS-TUNIP Tuneling"></a>LVS-TUN<code>IP Tuneling</code></h3><h6 id="示意图和调度步骤-1"><a href="#示意图和调度步骤-1" class="headerlink" title="示意图和调度步骤"></a><strong>示意图和调度步骤</strong></h6><img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/03.webp" class>

<p>LVS-TUN</p>
<h6 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a><strong>原理：</strong></h6><p>基于隧道封装技术。在IP报文的外面再包一层IP报文。<br> 当Director接收到请求的时候，选举出调度的RealServer<br> 当接受到从Director而来的请求时，RealServer则会使用lo接口上的VIP直接响应CIP。<br> 这样CIP请求VIP的资源，收到的也是VIP响应。</p>
<h6 id="LVS-TUN的优点与缺点"><a href="#LVS-TUN的优点与缺点" class="headerlink" title="LVS-TUN的优点与缺点"></a><strong>LVS-TUN的优点与缺点</strong></h6><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>RIP,VIP,DIP都应该使用公网地址，且RS网关不指向DIP;<br> <code>只接受进站请求，解决了LVS-NAT时的问题，减少负载。</code><br> <code>请求报文经由Director调度，但是响应报文不需经由Director。</code></li>
</ul>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>不指向Director所以不支持端口映射。</li>
<li>RS的OS必须支持隧道功能。</li>
<li>隧道技术会额外花费性能，增大开销。</li>
</ul>
<h3 id="LVS-DRDirect-Routing"><a href="#LVS-DRDirect-Routing" class="headerlink" title="LVS-DRDirect Routing"></a>LVS-DR<code>Direct Routing</code></h3><h6 id="示意图和调度步骤-2"><a href="#示意图和调度步骤-2" class="headerlink" title="示意图和调度步骤"></a><strong>示意图和调度步骤</strong></h6><img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/04.webp" class>

<p>LVS-DR</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h6><p>当Director接收到请求之后，通过调度方法选举出RealServer。<br> 讲目标地址的MAC地址改为RealServer的MAC地址。<br> RealServer接受到转发而来的请求，发现目标地址是VIP。<code>RealServer配置在lo接口上。</code><br> 处理请求之后则使用lo接口上的VIP响应CIP。</p>
<h6 id="LVS-DR的优点与缺点"><a href="#LVS-DR的优点与缺点" class="headerlink" title="LVS-DR的优点与缺点"></a><strong>LVS-DR的优点与缺点</strong></h6><h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>RIP可以使用私有地址，也可以使用公网地址。<br> <code>只要求DIP和RIP的地址在同一个网段内。</code></li>
<li>请求报文经由Director调度，但是响应报文不经由Director。</li>
<li>RS可以使用大多数OS</li>
</ul>
<h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>不支持端口映射。</li>
<li>不能跨局域网。</li>
</ul>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>三种模型虽然各有利弊，但是由于追求性能和便捷，DR是目前用得最多的LVS模型。</p>
<blockquote>
<h3 id="LVS的八种调度方法"><a href="#LVS的八种调度方法" class="headerlink" title="LVS的八种调度方法"></a>LVS的八种调度方法</h3></blockquote>
<h5 id="静态方法-仅依据算法本身进行轮询调度"><a href="#静态方法-仅依据算法本身进行轮询调度" class="headerlink" title="静态方法:仅依据算法本身进行轮询调度"></a>静态方法:仅依据算法本身进行轮询调度</h5><ul>
<li>RR:Round Robin,轮调<br> <code>一个接一个，自上而下</code></li>
<li>WRR:Weighted RR，加权论调<br> <code>加权，手动让能者多劳。</code></li>
<li>SH:SourceIP Hash<br> <code>来自同一个IP地址的请求都将调度到同一个RealServer</code></li>
<li>DH:Destination Hash<br> <code>不管IP，请求特定的东西，都定义到同一个RS上。</code></li>
</ul>
<h5 id="动态方法-根据算法及RS的当前负载状态进行调度"><a href="#动态方法-根据算法及RS的当前负载状态进行调度" class="headerlink" title="动态方法:根据算法及RS的当前负载状态进行调度"></a>动态方法:根据算法及RS的当前负载状态进行调度</h5><ul>
<li>LC:least connections(最小链接数)<br> <code>链接最少，也就是Overhead最小就调度给谁。</code><br> <code>假如都一样，就根据配置的RS自上而下调度。</code></li>
<li>WLC:Weighted Least Connection (加权最小连接数)<br> <code>这个是LVS的默认算法。</code></li>
<li>SED:Shortest Expection Delay(最小期望延迟)<br> <code>WLC算法的改进。</code></li>
<li>NQ:Never Queue<br> <code>SED算法的改进。</code></li>
<li>LBLC:Locality-Based Least-Connection,基于局部的的LC算法<br> 正向代理缓存机制。访问缓存服务器，调高缓存的命中率。<br> 和传统DH算法比较，考虑缓存服务器负载。可以看做是DH+LC<br> 如果有两个缓存服务器<br> 1.只要调度到其中的一个缓存服务器，那缓存服务器内就会记录下来。下一次访问同一个资源的时候也就是这个服务器了。   (DH)<br> 2.有一个用户从来没有访问过这两个缓存服务器，那就分配到负载较小的服务器。<code>LC</code></li>
</ul>
<p>LBLCR:Locality-Based Least-Connection  with  Replication(带复制的lblc算法)<br> 缓存服务器中的缓存可以互相复制。<br> 因为即使没有，也能立即从另外一个服务器内复制一份，并且均衡负载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man ipvsadm有讲这几种动态或者静态的rs调度方法</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="配置LVS-DR"><a href="#配置LVS-DR" class="headerlink" title="配置LVS-DR"></a>配置LVS-DR</h4></blockquote>
<table>
<thead>
<tr>
<th align="center">主机名</th>
<th align="center">主机地址</th>
<th align="center">角色</th>
</tr>
</thead>
<tbody><tr>
<td align="center">node1</td>
<td align="center">DIP:192.168.2.201，VIP:192.168.2.211</td>
<td align="center">Director</td>
</tr>
<tr>
<td align="center">node3</td>
<td align="center">RIP:192.168.2.203，VIP:192.168.2.211</td>
<td align="center">RealServer</td>
</tr>
<tr>
<td align="center">node4</td>
<td align="center">RIP:192.168.2.204，VIP:192.168.2.211</td>
<td align="center">RealServer</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本文中的主机系统均为CentOS7.1，Apache2.4，数据库：MariaDB-5.5.50</span><br></pre></td></tr></table></figure>
<p>实验拓扑：</p>
<img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/05.webp" class>

<p>lvs-dr实验拓扑</p>
<p><strong>(1)在Director上配置VIP和DIP</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  [root@bc ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736</span><br><span class="line">    TYPE=Ethernet</span><br><span class="line">    BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">    DEFROUTE=yes</span><br><span class="line">    PEERDNS=yes</span><br><span class="line">    PEERROUTES=yes</span><br><span class="line">    NAME=eno16777736</span><br><span class="line">    DEVICE=eno16777736</span><br><span class="line">    ONBOOT=yes</span><br><span class="line">    IPADDR=<span class="string">&quot;192.168.2.201&quot;</span></span><br><span class="line">    NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line">    DNS1=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line">    GATEWAY=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line"></span><br><span class="line">[root@bc ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736:0</span><br><span class="line">    TYPE=Ethernet</span><br><span class="line">    BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">    NAME=eno16777736:<span class="number">0</span></span><br><span class="line">    ONBOOT=yes</span><br><span class="line">    IPADDR=<span class="string">&quot;192.168.2.211&quot;</span></span><br><span class="line">    NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line">    DNS1=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line">    GATEWAY=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line">    ONPARENT=yes</span><br></pre></td></tr></table></figure>
<p>重启网络之后查看配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@bc ~]# service NetworkManager stop</span><br><span class="line">  Redirecting to /bin/systemctl stop  NetworkManager.service</span><br><span class="line">[root@bc ~]# service network restart</span><br><span class="line">  Restarting network (via systemctl):                        [  OK  ]</span><br><span class="line">[root@bc ~]# ifconfig</span><br><span class="line">  eno16777736: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.2</span><span class="number">.201</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.2</span><span class="number">.255</span></span><br><span class="line">        inet6 fe80::<span class="number">250</span>:56ff:fe3c:d757  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ether <span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:3c:d7:<span class="number">57</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">88853</span>  bytes <span class="number">14843664</span> (<span class="number">14.1</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">79195</span>  bytes <span class="number">6551143</span> (<span class="number">6.2</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  eno16777736:<span class="number">0</span>: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.2</span><span class="number">.255</span></span><br><span class="line">        ether <span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:3c:d7:<span class="number">57</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line"></span><br><span class="line">  lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">0</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">12998</span>  bytes <span class="number">1140269</span> (<span class="number">1.0</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">12998</span>  bytes <span class="number">1140269</span> (<span class="number">1.0</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>(2)Director使用ipvsadm修改创建ipvs规则</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@bc ~]# ipvsadm -A -t 192.168.2.211:80 -s rr</span><br><span class="line">[root@bc ~]# ipvsadm -a -t 192.168.2.211:80 -r 192.168.2.203 -g</span><br><span class="line">[root@bc ~]# ipvsadm -a -t 192.168.2.211:80 -r 192.168.2.204 -g</span><br><span class="line">[root@bc ~]# ipvsadm -L -n</span><br><span class="line">IP Virtual Server version <span class="number">1.2</span><span class="number">.1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">192.168</span><span class="number">.2</span><span class="number">.203</span>:<span class="number">80</span>             Route   <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span>         </span><br><span class="line">  -&gt; <span class="number">192.168</span><span class="number">.2</span><span class="number">.204</span>:<span class="number">80</span>             Route   <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span>   </span><br></pre></td></tr></table></figure>
<p><strong>(3)RealServer安装httpd</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# yum install httpd -y</span><br><span class="line">[root@node4 ~]# yum install httpd -y</span><br></pre></td></tr></table></figure>
<p><code>可以在里面放一个Wordpress,也可以简单echo几个字到index.html</code><br> <strong>(4)node3和node4修改RealServer内核参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;1&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br><span class="line">echo <span class="string">&quot;2&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">echo <span class="string">&quot;1&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo <span class="string">&quot;1&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">echo <span class="string">&quot;2&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">ifconfig lo:<span class="number">0</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span>/<span class="number">32</span> broadcast <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span> up</span><br><span class="line">route add -host <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span> dev lo:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>修改内核参数，并且配置VIP地址到RealServer的loopback接口上。</code><br> <strong><code>那样的话，当RealServer接到从Director转发而来的数据报文时，RealServer也不会丢弃报文。</code></strong><br> <code>同时，修改了RealServer的参数，局域网内的arp表就只有Director有VIP。</code><br> <code>RealServer的的机器上有VIP这件事，只有RealServer自己知道。</code><br> <strong><code>这样可以保证，当请求到来的时候，第一个会送到Director那里去。</code></strong></p>
<p><strong>(5)测试结果</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node3 httpd]# vim  /var/log/httpd/access_log </span><br><span class="line">[root@node4 httpd]# vim  /var/log/httpd/access_log </span><br></pre></td></tr></table></figure>
<p>效果差不多就是这样:<br> <code>因为我们使用了RR静态调度方法,所以这node3和node4的请求是一人一个。</code></p>
<img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/06.webp" class>



]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC框架</title>
    <url>/2021/03/02/MVC%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="MVC的定义"><a href="#MVC的定义" class="headerlink" title="MVC的定义"></a>MVC的定义</h2><p><strong>MVC模式</strong>（Model–view–controller）是软件工程中的一种<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84">软件架构</a>模式，把软件系统分为三个基本部分：模型（Model）、视图（View）和控制器（Controller）。</p>
<p><strong>MVC模式</strong>的目的是实现一种动态的程序设计，使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。除此之外，此模式透过对复杂度的简化，使程序结构更加直观。软件系统透过对自身基本部分分离的同时也赋予了各个基本部分应有的功能。专业人员可以依据自身的专长分组。</p>
<ul>
<li><p>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)。</p>
</li>
<li><p>视图（View） - 界面设计人员进行图形界面设计。</p>
</li>
<li><p>控制器（Controller）- 负责转发请求，对请求进行处理。</p>






</li>
</ul>
<h2 id="MVC三者之间详细说明与联系"><a href="#MVC三者之间详细说明与联系" class="headerlink" title="MVC三者之间详细说明与联系"></a>MVC三者之间详细说明与联系</h2><p>###详细说明</p>
<p>MVC模式在概念上强调 Model, View, Controller 的分离，各个模块也遵循着由 Controller 来处理消息，Model 掌管数据源，View 负责资料显示的职责分离原则，因此在实现上，MVC 模式的 Framework 通常会将 MVC 三个部分分离实现：</p>
<blockquote>
<p>Model 负责资料访问，较现代的 Framework 都会建议使用独立的资料对象 (DTO, POCO, POJO 等) 来替代弱类型的集合对象。资料访问的代码会使用 Data Access 的代码或是 ORM-based Framework，也可以进一步使用 Repository Pattern 与 Unit of Works Pattern 来切割数据源的相依性。</p>
</blockquote>
<blockquote>
<p>Controller 负责处理消息，较高端的 Framework 会有一个默认的实现来作为 Controller 的基础，例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等，在职责分离原则的基础上，每个 Controller 负责的部分不同，因此会将各个 Controller 切割成不同的文件以利维护</p>
</blockquote>
<blockquote>
<p>View 负责显示资料，这个部分多为前端应用，而 Controller 会有一个机制将处理的结果 (可能是 Model, 集合或是状态等) 交给 View，然后由 View 来决定怎么显示。例如 Spring Framework 使用 JSP 或相应技术，ASP.NET MVC 则使用 Razor 处理资料的显示。</p>
</blockquote>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><ul>
<li>View 传送指令到 Controller</li>
<li>Controller 完成业务逻辑后，要求 Model 改变状态</li>
<li>Model 将新的数据发送到 View，用户得到反馈</li>
<li>所有通信都是单向的。View和Model之间的通信是通过Controller来作为桥梁的，也就是说View和Model并不是直接通信；</li>
<li>需要服务器端配合，JavaScript可以在前端修改服务器渲染后的数据，所有通信都是单向的，提交一次反馈一次，通信一次相互制约。</li>
</ul>
<h2 id="MVC的优点与缺点"><a href="#MVC的优点与缺点" class="headerlink" title="MVC的优点与缺点"></a>MVC的优点与缺点</h2><blockquote>
<p>优点</p>
</blockquote>
<ul>
<li>多个 View 能共享一个 Model    <ul>
<li>同一个Web应用程序会提供多种用户界面，例如用户希望既能够通过浏览器来收发电子邮件 ，还希望通过手机来访问电子邮箱，这就要求Web网站同时能提供<a href="https://zh.wikipedia.org/wiki/Internet">Internet</a>界面和<a href="https://zh.wikipedia.org/wiki/WAP">WAP</a>界面。在MVC设计模式中， Model 响应用户请求并返回响应数据，View 负责格式化数据并把它们呈现给用户，业务逻辑和表示层分离，同一个 Model 可以被不同的 View 重用，所以大大提高了代码的可重用性。</li>
</ul>
</li>
<li>Controller 是自包含（self-contained,指高独立内聚）的对象，与 Model 和 View 保持相对独立，所以可以方便的改变应用程序的数据层和业务规则。<ul>
<li>把数据库从<a href="https://zh.wikipedia.org/wiki/MySQL">MySQL</a>移植到<a href="https://zh.wikipedia.org/wiki/Oracle">Oracle</a>，或者把<a href="https://zh.wikipedia.org/wiki/RDBMS">RDBMS</a>数据源改变成<a href="https://zh.wikipedia.org/wiki/LDAP">LDAP</a>数据源，只需改变 Model 即可。一旦正确地实现了控制器，不管数据来自数据库还是<a href="https://zh.wikipedia.org/wiki/LDAP">LDAP</a>服务器，View 都会正确地显示它们。由于MVC模式的三个模块相互独立，改变其中一个不会影响其他两个，所以依据这种设计思想能构造良好的少互扰性的构件，<strong>降低了耦合度</strong></li>
</ul>
</li>
<li>Controller 提高了应用程序的灵活性和可配置性<ul>
<li>Controller 可以用来连接不同的 Model 和 View 去完成用户的需求，也可以构造应用程序提供强有力的手段。给定一些可重用的 Model 、 View 和Controller 可以根据用户的需求选择适当的 Model 进行处理，然后选择适当的的 View 将处理结果显示给用户。</li>
</ul>
</li>
<li>增强了软件工程所要求的可测试性(Testablity)<ul>
<li>MVC-based 的应用程序在良好的职责分离的设计下，各个部分可独立行使<a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a>，有利于与企业内的自动化测试、<a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">持续集成</a> (Continuous Integration) 与<a href="https://zh.wikipedia.org/w/index.php?title=%E6%8C%81%E7%BA%8C%E7%99%BC%E8%A1%8C&action=edit&redlink=1">持续发行</a> (Continuous Delivery) 流程集成，减少应用程序改版部署所需的时间。</li>
</ul>
</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>不适合小型中等规模的应用程序；</li>
<li>增加了系统结果和实现的复杂性；</li>
<li>View和Model之间不匹配，用户界面和流程要考虑易用性，用户体验优化同时考虑业务流程的精确和无错。</li>
<li>Controler和Model之间界线不清，什么样的逻辑是界面逻辑，什么样的逻辑是业务逻辑，很难定义清楚。没有明确的定义；</li>
<li>View的变化不能完全由Model控制，即Observer模式不足以支持复杂的用户交互。这其实要求VC之间要有依赖。牵一发而动全身，数据，显示不分离，Controller，Model联系过于紧密。</li>
</ul>
<h2 id="扩展：MVP"><a href="#扩展：MVP" class="headerlink" title="扩展：MVP"></a>扩展：MVP</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>MVP（Model-View-Presenter）是MVC的改良模式，由IBM的子公司Taligent提出。和MVC的相同之处在于：Controller/Presenter负责业务逻辑，Model管理数据，View负责显示。只不过是将 Controller 改名为 Presenter，同时改变了通信方向。</p>
<h2 id="MVP的特点"><a href="#MVP的特点" class="headerlink" title="MVP的特点"></a>MVP的特点</h2><ul>
<li>M、V、P之间双向通信。</li>
<li>View 与 Model 不通信，都通过 Presenter 传递。Presenter完全把Model和View进行了分离，主要的程序逻辑在Presenter里实现。</li>
<li>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</li>
<li>Presenter与具体的View是没有直接关联的，而是通过<strong>定义好的接口</strong>进行交互，从而使得在变更View时候可以保持Presenter的不变，这样就可以重用。不仅如此，还可以编写测试用的View，模拟用户的各种操作，从而实现对Presenter的测试–从而不需要使用自动化的测试工具。</li>
</ul>
<h3 id="MVP的优缺点"><a href="#MVP的优缺点" class="headerlink" title="MVP的优缺点"></a>MVP的优缺点</h3><blockquote>
<p>MVP的优点</p>
</blockquote>
<ul>
<li>模型与视图完全分离，我们可以修改视图而不影响模型；</li>
<li>可以更高效地使用模型，因为所有的交互都发生在一个地方——Presenter内部；</li>
<li>我们可以将一个Presenter用于多个视图，而不需要改变Presenter的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；</li>
<li>如果我们把逻辑放在Presenter中，那么我们就可以脱离用户接口来测试这些逻辑（单元测试）。</li>
</ul>
<blockquote>
<p>MVP的缺点</p>
</blockquote>
<p>视图和Presenter的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，presenter也要变更。</p>
]]></content>
      <categories>
        <category>项目架构</category>
      </categories>
      <tags>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MVP开发策略</title>
    <url>/2022/08/06/MVP%E5%BC%80%E5%8F%91%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h2 id="MVP开发策略"><a href="#MVP开发策略" class="headerlink" title="MVP开发策略"></a>MVP开发策略</h2><p>MVP （最小化可实行产品，Minimum Viable Product）是 Eric Ries 在《精益创业》中关于「精益创业」（Lean Startup）的核心思想，意思是用最快、最简明的方式建立一个可用的产品原型，通过这个最简单的原型来测试产品是否符合市场预期，并通过不断的快速迭代来修正产品，最终适应市场需求。</p>
<p>简单来说，就是在<strong>做一个新产品的时候，不要一下子做一个「尽善尽美」的产品，而是先花费最小的代价做一个「可用」的产品原型</strong>，去验证这个产品是否有价值、是否可行，再通过迭代来完善细节。</p>
<img data-src="/2022/08/06/MVP%E5%BC%80%E5%8F%91%E7%AD%96%E7%95%A5/1.png" class>

<p>传统产品迭代思路成本高、速度慢、风险大，花高成本做出来的产品用户可能不认可；MVP 策略的优点在于试错成本低、速度快、风险低，能满足产品快速迭代的需求。</p>
<p>MVP的作用就是让你用最小的代价，最快的速度，最早的时间将你的产品设想拿出来接触用户，并根据用户的反馈来改进你的产品。这里拿出来的「产品」并不一定是一个App、网页或者其他，可以是视频、PPT（额，但是千万别 PPT 造车啊）、RP文件等等。</p>
]]></content>
      <categories>
        <category>Base-Cache缓存</category>
      </categories>
      <tags>
        <tag>KV缓存第一讲</tag>
      </tags>
  </entry>
  <entry>
    <title>MVVM框架</title>
    <url>/2021/03/02/MVVM%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>一个软件或者 APP都是服务于某种需求，这称之为“业务需求”。随着业务需求的增多、软件会变得越来越庞大，越来越复杂。所以就会设计一套完整的架构设计、研发流程以及质量管理体系来保证整个研发过程。“架构设计”是一个非常大的话题，它涉及到各方面，近年来前端一个明显的开发趋势就是架构从传统的 MVC 模式向 MVVM 模式迁移，这里来谈谈——MVVM模式。</p>
<h2 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM"></a>什么是MVVM</h2><blockquote>
<p>MVVM（Model–View–Viewmodel）是一种软件架构模式。<br>MVVM有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开，这是通过标记语言或GUI代码实现的。MVVM的视图模型是一个值转换器， 这意味着视图模型负责从模型中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，视图模型比视图做得更多，并且处理大部分视图的显示逻辑。 视图模型可以实现中介者模式，组织对视图所支持的用例集的后端逻辑的访问</p>
</blockquote>
<p><a href="https://zh.wikipedia.org/wiki/MVVM">想要了解更多关于MVVM的定义，点击访问维基百科</a></p>
<h2 id="MVVM涉及到的概念"><a href="#MVVM涉及到的概念" class="headerlink" title="MVVM涉及到的概念"></a>MVVM涉及到的概念</h2><ul>
<li>M(odel)层：模型，定义数据结构。</li>
<li>C(ontroller)层：实现业务逻辑，数据的增删改查。在MVVM模式中一般把C层算在M层中，（只有在理想的双向绑定模式下，Controller 才会完全的消失。这种理想状态一般不存在）</li>
<li>ViewModel层：顾名思义是视图View的模型、映射和显示逻辑（如if for等，非业务逻辑），另外绑定器也在此层。ViewModel是基于视图开发的一套模型，如果你的应用是给盲人用的，那么也可以开发一套基于Audio的模型AudioModel。</li>
<li>V(iew)层：将ViewModel通过特定的GUI展示出来，并在GUI控件上绑定视图交互事件，V(iew)一般由MVVM框架自动生成在浏览器中。</li>
</ul>
<h2 id="MVVM的工作机制"><a href="#MVVM的工作机制" class="headerlink" title="MVVM的工作机制"></a>MVVM的工作机制</h2><p>在MVVM架构下，View 和 Model 之间其实并没有直接的联系，而是通<strong>过ViewModel进行交互</strong>，Model 和 ViewModel 之间的交互是*<u>双向</u>*的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来。ViewModel里面包含DOM Listeners(数据监听)和Data Bindings(数据绑定)，DOM Listeners和Data Bindings是实现双向绑定的关键。</p>
<blockquote>
<p>DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；</p>
</blockquote>
<blockquote>
<p>Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</p>
</blockquote>
<img data-src="/2021/03/02/MVVM%E6%A1%86%E6%9E%B6/01.png" class>



<img data-src="/2021/03/02/MVVM%E6%A1%86%E6%9E%B6/02.png" class>



<h2 id="MVVM模式的优缺点"><a href="#MVVM模式的优缺点" class="headerlink" title="MVVM模式的优缺点"></a>MVVM模式的优缺点</h2><p>MVVM模式相较于原先的MVP模式至少省下30%编码量，甚至能省下70%DOM操作，因为用MVP模式的话主要是在进行DOM操作</p>
<blockquote>
<p>优点</p>
</blockquote>
<ul>
<li><strong>低耦合</strong>。View可以独立于Model变化和修改，一个ViewModel可以绑定到不同的View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。</li>
<li><strong>可重用性</strong>。可以把一些视图的逻辑放在ViewModel里面，让很多View重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注与业务逻辑和数据的开发(ViewModel)。设计人员可以专注于界面(View)的设计。</li>
<li><strong>可测试性</strong>。可以针对ViewModel来对界面(View)进行测试</li>
</ul>
<blockquote>
<p>缺点</p>
</blockquote>
<ul>
<li>学习成本高。</li>
<li>DEBUG困难</li>
<li>实现MVVM的开销对于简单的UI操作是过度的。而对于更大的应用来说，推广ViewModel将变得更加困难，非常大的应用程序中的数据绑定会导致相当大的内存消耗。</li>
</ul>
<h2 id="MVVM应用场景"><a href="#MVVM应用场景" class="headerlink" title="MVVM应用场景"></a>MVVM应用场景</h2><ul>
<li>针对具有复杂交互逻辑的前端应用</li>
<li>提供基础的架构抽象</li>
<li>通过Ajax数据持久化，保证前端用户体验</li>
</ul>
<h2 id="常见的MVVM框架"><a href="#常见的MVVM框架" class="headerlink" title="常见的MVVM框架"></a>常见的MVVM框架</h2><p>Vue.js   AngularJs，ReactJs</p>
]]></content>
      <categories>
        <category>项目架构</category>
      </categories>
      <tags>
        <tag>架构模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
    <content><![CDATA[<h2 id="IDEA编辑器集成maven环境"><a href="#IDEA编辑器集成maven环境" class="headerlink" title="IDEA编辑器集成maven环境"></a>IDEA编辑器集成maven环境</h2><p>###设置Maven版本</p>
<ul>
<li> 设置Maven版本–选择下载好的maven版本（⽬录选到bin⽬录的上⼀级⽬录）</li>
</ul>


 <img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven2.png" class>

<ul>
<li><p>设置settings.xml文件</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven3.png" class>

</li>
</ul>
<h3 id="Maven项目的创建"><a href="#Maven项目的创建" class="headerlink" title="Maven项目的创建"></a>Maven项目的创建</h3><ul>
<li><p>选择Maven,设置JDK版本，选择maven项目里的模板</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven4.png" class>
</li>
<li><p>设置项目里的GroupID和ArtifactID</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven5.png" class>
</li>
<li><p>检查项目的Maven环境</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven6.png" class>
</li>
<li><p>项目的目录结构</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven7.png" class>

</li>
</ul>
<p>###项目的编译</p>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven8.png" class>

<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven9.png" class>

<ul>
<li>执⾏编译命令，两个图标分别代表”普通模式”和”调试模式”</li>
</ul>
<img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven10.png" class>

<h3 id="创建WEB项目"><a href="#创建WEB项目" class="headerlink" title="创建WEB项目"></a>创建WEB项目</h3><p>创建web项目与创建普通Java项目步骤基本一致，区别在于选择Maven模板（WEB项目选择webapp)</p>
<h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><ul>
<li><p>修改相关版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- JDK的版本修改为1.8 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- junit的版本修改为4.12 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>删除pluginManagement标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将这个标签及标签中的内容全部删除 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>添加web部署的插件</p>
<p>1.jetty插件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置在plugins标签中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		 <span class="comment">&lt;!-- 热部署，每10秒扫描⼀次 --&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>10<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line">		 <span class="comment">&lt;!-- 可指定当前项⽬的站点名 --&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">connectors</span>&gt;</span></span><br><span class="line">			 &lt;connector</span><br><span class="line">implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt;</span><br><span class="line"> <span class="tag">&lt;<span class="name">port</span>&gt;</span>9090<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!-- 设置启动的端⼝号 --&gt;</span></span><br><span class="line"> 			 <span class="tag">&lt;/<span class="name">connector</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">connectors</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>  2.tomcat插件</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置在plugins标签中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">port</span>&gt;</span>8081<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!-- 启动端⼝ 默认:8080 --&gt;</span></span><br><span class="line"> 		 <span class="tag">&lt;<span class="name">path</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">path</span>&gt;</span> <span class="comment">&lt;!-- 项⽬的站点名，即对外访问路径 --&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span> <span class="comment">&lt;!-- 字符集编码 默认：ISO-8859-1 --&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">server</span>&gt;</span>tomcat7<span class="tag">&lt;/<span class="name">server</span>&gt;</span> <span class="comment">&lt;!-- 服务器名称 --&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
  <img data-src="/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/maven11.png" class>



<p>**maven依赖仓库：<a href="https://mvnrepository.com/">https://mvnrepository.com/</a> **</p>
]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2021/02/25/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
    <content><![CDATA[<h3 id="Maven仓库的基本概念"><a href="#Maven仓库的基本概念" class="headerlink" title="Maven仓库的基本概念"></a>Maven仓库的基本概念</h3><p> 当第⼀次运⾏Maven命令的时候， 你需要Internet链接， 因为它需要从⽹上下载⼀些⽂件。 那么它从 哪⾥下载呢？ 它是从Maven默认的远程库下载的。 这个远程仓库有Maven的核⼼插件和可供下载的jar⽂件。</p>
<p>对于Maven来说， 仓库只分为两类： 本地仓库和远程仓库。</p>
<p>当Maven根据坐标寻找构件的时候，它⾸先会查看本地仓库，如果本地仓库存在，则直接使⽤； 如果 本地没有，Maven就会去远程仓库查找，发现需要的构件之后，下载到本地仓库再使⽤。 如果本地仓库和远程仓库都没有，Maven就会报错。 </p>
<p>远程仓库分为三种： 中央仓库，私服， 其他公共库。</p>
<ul>
<li><p>中央仓库：默认配置下，Maven下载jar包的地⽅。</p>
<blockquote>
<p>由于原始的本地仓库是空的，maven必须知道⾄少⼀个可⽤的远程仓库，才能执⾏maven命令的时候 下载到需要的构件。中央仓库就是这样⼀个默认的远程仓库。 maven-model-builder-3.3.9.jar maven⾃动的 jar 中包含了⼀个 超级POM。定义了默认中央仓库的位 置。 中央仓库包含了2000多个开源项⽬，接收每天1亿次以上的访问</p>
</blockquote>
</li>
<li><p>私服：是另⼀种特殊的远程仓库，为了节省带宽和时间，应该在局域⽹内架设⼀个私有的仓库服务器， ⽤其代理所有外部的远程仓库。 内部的项⽬还能部署到私服上供其他项⽬使用</p>
<blockquote>
<p>私服是⼀种特殊的远程仓库，它是架设在局域⽹内的仓库服务， 私服代理⼴域⽹上的远程仓库，供局 域⽹内的maven⽤户使⽤。 当maven需要下载构件时， 它去私服当中找，如果私服没有， 则从外部远 程仓库下载，并缓存在私服上， 再为maven提供。 此外，⼀些⽆法从外部仓库下载的构件也能从本地上传到私服提供局域⽹中其他⼈使⽤</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">id</span>&gt;</span>public<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Public Repositories<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://192.168.0.96:8081/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>getui-nexus<span class="tag">&lt;/<span class="name">id</span>&gt;</span>       				<span class="tag">&lt;<span class="name">url</span>&gt;</span>http://mvn.gt.igexin.com/nexus/content/repositories/releases/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>公司内部为何需要建立私服：</p>
<blockquote>
<p>节省⾃⼰的外⽹带宽 加速maven构建 部署第三⽅控件 提⾼稳定性 降低中央仓库的负荷</p>
</blockquote>
<p>常用的阿里云仓库配置，需要修改settings.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>




<p>⼀般来说，在Maven项⽬⽬录下，没有诸如lib/这样⽤来存放依赖⽂件的⽬录。 当Maven在执⾏编译或 测试时，如果需要使⽤依赖⽂件，它总是基于坐标使⽤本地仓库的依赖⽂件。</p>
<p>每个⽤户在⾃⼰的⽤户⽬录下都有⼀个路径名为.m2/repository/的仓库⽬录。 有时候， 因为某些原因（⽐如c盘空间不⾜）,需要修改本地仓库⽬录地址。</p>
<p>对于仓库路径的修改，可以通过maven 配置⽂件conf ⽬录下settings.xml来指定仓库路径。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 设置到指定⽬录中，路径的斜杆不要写反 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>D:/m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="Maven依赖的基本概念"><a href="#Maven依赖的基本概念" class="headerlink" title="Maven依赖的基本概念"></a>Maven依赖的基本概念</h3><p>根元素project下的dependencies可以包含多个 dependence元素，以声明多个依赖。每个依赖都应该包含以下元素：</p>
<ol>
<li><p>groupId, artifactId, version : 依赖的基本坐标， 对于任何⼀个依赖来说，基本坐标是最重要的， Maven根据坐标才能找到需要的依赖。</p>
</li>
<li><p>Type： 依赖的类型，⼤部分情况下不需要声明。 默认值为jar</p>
</li>
<li><p>Scope： 依赖范围（compile,test,provided,runtime,system）</p>
</li>
</ol>
<blockquote>
<p>compile：编译依赖范围</p>
</blockquote>
<p>如果没有指定，就会默认使⽤该依赖范围。使⽤此依赖范围的Maven依赖，对于编译、测 试、运⾏三种classpath都有效。</p>
<blockquote>
<p>test：测试依赖范围</p>
</blockquote>
<p>使⽤此依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运⾏项⽬的使 ⽤时将⽆法使⽤此类依赖。典型的例⼦就是JUnit，它只有在编译测试代码及运⾏测试的时候才需要</p>
<blockquote>
<p>provided：已提供依赖范围</p>
</blockquote>
<p>使⽤此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运⾏时⽆效。典型的例 ⼦是servlet-api，编译和测试项⽬的时候需要该依赖，但在运⾏项⽬的时候，由于容器已经提供，就不需要Maven重复地引⼊⼀遍(如：servlet-api)。</p>
<blockquote>
<p>runtime：运行时依赖范围</p>
</blockquote>
<p>使⽤此依赖范围的Maven依赖，对于测试和运⾏classpath有效，但在编译主代码时⽆效。典 型的例⼦是JDBC驱动实现，项⽬主代码的编译只需要JDK提供的JDBC接⼝，只有在执⾏测 试或者运⾏项⽬的时候才需要实现上述接⼝的具体JDBC驱动。</p>
<blockquote>
<p>system：系统依赖范围</p>
</blockquote>
<p>该依赖与三种classpath的关系，和provided依赖范围完全⼀致。但是，使⽤system范围依赖 时必须通过systemPath元素显式地指定依赖⽂件的路径。由于此类依赖不是通过Maven仓库 解析的，⽽且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使⽤。</p>
<ol start="4">
<li><p>Optional：标记依赖是否可选</p>
</li>
<li><p>Exclusions： ⽤来排除传递性依赖。</p>
</li>
</ol>
<h3 id="Maven依赖的依赖范围"><a href="#Maven依赖的依赖范围" class="headerlink" title="Maven依赖的依赖范围"></a>Maven依赖的依赖范围</h3><p>⾸先需要知道，Maven在编译项⽬主代码的时候需要使⽤⼀套classpath。 ⽐如：编译项⽬代码的时候 需要⽤到spring-core, 该⽂件以依赖的⽅式被引⼊到classpath中。 其次， Maven在执⾏测试的时候会使 ⽤另外⼀套classpath。 如：junit。</p>
<p>最后在实际运⾏项⽬时，⼜会使⽤⼀套classpath， spring-core需要在该classpath中，⽽junit不需要。</p>
<p>那么依赖范围就是⽤来控制依赖与这三种classpath(编译classpath，测试classpath，运⾏时classpath)的 关系， Maven有以下⼏种依赖范围：<strong>（如上所述）</strong></p>
<h3 id="传递性依赖"><a href="#传递性依赖" class="headerlink" title="传递性依赖"></a>传递性依赖</h3><p>传递依赖机制， 让我们在使⽤某个jar的时候就不⽤去考虑它依赖了什么。也不⽤担⼼引⼊多余的依 赖。 Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引⼊到当前项⽬中。</p>
<p><strong>注意：传递依赖有可能产生冲突</strong></p>
<p>冲突场景”</p>
<blockquote>
<p>A–&gt;B—&gt;C (2.0) </p>
<p>A–&gt;E—&gt;C (1.0)</p>
</blockquote>
<p>如果A下同时存在两个不同version的C，冲突！！（选取同时适合A、B的版本）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>A<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>C<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>B<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记&lt;一&gt;</title>
    <url>/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Maven的简介"><a href="#Maven的简介" class="headerlink" title="Maven的简介"></a>Maven的简介</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p> Maven【[ˈmevən]】这个词可以翻译为”专家”,”内⾏”。 作为Apache组织中的⼀个颇为成功的开源项⽬， Maven主要服务于基于java平台的项⽬构建，依赖管理和项⽬信息管理。 ⽆论是⼩型的开源类库项⽬，还是⼤型的企业级应⽤； ⽆论是传统的瀑布式开发，还是流⾏的敏捷开 发，Maven都能⼤显身⼿。</p>
<p>###项目构建</p>
<p>不管你是否意识到，构建（build）是每⼀位程序员每天都在做的⼯作。早上来到公司，我们做的第⼀ 件事就是从源码库签出最新的代码，然后进⾏单元测试，如果测试失败，会找相关的同事⼀起调试修复错误代码。 接着回到⾃⼰的⼯作上来，编写⾃⼰的单元测试及产品代码。</p>
<p>我们会发现，除了编写源代码，我们每天有相当⼀部分时间花在了编译，运⾏单元测 试，⽣成⽂档，打包和部署等繁琐且不起眼的⼯作上，这就是构建。 如果我们现在还⼿⼯这样做，那成 本也太⾼了，于是有⼈⽤软件的⽅法让这⼀系列⼯作完全⾃动化，使得软件的构建可以像全⾃动流⽔线 ⼀样，只需要⼀条简单的命令，w所有繁琐的步骤都能够⾃动完成，很快就能得到最终结果。</p>
<p>###项目构建工具</p>
<blockquote>
<p>Ant构建</p>
</blockquote>
<p>最早的构建⼯具，基于IDE, ⼤概是2000年有的，当时是最流⾏java构建⼯具，不过它的XML脚本编写格式让XML⽂件特别⼤。对⼯程构建过程中的过程控制特别好。</p>
<blockquote>
<p>Maven【Java】</p>
</blockquote>
<p>项⽬对象模型，通过其描述信息来管理项⽬的构建，报告和⽂档的软件项⽬管理⼯具。它填补了Ant缺 点，Maven第⼀次⽀持了从⽹络上下载的功能，仍然采⽤xml作为配置⽂件格式。Maven专注的是依赖管理，使⽤Java编写。</p>
<blockquote>
<p>Gradle</p>
</blockquote>
<p>属于结合以上两个的优点，它继承了Ant的灵活和Maven的⽣命周期管理，它最后被google作为了 Android御⽤管理⼯具。它最⼤的区别是不⽤XML作为配置⽂件格式，采⽤了DSL格式，使得脚本更加简洁。 ⽬前市⾯上Ant⽐较⽼, 所以⼀般是⼀些⽐较传统的软件企业公司使⽤, Maven使⽤Java编写, 是当下⼤多数互联⽹公司会使⽤的⼀个构建⼯具, 中⽂⽂档也⽐较⻬全, gradle是⽤groovy编写, ⽬前⽐较新型的构建⼯具⼀些初创互联⽹公司会使⽤, 以后会有很⼤的使⽤空间。</p>
<h3 id="Maven的四大特性"><a href="#Maven的四大特性" class="headerlink" title="Maven的四大特性"></a>Maven的四大特性</h3><h4 id="依赖管理系统"><a href="#依赖管理系统" class="headerlink" title="依赖管理系统"></a>依赖管理系统</h4><p> Maven为Java世界引⼊了⼀个新的依赖管理系统jar包管理 jar 升级时修改配置⽂件即可。在Java世界中，可以⽤<strong>groupId、artifactId、version</strong>组成的Coordination（坐标）<u>唯⼀标识⼀个依赖。</u></p>
<p>任何基于Maven构建的项⽬⾃身也必须定义这三项属性，⽣成的包可以是Jar包，也可以是war包或者 jar包。⼀个典型的依赖引⽤如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> com.baidu</span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> ueditor echarts</span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>坐标属性的理解</p>
</blockquote>
<ul>
<li><strong>groupId</strong></li>
</ul>
<p>定义当前Maven项⽬⾪属的实际项⽬-公司名称。(jar包所在仓库路径） 由于Maven中模块的概念，因 此⼀个实际项⽬往往会被划分为很多模块。 ⽐如spring是⼀个实际项⽬，其对应的Maven模块会有很 多，如spring-core,spring-webmvc等。</p>
<ul>
<li><strong>artifactId</strong></li>
</ul>
<p>该元素定义实际项⽬中的⼀个Maven模块-项⽬名， 推荐的做法是使⽤实际项⽬名称作为artifactId的前 缀。 ⽐如： spring-bean, spring-webmvc等。</p>
<ul>
<li><strong>version</strong></li>
</ul>
<p>该元素定义Maven当前所处的版本</p>
<h4 id="项目的多模块构建"><a href="#项目的多模块构建" class="headerlink" title="项目的多模块构建"></a>项目的多模块构建</h4><p>项⽬复查时 dao service controller 层分离将⼀个项⽬分解为多个模块已经是很通⽤的⼀种⽅式。 在Maven中需要定义⼀个parent POM作为⼀组module的聚合POM。在该POM中可以使⽤ 标签来定义⼀ 组⼦模块。parent POM不会有什么实际构建产出。⽽parent POM中的build配置以及依赖配置都会⾃动继承给⼦module。</p>
<h4 id="一致的构建模型和插件机制"><a href="#一致的构建模型和插件机制" class="headerlink" title="一致的构建模型和插件机制"></a>一致的构建模型和插件机制</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mortbay.jetty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jetty-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.1.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scanIntervalSeconds</span>&gt;</span>10<span class="tag">&lt;/<span class="name">scanIntervalSeconds</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">contextPath</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">contextPath</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="Maven的安装配置和目录结构"><a href="#Maven的安装配置和目录结构" class="headerlink" title="Maven的安装配置和目录结构"></a>Maven的安装配置和目录结构</h2><h3 id="Maven的安装与配置"><a href="#Maven的安装与配置" class="headerlink" title="Maven的安装与配置"></a>Maven的安装与配置</h3><img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/createmaven.png" class>

<p>打开cmd窗口，通过命令查看maven是否安装成功</p>
<img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/maventest.png" class>

<h3 id="认识Maven的目录结构"><a href="#认识Maven的目录结构" class="headerlink" title="认识Maven的目录结构"></a>认识Maven的目录结构</h3> <img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mulu.png" class>

<h4 id="创建一个文件夹作为项目的根目录"><a href="#创建一个文件夹作为项目的根目录" class="headerlink" title="创建一个文件夹作为项目的根目录"></a>创建一个文件夹作为项目的根目录</h4><ul>
<li><p>在根目录中创建一个pom.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string"> http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xxxx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven01<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>maven01<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<p><strong>PS:标签定义解释</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">根⽬录下的第⼀个⼦元素 ModelVersion指定当前Pom模型的版本，对于Maven3来说，它只能是4.0.0 。指定了当前Maven模型的版本号，对于Maven2和Maven3来说，它只能是4.0.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">groupId:定义了项目属于哪一个组，这个组通常和项目所在的组织和公司存在关联</span></span><br><span class="line"><span class="comment">比如：com.xxxx</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">artifactId 定义了当前Maven项⽬在组中唯⼀的ID。</span></span><br><span class="line"><span class="comment">Version X.X.X-⾥程碑</span></span><br><span class="line"><span class="comment">⽐如：1.0.0-SNAPSHOT</span></span><br><span class="line"><span class="comment">第⼀个X ⼤版本 有重⼤变⾰</span></span><br><span class="line"><span class="comment">第⼆个X ⼩版本 修复bug，增加功能</span></span><br><span class="line"><span class="comment">第三个X 更新</span></span><br><span class="line"><span class="comment">⾥程碑版本：</span></span><br><span class="line"><span class="comment">SNAPSHOT （快照，开发版）</span></span><br><span class="line"><span class="comment">alpha（内部测试）</span></span><br><span class="line"><span class="comment">beta（公开测试）</span></span><br><span class="line"><span class="comment">Release | RC（ 发布版）</span></span><br><span class="line"><span class="comment">GA（正常版本）</span></span><br><span class="line"><span class="comment">使⽤name标签声明⼀个对于⽤户更为友好的项⽬名称，虽然不是必须的，但还是推荐为每个Pom声明name，以⽅便信息交流。</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>


<h4 id="编写主函数"><a href="#编写主函数" class="headerlink" title="编写主函数"></a>编写主函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xxxx.demo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> System.out.println(<span class="string">&quot;hello maven&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="cmd下编译并且运行"><a href="#cmd下编译并且运行" class="headerlink" title="cmd下编译并且运行"></a>cmd下编译并且运行</h4><p>cmd下面，进入项目根目录</p>
<p>1.编译Java文件</p>
<p>mvn compile</p>
<p>2.执行main方法</p>
<p>mvn exec:java -Dexec.mainClass=”com.xxxx.demo.hello”</p>
<img data-src="/2021/02/06/Maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/mavencreate.png" class>

<p><strong>注：第⼀次下载会⽐较慢，要修改maven解压之后的conf⽬录下的settings.xml。</strong></p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1.1.修改默认仓库位置</span><br><span class="line">打开maven⽬录 -&gt; conf -&gt; settings.xml</span><br><span class="line">添加仓库位置配置</span><br><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>F:/m2/repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br><span class="line">注：仓库位置改为⾃⼰本机的指定⽬录，&quot;/&quot;不要写反</span><br><span class="line">1.2.更换阿⾥镜像,加快依赖下载</span><br><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果编译不成功，可能出现的问题</p>
<blockquote>
<p>1.不是使用管理员权限执行的dos命令</p>
</blockquote>
<blockquote>
<p>2.JDK环境配置有问题，重装JDK</p>
</blockquote>
<blockquote>
<p>3.代码编写时，类里面没有设置包名</p>
</blockquote>
<p>##Maven命令</p>
<p>作为开发利器的maven，为我们提供了⼗分丰富的命令，了解maven的命令⾏操作并熟练运⽤常⻅的 maven命令还是⼗分必要的，即使譬如IDEA等⼯具给我提供了图形界⾯化⼯具，但其底层还是依靠 maven命令来驱动的。</p>
<p>Maven的命令格式如下：</p>
<blockquote>
<p>maven [plugin-name] : [goal-name]</p>
</blockquote>
<p>命令代表的含义：执⾏ plugin-name 插件的 goal-name ⽬标</p>
<table>
<thead>
<tr>
<th align="left">maven命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mvn clean</td>
<td>清理项⽬⽣产的临时⽂件,⼀般是模块下的target⽬录</td>
</tr>
<tr>
<td align="left">mvn compile</td>
<td>编译源代码，⼀般编译模块下的src/main/java⽬录</td>
</tr>
<tr>
<td align="left">mvn package</td>
<td>项⽬打包⼯具,会在模块下的target⽬录⽣成jar或war等⽂件</td>
</tr>
<tr>
<td align="left">mvn test</td>
<td>测试命令,或执⾏src/test/java/下junit的测试⽤例</td>
</tr>
<tr>
<td align="left">mvn -version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td align="left">mvn install</td>
<td>将打包的jar/war⽂件复制到你的本地仓库中,供其他模块使⽤</td>
</tr>
<tr>
<td align="left">mvn deploy</td>
<td>将打包的⽂件发布到远程参考,提供其他⼈员进⾏下载依赖</td>
</tr>
<tr>
<td align="left">mvn site</td>
<td>生成项目相关信息的网站</td>
</tr>
<tr>
<td align="left">mvn eclipse:eclipse</td>
<td>将项目转换为Eclipse项目</td>
</tr>
<tr>
<td align="left">mvn dependency:tree</td>
<td>打印出整个项目的依赖树</td>
</tr>
<tr>
<td align="left">mvn archetype:generate</td>
<td>创建maven的普通Java项目</td>
</tr>
<tr>
<td align="left">mvn tomcat:run</td>
<td>在tomcat容器中运行web应用</td>
</tr>
<tr>
<td align="left">mvn jetty:run</td>
<td>调用jetty插件的Run目标在jetty servlet容器中启动web应用</td>
</tr>
</tbody></table>
<p>注意：运⾏maven命令的时候，⾸先需要定位到maven项⽬的⽬录，也就是项⽬的pom.xml⽂件所在的⽬录。否则， 必以通过参数来指定项⽬的⽬录。</p>
<h3 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h3><p>上⾯列举的只是⽐较通⽤的命令，其实很多命令都可以携带参数以执⾏更精准的任务。</p>
<h4 id="D传入属性参数"><a href="#D传入属性参数" class="headerlink" title="-D传入属性参数"></a>-D传入属性参数</h4><p>例如： </p>
<blockquote>
<p>mvn package -Dmaven.test.skip=true </p>
</blockquote>
<p>以 -D 开头，将 maven.test.skip 的值设为 true ,就是告诉maven打包的时候跳过单元测试。同 理， mvn deploy-Dmaven.test.skip=true 代表部署项⽬并跳过单元测试。</p>
<h4 id="P使用指定的Profile配置"><a href="#P使用指定的Profile配置" class="headerlink" title="-P使用指定的Profile配置"></a>-P使用指定的Profile配置</h4><p>⽐如项⽬开发需要有多个环境，⼀般为开发，测试，预发，正式4个环境，在pom.xml中的配置如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">env</span>&gt;</span>dev<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span>&gt;</span>qa<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">env</span>&gt;</span>qa<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span>&gt;</span>pre<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">env</span>&gt;</span>pre<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">id</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">env</span>&gt;</span>prod<span class="tag">&lt;/<span class="name">env</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line">......</span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">filters</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">filter</span>&gt;</span>config/$&#123;env&#125;.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> 	 <span class="tag">&lt;/<span class="name">filters</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line"> 			<span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"> ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>profiles 定义了各个环境的变量 id ， filters 中定义了变量配置⽂件的地址，其中地址中的环境 变量就是上⾯ profile 中定义的值， resources 中是定义哪些⽬录下的⽂件会被配置⽂件中定义的变量替换。 通过maven可以实现按不同环境进⾏打包部署，例如：</p>
<blockquote>
<p>mvn package -Pdev -Dmaven.test.skip=true</p>
</blockquote>
]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis动态代理与传参</title>
    <url>/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<h2 id="Mybatis动态代理实现CURD"><a href="#Mybatis动态代理实现CURD" class="headerlink" title="Mybatis动态代理实现CURD"></a>Mybatis动态代理实现CURD</h2><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><blockquote>
<p>去掉Dao接口的实现类</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/01.png" class>

<blockquote>
<p>getMapper获取代理对象</p>
</blockquote>
<p>只需调用 SqlSession 的 getMapper()方法，即可获取指定接口的实现类对象。该方法的参数为指定 Dao 接口类的 class 值。(<strong>反射原理</strong>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSession session = factory.openSession();</span><br><span class="line">StudentDao dao = session.getMapper(StudentDao.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用工具类获取session</span></span><br><span class="line">StudentDao studentDao =</span><br><span class="line">MyBatisUtil.getSqlSession().getMapper(StudentDao.class);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>使用Dao代理对象方法执行SQL语句</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//s所有的方法必须都在StudentDao接口中有所定义</span></span><br><span class="line"><span class="comment">//select 方法:</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> List&lt;Student&gt; studentList = studentDao.selectStudents();</span><br><span class="line">     studentList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert 方法:</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1006</span>);</span><br><span class="line">     student.setName(<span class="string">&quot;林浩&quot;</span>);</span><br><span class="line">     student.setEmail(<span class="string">&quot;linhao@163.com&quot;</span>);</span><br><span class="line">     student.setAge(<span class="number">26</span>);</span><br><span class="line">     <span class="keyword">int</span> nums = studentDao.insertStudent(student);</span><br><span class="line">     System.out.println(<span class="string">&quot;使用 Dao 添加数据:&quot;</span>+nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//update 方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1006</span>);</span><br><span class="line">     student.setAge(<span class="number">28</span>);</span><br><span class="line">     <span class="keyword">int</span> nums = studentDao.updateStudent(student);</span><br><span class="line">     System.out.println(<span class="string">&quot;使用 Dao 修改数据:&quot;</span>+nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//delete 方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> nums = studentDao.deleteStudent(<span class="number">1006</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;使用 Dao 修改数据:&quot;</span>+nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="基于动态代理的原理分析"><a href="#基于动态代理的原理分析" class="headerlink" title="基于动态代理的原理分析"></a>基于动态代理的原理分析</h4><img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/02.png" class>



<blockquote>
<p>MapperProxy类定义</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/03.png" class>

<blockquote>
<p>invoke方法</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/04.png" class>



<blockquote>
<p>重点方法</p>
</blockquote>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/05.png" class>





<h2 id="深入理解参数"><a href="#深入理解参数" class="headerlink" title="深入理解参数"></a>深入理解参数</h2><blockquote>
<p>parameterType</p>
</blockquote>
<p>parameterType: 接口中方法参数的类型， 值是类型的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以推断出具体传入语句的参数，默认值为未设置（unset）。接口中方法的参数从 java 代码传入到 mapper 文件的 sql 语句。</p>
<p>支持传入参数的类型与别名映射如表所示：</p>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/06.png" class>



<p> <select>、<insert>、<update>、<delete>都可以使用parameterType指定类型</delete></update></insert></select></p>
  <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/07.png" class>



<h3 id="Mybatis传递参数"><a href="#Mybatis传递参数" class="headerlink" title="Mybatis传递参数"></a>Mybatis传递参数</h3><h4 id="一个简单参数"><a href="#一个简单参数" class="headerlink" title="一个简单参数"></a>一个简单参数</h4><p>Dao 接口中方法的参数只有一个简单类型（java 基本类型和 String），占位符 #{ 任意字符 }，和方法的参数名无关。</p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectById&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line"> select id,name,email,age from student where id=#&#123;studentId&#125;</span><br><span class="line">&lt;/select&gt;</span><br><span class="line">#&#123;studentId&#125; , studentId 是自定义的变量名称，和方法参数名无关。#表示占位符</span><br></pre></td></tr></table></figure>


<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//传入了一个参数</span></span><br><span class="line">    Student student = studentDao.selectById(<span class="number">1005</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;查询 id 是 1005 的学生：&quot;</span>+student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="多个参数"><a href="#多个参数" class="headerlink" title="多个参数"></a>多个参数</h3><h4 id="使用-Param"><a href="#使用-Param" class="headerlink" title="使用@Param"></a>使用@Param</h4><p>当 Dao 接口方法多个参数，需要通过名称使用参数。在方法形参前面加入@Param(“自定义参数名”)， mapper 文件使用#{自定义参数名}。</p>
<ul>
<li>接口方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List <span class="title">selectMultiParam</span><span class="params">(<span class="meta">@Param(&quot;personName&quot;)</span> String name, <span class="meta">@Param(&quot;personAge&quot;)</span> <span class="keyword">int</span> age)</span></span>; </span><br></pre></td></tr></table></figure>


<ul>
<li><p>mapper 文件： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">select id,name,email,age from student where name=#&#123;personName&#125; or age =#&#123;personAge&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectMultiParam</span><span class="params">()</span></span>&#123; </span><br><span class="line">    List stuList = studentDao.selectMultiParam(<span class="string">&quot;李力&quot;</span>,<span class="number">20</span>); 					stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="多个参数–适用对象"><a href="#多个参数–适用对象" class="headerlink" title="多个参数–适用对象"></a>多个参数–适用对象</h4><p>使用 java 对象传递参数， java 的属性值就是 sql 需要的参数值。 每一个属性就是一个参数。 语法格式： #{ property,javaType=java 中数据类型名,jdbcType=数据类型名称 } javaType, jdbcType 的类型 MyBatis 可以检测出来，一般不需要设置。常用格式 #{ property }</p>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/08.png" class>

<blockquote>
<p>创建保存参数值的对象QueryParam</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.vo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryParam</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String queryName;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> queryAge;</span><br><span class="line"> <span class="comment">//set ，get 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectMultiObject</span><span class="params">(QueryParam queryParam)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件—-必须保证和对象的属性名相同</p>
</blockquote>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectMultiObject&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line"> select id,name,email,age from student where name=#&#123;queryName&#125; or age=#&#123;queryAge&#125;</span><br><span class="line">&lt;/select</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectMultiObject&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line"> select id,name,email,age from student</span><br><span class="line"> where name=#&#123;queryName,javaType=string,jdbcType=VARCHAR&#125;</span><br><span class="line"> or age =#&#123;queryAge,javaType=int,jdbcType=INTEGER&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectMultiObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam qp = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     qp.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     qp.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectMultiObject(qp);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="多个参数–按照位置"><a href="#多个参数–按照位置" class="headerlink" title="多个参数–按照位置"></a>多个参数–按照位置</h4><p>参数位置从 0 开始， 引用参数语法 #{ arg 位置 } ， 第一个参数是#{arg0}, 第二个是#{arg1} 注意：mybatis-3.3 版本和之前的版本使用#{0},#{1}方式， 从 mybatis3.4 开始使用#{arg0}方式&gt;。</p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectByNameAndAge</span><span class="params">(String name,<span class="keyword">int</span> age)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectByNameAndAge&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">	 select id,name,email,age from student where name=#&#123;arg0&#125; or age =#&#123;arg1&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectByNameAndAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="comment">//按位置参数</span></span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectByNameAndAge(<span class="string">&quot;李力&quot;</span>,<span class="number">20</span>);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="多个参数–使用Map"><a href="#多个参数–使用Map" class="headerlink" title="多个参数–使用Map"></a>多个参数–使用Map</h4><p>Map 集合可以存储多个值，使用Map向 mapper 文件一次传入多个参数。Map 集合使用 String的 key， Object 类型的值存储参数。 mapper 文件使用 # { key } 引用参数值。</p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectMultiMap</span><span class="params">(Map&lt;String,Object&gt; map)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectMultiMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">	 select id,name,email,age from student where name=#&#123;myname&#125; or age =#&#123;myage&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">//通过key来传递参数</span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectMultiMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Map&lt;String,Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">     data.put(<span class="string">&quot;myname&quot;</span>,<span class="string">&quot;李力&quot;</span>);<span class="comment">// #&#123;myname&#125;</span></span><br><span class="line">     data.put(<span class="string">&quot;myage&quot;</span>,<span class="number">20</span>); <span class="comment">// #&#123;myage&#125;</span></span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectMultiMap(data);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存储参数的类型是Object</span></span><br></pre></td></tr></table></figure>


<h3 id="占位符-和"><a href="#占位符-和" class="headerlink" title="占位符#和$"></a>占位符#和$</h3><h4 id><a href="#" class="headerlink" title></a></h4><p>#：占位符，告诉 mybatis 使用实际的参数值代替。并使用 PrepareStatement 对象执行 sql 语句, #{…}代替 sql 语句的“?”。这样做更安全，更迅速，通常也是首选做法，</p>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">	 select id,name,email,age from student where id=#&#123;studentId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>转换为Mybatis的执行是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">String <span class="keyword">sql</span><span class="operator">=</span>” <span class="keyword">select</span> id,name,email,age <span class="keyword">from</span> student <span class="keyword">where</span> id<span class="operator">=</span>?”;</span><br><span class="line">PreparedStatement ps <span class="operator">=</span> conn.prepareStatement(<span class="keyword">sql</span>);</span><br><span class="line">ps.setInt(<span class="number">1</span>,<span class="number">1005</span>);</span><br></pre></td></tr></table></figure>


<h4 id="-1"><a href="#-1" class="headerlink" title="$"></a>$</h4><p> $ 字符串替换，告诉 mybatis 使用$包含的“字符串”替换所在位置。使用 Statement 把 sql 语句和${}的 内容连接起来。主要用在替换表名，列名，不同列排序等操作。</p>
<p><strong>因为存在拼接的操作，所以可能会存在SQL注入的安全隐患</strong></p>
 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/09.png" class>

 <img data-src="/2021/03/13/Mybatis%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/10.png" class>











]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架</title>
    <url>/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6-1/</url>
    <content><![CDATA[<h2 id="Mybatis入门案例"><a href="#Mybatis入门案例" class="headerlink" title="Mybatis入门案例"></a>Mybatis入门案例</h2><h3 id="搭建Mybatis开发环境–基础CRUD操作实例"><a href="#搭建Mybatis开发环境–基础CRUD操作实例" class="headerlink" title="搭建Mybatis开发环境–基础CRUD操作实例"></a>搭建Mybatis开发环境–基础CRUD操作实例</h3><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><blockquote>
<p>创建MySQL数据库和表</p>
</blockquote>
<img data-src="/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6-1/01.png" class>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` (</span><br><span class="line"> `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line"> `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `email` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> <span class="keyword">PRIMARY</span> <span class="keyword">KEY</span> (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建Maven工程，并且在pom.xml中加入maven坐标</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     	<span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   	 	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>加入maven插件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span><span class="comment">&lt;!--所在的目录--&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">includes</span>&gt;</span><span class="comment">&lt;!--包括目录下的.properties,.xml 文件都会扫描到--&gt;</span></span><br><span class="line"> 			 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> 		<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span> </span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">			 <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">		 <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>/&gt;</span> </span><br></pre></td></tr></table></figure>


<blockquote>
<p>编写Student实体类</p>
</blockquote>
<p>创建包com.bytedance.domain,包中创建Student类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.domain;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Description: 实体类 &lt;/p&gt;</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Company: http://www.bjpowernode.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"> <span class="comment">//属性名和列名一样</span></span><br><span class="line">     <span class="keyword">private</span> Integer id;</span><br><span class="line">     <span class="keyword">private</span> String name;</span><br><span class="line">     <span class="keyword">private</span> String email;</span><br><span class="line">     <span class="keyword">private</span> Integer age;</span><br><span class="line">     <span class="comment">// set ,get , toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写Dao接口 StudentDao</p>
</blockquote>
<p>创建包com.bytedance.dao,创建StudentDao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.dao;</span><br><span class="line"><span class="keyword">import</span> com.bjpowernode.domain.Student;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Description: Dao 接口 &lt;/p&gt;</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Company: http://www.bjpowernode.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">	 <span class="comment">/*查询所有数据*/</span></span><br><span class="line">	 <span class="function">List&lt;Student&gt; <span class="title">selectStudents</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>编写Dao接口Mapper映射文件StudentDao.xml</p>
<p>要求：</p>
<ul>
<li> 在 dao 包中创建文件 StudentDao.xml </li>
<li>要 StudentDao.xml 文件名称和接口 StudentDao 一样，区分大小写的一样</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">     <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">     <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">     namespace：必须有值，自定义的唯一字符串</span></span><br><span class="line"><span class="comment">     推荐使用：dao 接口的全限定名称</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.bytedance.dao.StudentDao&quot;</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment"> 		&lt;select&gt;: 查询数据， 标签中必须是 select 语句</span></span><br><span class="line"><span class="comment"> 			id: sql 语句的自定义名称，推荐使用 dao 接口中方法名称，使用名称表示要执行的 sql 语句</span></span><br><span class="line"><span class="comment"> 		resultType: 查询语句的返回结果数据类型，使用全限定类名</span></span><br><span class="line"><span class="comment"> --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectStudents&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.bytedance.domain.Student&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--要执行的 sql 语句--&gt;</span></span><br><span class="line">         select id,name,email,age from student</span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建Mybatis主配置文件</p>
</blockquote>
<p>项目 src/main 下创建 resources 目录，设置 resources 目录为 resources root 创建主配置文件：名称为 mybatis.xml 说明：主配置文件名称是自定义的，内容如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">     <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">     <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> 	<span class="comment">&lt;!--配置 mybatis 环境--&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--id:数据源的名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务类型：使用 JDBC 事务（使用 Connection 的提交和回滚）--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据源 dataSource：创建数据库 Connection 对象</span></span><br><span class="line"><span class="comment">        type: POOLED 使用数据库的连接池</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--连接数据库的四个要素--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssm&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">	 <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--告诉 mybatis 要执行的 sql 语句的位置--&gt;</span></span><br><span class="line">	 <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/bytedance/dao/StudentDao.xml&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建测试类</p>
</blockquote>
<p> src/test/java/com/bytedance/ 创建 MyBatisTest.java 文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* mybatis 入门</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testStart</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象,目的是获取 SqlSession</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession,SqlSession 能执行 sql 语句</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.执行 SqlSession 的 selectList()</span></span><br><span class="line">     List&lt;Student&gt; studentList = 	session.selectList(<span class="string">&quot;com.bytedance.dao.StudentDao.selectStudents&quot;</span>);</span><br><span class="line">    <span class="comment">//6.循环输出查询结果</span></span><br><span class="line">	 studentList.forEach( student -&gt; System.out.println(student));</span><br><span class="line"> 	<span class="comment">//7.关闭 SqlSession，释放资源</span></span><br><span class="line">	 session.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>配置日志功能</p>
</blockquote>
<p>mybatis.xml 文件加入日志配置，可以在控制台输出执行的 sql 语句和参数</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;logImpl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;STDOUT_LOGGING&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><ul>
<li><p>StudentDao 接口中增加方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int insertStudent(Student student);</span><br></pre></td></tr></table></figure></li>
<li><p>StudentDao.xml中加入SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">（<span class="number">2</span>） StudentDao.xml 加入 <span class="keyword">sql</span> 语句</span><br><span class="line"><span class="operator">&lt;</span><span class="keyword">insert</span> id<span class="operator">=</span>&quot;insertStudent&quot;<span class="operator">&gt;</span></span><br><span class="line"> 	<span class="keyword">insert</span> <span class="keyword">into</span> student(id,name,email,age)</span><br><span class="line">	values(#&#123;id&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;age&#125;)</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">insert</span><span class="operator">&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>增加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.创建保存数据的对象</span></span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1005</span>);</span><br><span class="line">     student.setName(<span class="string">&quot;张丽&quot;</span>);</span><br><span class="line">     student.setEmail(<span class="string">&quot;zhangli@163.com&quot;</span>);</span><br><span class="line">     student.setAge(<span class="number">20</span>);</span><br><span class="line">     <span class="comment">//6.执行插入 insert</span></span><br><span class="line">     <span class="keyword">int</span> rows = session.insert(</span><br><span class="line">    <span class="string">&quot;com.bytedance.dao.StudentDao.insertStudent&quot;</span>,student);</span><br><span class="line">     <span class="comment">//7.提交事务</span></span><br><span class="line">     session.commit();</span><br><span class="line">     System.out.println(<span class="string">&quot;增加记录的行数:&quot;</span>+rows);</span><br><span class="line">     <span class="comment">//8.关闭 SqlSession</span></span><br><span class="line">     session.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><ul>
<li><p>StudentDao接口中增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">updateStudent</span><span class="params">(Student student)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>StudentDao.xml文件中增加SQL语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">&lt;</span><span class="keyword">update</span> id<span class="operator">=</span>&quot;updateStudent&quot;<span class="operator">&gt;</span></span><br><span class="line"> 	update student set age = #&#123;age&#125; where id=#&#123;id&#125;</span><br><span class="line"><span class="operator">&lt;</span><span class="operator">/</span><span class="keyword">update</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>增加测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.创建保存数据的对象</span></span><br><span class="line">     Student student = <span class="keyword">new</span> Student();</span><br><span class="line">     student.setId(<span class="number">1005</span>);<span class="comment">//要修改的 id</span></span><br><span class="line">     student.setAge(<span class="number">30</span>); <span class="comment">//要修改的年龄值</span></span><br><span class="line">     <span class="comment">//6.执行更新 update</span></span><br><span class="line">     <span class="keyword">int</span> rows = session.update(</span><br><span class="line">    <span class="string">&quot;com.bytedance.dao.StudentDao.updateStudent&quot;</span>,student);</span><br><span class="line">     <span class="comment">//7.提交事务</span></span><br><span class="line">     session.commit();</span><br><span class="line">     System.out.println(<span class="string">&quot;修改记录的行数:&quot;</span>+rows);</span><br><span class="line">     <span class="comment">//8.关闭 SqlSession</span></span><br><span class="line">     session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><ul>
<li><p>StudentDao接口中增加方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteStudent</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>StudentDao.xml文件中增加SQL语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;deleteStudent&quot;</span>&gt;</span></span><br><span class="line"> delete from student where id=#&#123;studentId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>增加测试方法</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="comment">//1.mybatis 主配置文件</span></span><br><span class="line">     String config = <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line">     <span class="comment">//2.读取配置文件</span></span><br><span class="line">     InputStream in = Resources.getResourceAsStream(config);</span><br><span class="line">     <span class="comment">//3.创建 SqlSessionFactory 对象</span></span><br><span class="line">     SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">     <span class="comment">//4.获取 SqlSession</span></span><br><span class="line">     SqlSession session = factory.openSession();</span><br><span class="line">     <span class="comment">//5.删除的 id</span></span><br><span class="line">     <span class="keyword">int</span> id = <span class="number">1001</span>;</span><br><span class="line">     <span class="comment">//6.执行删除 delete</span></span><br><span class="line">     <span class="keyword">int</span> rows = session.delete(</span><br><span class="line">    <span class="string">&quot;com.bytedance.dao.StudentDao.deleteStudent&quot;</span>,id);</span><br><span class="line">     <span class="comment">//7.提交事务</span></span><br><span class="line">     session.commit();</span><br><span class="line">     System.out.println(<span class="string">&quot;修改记录的行数:&quot;</span>+rows);</span><br><span class="line">    <span class="comment">//8.关闭SqlSession</span></span><br><span class="line">    session.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis框架概述</title>
    <url>/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h2 id="软件开发常用结构"><a href="#软件开发常用结构" class="headerlink" title="软件开发常用结构"></a>软件开发常用结构</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>三层架构包含的三层： 界面层（User Interface layer）、业务逻辑层（Business Logic Layer）、数据访问层（Data access layer）</p>
<blockquote>
<p>三层的职责</p>
</blockquote>
<ul>
<li><p>1、界面层（表示层\视图层）：主要功能是接受用户的数据，显示请求的处理结果。使用 web 页面和 用户交互，手机 app 也就是表示层的，用户在 app 中操作，业务逻辑在服务器端处理。</p>
</li>
<li><p>2、业务逻辑层：接收表示传递过来的数据，检查数据，计算业务逻辑，调用数据访问层获取数据。</p>
</li>
<li><p>3、数据访问层（持久层）：与数据库打交道。主要实现对数据的增、删、改、查。将存储在数据库中的数据提交 给业务层，同时将业务层处理的数据保存到数据库。</p>
</li>
</ul>
<p>三层的处理请求的交互：</p>
<p>用户—&gt;界面层—&gt;业务逻辑层—&gt;数据访问层—&gt;DB数据库</p>
 <img data-src="/2021/02/25/Mybatis%E6%A1%86%E6%9E%B6/01.png" class>



<blockquote>
<p>为什么使用三层？</p>
</blockquote>
<p>1，结构清晰、耦合度低, 各层分工明确 </p>
<p>2，可维护性高，可扩展性高</p>
<p> 3，有利于标准化 </p>
<p>4，开发人员可以只关注整个结构中的其中某一层的功能实现 </p>
<p>5，有利于各层逻辑的复用</p>
<h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><ul>
<li><p>Mybatis框架</p>
<p>MyBatis 是一个优秀的基于 java 的持久层框架，内部封装了 jdbc，开发者只需要关注 sql 语句本身，而不需要处理加载驱动、创建连接、创建 statement、关闭连接，资源等繁杂的过程。 MyBatis 通过 xml 或注解两种方式将要执行的各种 sql 语句配置起来，并通过 java 对象和 sql 的 动态参数进行映射生成最终执行的 sql 语句，最后由 mybatis 框架执行 sql 并将结果映射为 java 对象并返回。</p>
</li>
<li><p>Spring框架</p>
<p>Spring 框架为了解决软件开发的复杂性而创建的。Spring 使用的是基本的 JavaBean 来完成以前 非常复杂的企业级开发。Spring 解决了业务对象，功能模块之间的耦合，不仅在 javase,web 中使用， 大部分 Java 应用都可以从 Spring 中受益。 Spring 是一个轻量级控制反转(IoC)和面向切面(AOP)的容器。</p>
</li>
<li><p>SpringMVC框架</p>
<p>SpringMVC 框架 Spring MVC 属于 SpringFrameWork 3.0 版本加入的一个模块，为 Spring 框架提供了构建 Web 应用程序的能力。现在可以 Spring 框架提供的 SpringMVC 模块实现 web 应用开发，在 web 项目中 可以无缝使用 Spring 和 Spring MVC 框架。</p>
</li>
</ul>
<h2 id="框架的定义"><a href="#框架的定义" class="headerlink" title="框架的定义"></a>框架的定义</h2><h3 id="框架定义"><a href="#框架定义" class="headerlink" title="框架定义"></a>框架定义</h3><p>框架（Framework）是整个或部分系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种认为，框架是可被应用开发者定制的应用骨架、模板。 简单的说，框架其实是半成品软件，就是一组组件，供你使用完成你自己的系统。从另一个角度来 说框架一个舞台，你在舞台上做表演。在框架基础上加入你要完成的功能。 框架安全的，可复用的，不断升级的软件。 </p>
<h3 id="框架解决的问题"><a href="#框架解决的问题" class="headerlink" title="框架解决的问题"></a>框架解决的问题</h3><p>框架要解决的最重要的一个问题是技术整合，在 J2EE 的 框架中，有着各种各样的技术，不同的应用，系统使用不同的技术解决问题。需要从 J2EE 中选择不同的技术，而技术自身的复杂性，有导致更大的风险。企业在开发软件项目时，主要目的是解决业务问题。 即要求企业负责技术本身，又要求解决业务问题。这是大多数企业不能完成的。框架把相关的技术融合在一起，企业开发可以集中在业务领域方面。 另一个方面可以提供开发的效率。</p>
<h2 id="JDBC编程"><a href="#JDBC编程" class="headerlink" title="JDBC编程"></a>JDBC编程</h2><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> 	Connection conn = <span class="keyword">null</span>;</span><br><span class="line"> 	Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"> 		<span class="comment">//注册 mysql 驱动</span></span><br><span class="line">		 Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">		 <span class="comment">//连接数据的基本信息 url ，username，password</span></span><br><span class="line">		 String url = <span class="string">&quot;jdbc:mysql://localhost:3306/springdb&quot;</span>;</span><br><span class="line">		 String username = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">		 String password = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"> 		<span class="comment">//创建连接对象</span></span><br><span class="line">		 conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">		 <span class="comment">//保存查询结果</span></span><br><span class="line">		 List&lt;Student&gt; stuList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> 		<span class="comment">//创建 Statement, 用来执行 sql 语句</span></span><br><span class="line"> 		stmt = conn.createStatement();</span><br><span class="line"> 		<span class="comment">//执行查询，创建记录集，</span></span><br><span class="line"> 		rs = stmt.executeQuery(<span class="string">&quot;select * from student&quot;</span>);</span><br><span class="line">		 <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">			 Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">			 stu.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">			 stu.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">			 stu.setAge(rs.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">			 <span class="comment">//从数据库取出数据转为 Student 对象，封装到 List 集合</span></span><br><span class="line">			 stuList.add(stu);</span><br><span class="line">			 &#125;</span><br><span class="line"> 		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			 e.printStackTrace();</span><br><span class="line">	    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> 			<span class="keyword">try</span> &#123;</span><br><span class="line">				 <span class="comment">//关闭资源</span></span><br><span class="line">                 <span class="keyword">if</span> (rs != <span class="keyword">null</span>) ;</span><br><span class="line"> 				&#123;</span><br><span class="line">					 rs.close();</span><br><span class="line">				 &#125;</span><br><span class="line"> 				<span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line"> 					stmt.close();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				<span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line"> 					conn.close();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				 e.printStackTrace();</span><br><span class="line"> 				&#125;</span><br><span class="line"> 			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="使用JDBC的缺陷"><a href="#使用JDBC的缺陷" class="headerlink" title="使用JDBC的缺陷"></a>使用JDBC的缺陷</h3><ol>
<li>代码比较多，开发效率低 </li>
<li> 需要关注 Connection ,Statement, ResultSet 对象创建和销毁 </li>
<li> 对 ResultSet 查询的结果，需要自己封装为 List </li>
<li> 重复的代码比较多些 </li>
<li> 业务代码和数据库的操作混在一起</li>
</ol>
<h2 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h2><p>MyBatis 框架：</p>
<p> MyBatis 本是 apache 的一个开源项目 iBatis, 2010 年这个项目由 apache software foundation 迁 移到了 google code，并且改名为 MyBatis 。2013 年 11 月迁移到 Github。 iBATIS 一词来源于“internet”和“abatis”的组合，是一个基于 Java 的持久层框架。iBATIS 提供的 持久层框架包括 SQL Maps 和 Data Access Objects（DAOs） 当前，最新版本是 MyBatis 3.5.1 ，其发布时间是 2019 年 4 月 8 日。</p>
<h3 id="Mybatis框架解决的主要问题"><a href="#Mybatis框架解决的主要问题" class="headerlink" title="Mybatis框架解决的主要问题"></a>Mybatis框架解决的主要问题</h3><p>减轻使用 JDBC 的复杂性，不用编写重复的创建 Connetion , Statement ; 不用编写关闭资源代码。 直接使用 java 对象，表示结果数据。让开发者专注 SQL 的处理。 其他分心的工作MyBatis 代劳。</p>
<p> MyBatis 可以完成：  </p>
<ul>
<li>注册数据库的驱动，例如 Class.forName(“com.mysql.jdbc.Driver”))</li>
<li>创建 JDBC 中必须使用的 Connection ， Statement， ResultSet 对象</li>
<li>从 xml 中获取 sql，并执行 sql 语句，把 ResultSet 结果转换 java 对象</li>
<li>关闭资源 ResultSet.close() , Statement.close() , Conenection.close()</li>
</ul>
]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis入门案例知识补充</title>
    <url>/2021/03/07/Mybatis%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<h2 id="不使用XML构建SqlSessionFactory"><a href="#不使用XML构建SqlSessionFactory" class="headerlink" title="不使用XML构建SqlSessionFactory"></a>不使用XML构建SqlSessionFactory</h2><p>如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置建造器，MyBatis 也<strong>提供了完整的配置类</strong>，提供了所有与 XML 文件等价的配置项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();</span><br><span class="line"><span class="comment">//指定事务类型</span></span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">&quot;development&quot;</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line"><span class="comment">//添加一个映射器类,相较于XML文件构建存在一定的局限性</span></span><br><span class="line">configuration.addMapper(BlogMapper.class);</span><br><span class="line"><span class="comment">//构造SqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure>
<p>注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是 Java 类，它们**<u>包含 SQL 映射注解从而避免依赖 XML 文件</u>**。不过，由于 Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML 配置。有鉴于此，如果存在一个同名 XML 配置文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载 BlogMapper.xml）。</p>
<h2 id="从SqlSessionFactory中获取SqlSession"><a href="#从SqlSessionFactory中获取SqlSession" class="headerlink" title="从SqlSessionFactory中获取SqlSession"></a>从SqlSessionFactory中获取SqlSession</h2><p> 既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>(SqlSession session = SqlSessionFactory.opensession())&#123;</span><br><span class="line">	 Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另一种更加简洁的方式</p>
</blockquote>
<p>使用和指定语句的参数和返回值**<u>相匹配的接口</u>**（比如 BlogMapper.class），现在你的代码不仅更清晰，更加类型安全，还不用担心可能出错的字符串字面值以及强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">    <span class="comment">//传参的时候传了一个接口</span></span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="探究已经映射的SQL语句"><a href="#探究已经映射的SQL语句" class="headerlink" title="探究已经映射的SQL语句"></a>探究已经映射的SQL语句</h2><p>粗略的讨论一下SqlSession和Mapper到底执行了什么操作</p>
<p>一个语句既可以通过 XML 定义，也可以通过注解定义。我们先看看 XML 定义语句的方式，事实上 MyBatis 提供的所有特性都可以利用基于 XML 的映射语言来实现，这使得 MyBatis 在过去的数年间得以流行。下面是一个XML文件示例</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">  PUBLIC <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="line">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="line">&lt;mapper namespace=<span class="string">&quot;org.mybatis.example.BlogMapper&quot;</span>&gt;</span><br><span class="line">  &lt;select id=<span class="string">&quot;selectBlog&quot;</span> resultType=<span class="string">&quot;Blog&quot;</span>&gt;</span><br><span class="line">    select * from Blog where id = #&#123;id&#125;</span><br><span class="line">  &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<p>为了这个简单的例子，我们似乎写了不少配置，但其实并不多。在一个 XML 映射文件中，可以定义无数个映射语句，这样一来，XML 头部和文档类型声明部分就显得微不足道了。文档的其它部分很直白，容易理解。 它在命名空间 “org.mybatis.example.BlogMapper” 中定义了一个名为 “selectBlog” 的映射语句，这样你就可以用全限定名 “org.mybatis.example.BlogMapper.selectBlog” 来调用映射语句了，就像上面例子中那样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Blog blog = (Blog) session.selectOne(<span class="string">&quot;org.mybatis.example.BlogMapper.selectBlog&quot;</span>, <span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>说明：此时org.mybatis.example.BlogMapper应该是一个接口</li>
<li>selectBlog是接口中定义的一个方法</li>
</ul>
<p>你可能会注意到，这种方式和用全限定名调用 Java 对象的方法类似。这样，该命名就可以<strong>直接映射到在命名空间中同名的映射器类</strong>，并将已映射的 select 语句匹配到对应名称、参数和返回类型的方法。因此你就可以像上面那样，不费吹灰之力地在对应的映射器接口调用方法，就像下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">Blog blog = mapper.selectBlog(<span class="number">101</span>);</span><br></pre></td></tr></table></figure>
<p>第二种方法有很多优势，首先它不依赖于字符串字面值，会更安全一点；其次，如果你的 IDE 有代码补全功能，那么代码补全可以帮你快速选择到映射好的 SQL 语句。</p>
<h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在之前版本的 MyBatis 中，<strong>命名空间（Namespaces）</strong>的作用并不大，是可选的。 但现在，随着命名空间越发重要，你必须指定命名空间。</p>
<p>命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的接口绑定。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。</p>
<p><strong>命名解析：</strong>为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。</p>
<ul>
<li>全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。</li>
<li>短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。</li>
</ul>
<hr>
<p>对于像 BlogMapper 这样的映射器类来说，还有另一种方法来完成语句映射。 它们映射的语句可以不用 XML 来配置，而可以使用 Java 注解来配置。比如，上面的 XML 示例可以被替换成如下的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.mybatis.example;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BlogMapper</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Select(&quot;SELECT * FROM blog WHERE id = #&#123;id&#125;&quot;)</span></span><br><span class="line">  <span class="function">Blog <span class="title">selectBlog</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用注解来映射简单语句会使代码显得更加简洁，但对于稍微复杂一点的语句，Java 注解不仅力不从心，还会让你本就复杂的 SQL 语句更加混乱不堪。 因此，如果你需要做一些很复杂的操作，最好用 XML 来映射语句。</p>
<p>选择何种方式来配置映射，以及认为是否应该要统一映射语句定义的形式，完全取决于你和你的团队。 换句话说，永远不要拘泥于一种方式，你可以很轻松的在基于注解和 XML 的语句映射方式间自由移植和切换。</p>
<h2 id="作用域和生命周期"><a href="#作用域和生命周期" class="headerlink" title="作用域和生命周期"></a>作用域和生命周期</h2><blockquote>
<p>对象生命周期和依赖注入框架</p>
</blockquote>
<p>依赖注入框架可以创建线程安全的、基于事务的 SqlSession 和映射器，并将它们直接注入到你的 bean 中，因此可以直接忽略它们的生命周期。 如果对如何通过依赖注入框架使用 MyBatis 感兴趣，可以研究一下 MyBatis-Spring 或 MyBatis-Guice 两个子项目。</p>
<h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在所有代码中都遵循这种使用模式，可以保证所有数据库资源都能被正确地关闭。</p>
<h3 id="映射器实例"><a href="#映射器实例" class="headerlink" title="映射器实例"></a>映射器实例</h3><p>映射器是一些绑定映射语句的接口。映射器接口的实例是从 SqlSession 中获得的。虽然从技术层面上来讲，任何映射器实例的最大作用域与请求它们的 SqlSession 相同。但方法作用域才是映射器实例的最合适的作用域。 也就是说，映射器实例应该在调用它们的方法中被获取，使用完毕之后即可丢弃。 映射器实例并不需要被显式地关闭。尽管在整个请求作用域保留映射器实例不会有什么问题，但是你很快会发现，在这个作用域上管理太多像 SqlSession 的资源会让你忙不过来。 因此，最好将映射器放在方法作用域内。就像下面的例子一样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;</span><br><span class="line">  BlogMapper mapper = session.getMapper(BlogMapper.class);</span><br><span class="line">  <span class="comment">// 你的应用逻辑代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>NetFilter and IPTable</title>
    <url>/2021/03/25/NetFilter/</url>
    <content><![CDATA[<p>netfilter 是 Linux 内置的一种防火墙机制，我们一般也称之为数据包过滤机制。iptables 则是一个命令行工具，用来配置 netfilter 防火墙。下图展示了一个带有防火墙的简单网络拓扑结构：</p>
<img data-src="/2021/03/25/NetFilter/01.png" class> 

<p>图中的 Linux 主机既充当了路由器的角色，同时又充当了防火墙的角色。本文我们将以该拓扑结构介绍 netfilter/iptables 防火墙中的基本概念和主要功能。<br>说明：本文的演示环境为 ubuntu 16.04。</p>
<h1 id="netfilter-与-iptables-的关系"><a href="#netfilter-与-iptables-的关系" class="headerlink" title="netfilter 与 iptables 的关系"></a>netfilter 与 iptables 的关系</h1><p>netfilter 指整个项目，其官网叫 <a href="https://netfilter.org/">netfilter.org</a>。在这个项目里面，netfilter 特指内核中的 netfilter 框架，iptables 指运行在用户态的配置工具。</p>
<p>netfilter 在协议栈中添加了一些钩子，它允许内核模块通过这些钩子注册回调函数，这样经过钩子的所有数据包都会被注册在相应钩子上的函数所处理，包括修改数据包内容、给数据包打标记或者丢掉数据包等。netfilter 框架负责维护钩子上注册的处理函数或者模块，以及它们的优先级。netfilter 框架负责在需要的时候动态加载其它的内核模块，比如 ip_conntrack、nf_conntrack、NAT subsystem 等。</p>
<p>iptables 是运行在用户态的一个程序，通过 netlink 和内核的 netfilter 框架打交道，并负责往钩子上配置回调函数。</p>
<h1 id="netfilter-防火墙原理"><a href="#netfilter-防火墙原理" class="headerlink" title="netfilter 防火墙原理"></a>netfilter 防火墙原理</h1><p>简单说 netfilter 机制就是对进出主机的数据包进行过滤。 我们可以通过 iptables 设置一些规则(rules)。所有进出主机的数据包都会按照一定的顺序匹配这些规则，如果匹配到某条规则，就执行这条规则对应的行为，比如抛弃该数据包或接受该数据包。下图展示了 netfilter 依据 iptables 规则对数据包过滤的大致过程：</p>
 <img data-src="/2021/03/25/NetFilter/02.png" class> 

<p>对数据包进行过滤。检查通过则接受(ACCEPT)数据包进入主机获取资源，如果检查不通过，则予以丢弃(DROP)！如果所有的规则都没有匹配上，就通过默认的策略(Policy)决定数据包的去向。注意，上图中的规则是有顺序的！比如数据包与 rule1 指定的规则匹配，那么这个数据包就会执行 action1 指定的行为，而不会继续匹配后面的规则了。</p>
<p>下面我们看一个例子。假设我们的 Linux 主机提供了 web 服务，所以需要放行访问 80 端口的数据包。<br>但是你发现来自 13.76.1.65 的数据包总是恶意的尝试入侵我们的 web 服务器，所以需要丢弃来自 13.76.1.65 数据包。<br>我们的 web 服务器并不提供 web 服务之外的其它服务，所以直接丢弃所有的非 web 请求的数据包。<br>总结后就是我们需要下面三条规则：</p>
<ul>
<li>rule1 丢弃来自 13.76.1.65 数据包</li>
<li>rule2 接受访问 web 服务的数据包</li>
<li>rule3 丢弃所有的数据包</li>
</ul>
<p>如果我们不小心把上面的规则顺序写错了，比如写成了下面的样子：</p>
<ul>
<li>rule1 接受访问 web 服务的数据包</li>
<li>rule2 丢弃来自 13.76.1.65 数据包</li>
<li>rule3 丢弃所有的数据包</li>
</ul>
<p>这时来自 13.76.1.65 的数据包是可以访问 web 服务的，因为来自 13.76.1.65 的数据包是符合第一条规则的，所以会被接受，此时就不会再考虑第二条规则了。</p>
<h1 id="iptables-中的-table-与-chain"><a href="#iptables-中的-table-与-chain" class="headerlink" title="iptables 中的 table 与 chain"></a>iptables 中的 table 与 chain</h1><p>iptables 用表(table)来分类管理它的规则(rule)，这也是 iptables 名称的由来。根据 rule 的作用分成了好几个表，比如用来过滤数据包的 rule 就会放到 filter 表中，用于处理地址转换的 rule 就会放到 nat 表中，其中 rule 就是应用在 netfilter 钩子上的函数，用来修改数据包的内容或过滤数据包。下面我们简单的介绍下最常用的 filter 表和 nat 表。<br><strong>filter</strong><br>从名字就可以看出，filter 表里面的规则主要用来过滤数据，用来控制让哪些数据可以通过，哪些数据不能通过，它是最常用的表。<br><strong>nat</strong><br>里面的规则都是用来处理网络地址转换的，控制要不要进行地址转换，以及怎样修改源地址或目的地址，从而影响数据包的路由，达到连通的目的，这是路由器必备的功能。</p>
<p>下图展示了 iptables 中常用的 tables 及其 rule chains：</p>
 <img data-src="/2021/03/25/NetFilter/03.png" class> 

<p>从上图可以看出，filter 和 nat 表中默认都存在着数条 rule chain。也就是说表中的规则(rule)又被编入了不同的链(chain)，由 chain 来决定什么时候触发 chain 上的这些规则。<br>iptables 里面有 5 个内置的 chain：</p>
<ul>
<li>PREROUTING：接收的数据包刚进来，还没有经过路由选择，即还不知道数据包是要发给本机还是其它机器。这时会触发该 chain 上的规则。</li>
<li>INPUT：已经经过路由选择，并且该数据包的目的 IP 是本机，进入本地数据包处理流程。此时会触发该 chain 上的规则。</li>
<li>FORWARD：已经经过路由选择，但该数据包的目的 IP 不是本机，而是其它机器，进入 forward 流程。此时会触发该 chain 上的规则。</li>
<li>OUTPUT：本地程序要发出去的数据包刚到 IP 层，还没进行路由选择。此时会触发该 chain 上的规则。</li>
<li>POSTROUTING：本地程序发出去的数据包，或者转发(forward)的数据包已经经过了路由选择，即将交由下层发送出去。此时会触发该 chain 上的规则。</li>
</ul>
<p>我们可以通过下图来理解这五条默认的规则链：</p>
 <img data-src="/2021/03/25/NetFilter/04.png" class> 

<p>从上图可知，不考虑特殊情况的话，一个数据包只会经过下面三个路径中的一个：<br>A，主机收到目的 IP 是本机的数据包<br>B，主机收到目的 IP 不是本机的数据包<br>C，本机发出去的数据包</p>
<ul>
<li>路径 A，数据包进入 Linux 主机访问其资源，在路由判断后确定是向 Linux 主机请求数据的数据包，此时主要是通过 filter 表的 INPUT 链来进行控制。</li>
<li>路径 B，数据包经由 Linux 主机转发，没有使用主机资源，而是流向后端主机。在路由判断之前对数据包进行表头的修改后，发现数据包需要透过防火墙去后端，此时的数据包就会通过路径B。也就是说，该封包的目标并非我们的 Linux 主机。该场景下数据包主要经过的链是 filter 表的 FORWARD 以及 nat 表的 POSTROUTING 和 PREROUTING。</li>
<li>路径 C，数据包由 Linux 主机向外发送。比如响应客户端的请求要求，或者是 Linux 主机主动发送出去的数据包，都会通过路径 C。它会先进行路由判断，在确定了输出的路径后，再通过 filter 表的 OUTPUT 链来传送。当然，最终还是会经过 nat 表的 POSTROUTING 链。</li>
</ul>
<p>由此我们可以总结出下面的规律。<br>filter 表主要跟进入 Linux 主机的数据包有关，其 chains 如下：</p>
<ul>
<li>INPUT：主要与想要进入 Linux 主机的数据包有关</li>
<li>OUTPUT：主要与 Linux 主机所要发送出去的数据包有关</li>
<li>FORWARD：与 Linux 主机没有关系，它可以对数据包进行转发</li>
</ul>
<p>nat(地址转换) 表主要在进行来源与目的之 IP 或 port 的转换，其 chains 如下：</p>
<ul>
<li>PREROUTING：在进行路由判断之前所要执行的规则(DNAT)</li>
<li>POSTROUTING：在进行路由判断之后所要执行的规则(SNAT)</li>
<li>OUTPUT：与发送出去的数据包有关</li>
</ul>
<h1 id="iptables-中的规则-rules"><a href="#iptables-中的规则-rules" class="headerlink" title="iptables 中的规则(rules)"></a>iptables 中的规则(rules)</h1><p>规则(rules)存放在特定表的特定 chain 上，每条 rule 包含下面两部分信息：</p>
<p><strong>Matching</strong><br>Matching 就是如何匹配一个数据包，匹配条件很多，比如协议类型、源/目的IP、源/目的端口、in/out接口、包头里面的数据以及连接状态等，这些条件可以任意组合从而实现复杂情况下的匹配。</p>
<p><strong>Targets</strong><br>Targets 就是找到匹配的数据包之后怎么办，常见的有下面几种：</p>
<ul>
<li>DROP：直接将数据包丢弃，不再进行后续的处理</li>
<li>RETURN： 跳出当前 chain，该 chain 里后续的 rule 不再执行</li>
<li>QUEUE： 将数据包放入用户空间的队列，供用户空间的程序处理</li>
<li>ACCEPT： 同意数据包通过，继续执行后续的 rule</li>
<li>跳转到其它用户自定义的 chain 继续执行</li>
</ul>
<p>比如下面的规则，只要是来自内网的(192.168.1.0/24)数据包都被接受：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo iptables -A INPUT -i eth0 -s 192.168.1.0&#x2F;24 -j ACCEPT</span><br></pre></td></tr></table></figure>
<h1 id="用户自定义-chains"><a href="#用户自定义-chains" class="headerlink" title="用户自定义 chains"></a>用户自定义 chains</h1><p>除了 iptables 预定义的 5 个 chain 之外，用户还可以在表中定义自己的 chain，用户自定义的 chain 中的规则和预定义 chain 里的规则没有区别，不过由于自定义的 chain 没有和 netfilter 里面的钩子进行绑定，所以它不会自动触发，只能从其它 chain 的规则中跳转过来。比如 docker 就创建了一些自定义的 chain：</p>
 <img data-src="/2021/03/25/NetFilter/05.png" class> 

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>netfilter/iptables 是当前 Linux 系统的主要防火墙机制，学习并掌握它可以为我们使用 Linux 系统打下坚实的基础。本文只是介绍了 netfilter/iptables 的概念和原理，在接下来的文章中，笔者将详细地介绍 iptables 命令的用法以及典型用例的设置方法。</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>防火墙配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公--Word</title>
    <url>/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/</url>
    <content><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Python实现高效自动化Word办公：如何批量合并多个文档-python-docx库）"><a href="#Python实现高效自动化Word办公：如何批量合并多个文档-python-docx库）" class="headerlink" title="Python实现高效自动化Word办公：如何批量合并多个文档(python-docx库）"></a>Python实现高效自动化Word办公：如何批量合并多个文档(python-docx库）</h1><p>在Word文件中，不但有文字内容，还有加粗、红色等格式，而且这些特殊的格式和文字内容是混合在一起的，但如果用Python来读取Word文件，这段文字会被分为纯文字、段落、字体、字号以及表格 等更具体的部分，而且每一个部分都对应着<strong>Python的变量和函数。</strong></p>
<p>用Python读取文件时，你需要记住很多个Python变量和函数。当然了，针对这一点， 你也不用担心，这些变量和函数在Python的Word扩展库<a href="https://python-docx.readthedocs.io/en/latest/#"><strong><em>官方文档</em></strong></a>可以查看。所以如果你需 要某个功能，但是不知道应该用什么变量和函数名称时，可以在官方文档中找到它的名字和 描述信息。</p>
<h3 id="用Python自动合并两个Word文件"><a href="#用Python自动合并两个Word文件" class="headerlink" title="用Python自动合并两个Word文件"></a>用Python自动合并两个Word文件</h3><ul>
<li><p>文件一（内容包含字体、字号、颜色等额外信息）：</p>
 <img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/image.png" class>
</li>
<li><p>文件二（内容文字出现在表格中）:</p>
 <img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/image01.png" class>

</li>
</ul>
<blockquote>
<p>第一个文件中，字体使用了黑体和宋体字，此外还有红色字体和加粗等格式。现在我需要 只提取其中的文字内容，不带任何格式。 </p>
<p>第二个文件中，文字被放在了一张表格里。现在我需要用Python把表格中的文字提取出 来，合并成一个新的文件。</p>
</blockquote>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mrge_without_format</span>(<span class="params">docfiles:<span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    只获取内容进行合并</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#遍历文件</span></span><br><span class="line">    <span class="keyword">for</span> docx_file <span class="keyword">in</span> <span class="built_in">sorted</span>(docfiles):</span><br><span class="line">        another_doc = Document(docx_file)</span><br><span class="line">        <span class="comment"># 获取每个文件的的所有段落</span></span><br><span class="line">        paras = another_doc.paragraphs</span><br><span class="line">        <span class="keyword">for</span> para <span class="keyword">in</span> paras:</span><br><span class="line">            <span class="comment"># 为新的word文件创建一个新段落</span></span><br><span class="line">            newpar = doc.add_paragraph(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="comment">#将提取的内容写入新的文本段落中</span></span><br><span class="line">            newpar.add_run(para.text)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#所有文件合并完成后在指定路径中保存</span></span><br><span class="line">        doc.save(Path(word_files_path,<span class="string">&#x27;new.docx&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用函数</span></span><br><span class="line">    merge-mrge_without_format(files)</span><br></pre></td></tr></table></figure>


<h3 id="用Python合并Word和其他类型的文件"><a href="#用Python合并Word和其他类型的文件" class="headerlink" title="用Python合并Word和其他类型的文件"></a>用Python合并Word和其他类型的文件</h3><p>相较于其他文件，Word文件支持的格式丰富程度远远高于Txt文件等，所以当这两种格式丰富程度不一致的文件进行合并时，要么向下兼容，去掉Txt不支持的格式；要 么向上兼容，对Txt进行格式再调整。否则容易出现合并之后仍需要手动调整格式的问题，影 响工作效率。</p>
<h4 id="将纯文本和Word文件合并"><a href="#将纯文本和Word文件合并" class="headerlink" title="将纯文本和Word文件合并"></a>将纯文本和Word文件合并</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> RGBColor</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># word文件所在路径</span></span><br><span class="line">word_files_path = <span class="string">&#x27;D:/Python自动化办公/Day02/word样例文件&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 取得该目录下所有的docx格式文件</span></span><br><span class="line"><span class="comment"># p = Path(word_files_path)</span></span><br><span class="line"></span><br><span class="line">my_content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">野老篱边江岸回，柴门不正逐江开。</span></span><br><span class="line"><span class="string">渔人网集澄潭下，贾客船随返照来。</span></span><br><span class="line"><span class="string">长路关心悲剑阁，片云何意傍琴台？</span></span><br><span class="line"><span class="string">王师未报收东郡，城阙秋生画角哀。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_content_mode1</span>(<span class="params">content</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    增加内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(doc)</span><br><span class="line">    para = doc.add_paragraph().add_run(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置字体格式</span></span><br><span class="line">    para.font.name = <span class="string">&#x27;仿宋&#x27;</span></span><br><span class="line">    <span class="comment"># 设置下划线</span></span><br><span class="line">    para.font.underline = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 设置颜色</span></span><br><span class="line">    para.font.color.rgb = RGBColor(<span class="number">255</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">    <span class="comment"># 其他设置参考官方文档</span></span><br><span class="line">    <span class="comment"># https://python-docx.readthedocs.io/en/latest/api/text.html#run-objects</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line">add_content_mode1(my_content)</span><br><span class="line">doc.save(Path(word_files_path, <span class="string">&#x27;new2.docx&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="将图片和Word文件合并"><a href="#将图片和Word文件合并" class="headerlink" title="将图片和Word文件合并"></a>将图片和Word文件合并</h4><p>我们经常见到的图片格式就有.jpg、.png、.gif等，由于这些格式应用范围广，格式 没有被商业软件加密，所以python-docx库的add_picture函数就能实现把图片插入Word的 功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> shared</span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line"><span class="comment"># 按英寸设置宽度，添加图片</span></span><br><span class="line">doc_add_picture(<span class="string">&#x27;test.jpg&#x27;</span>,width=shared.Inches(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>


<h4 id="将Execl和Word文件合并"><a href="#将Execl和Word文件合并" class="headerlink" title="将Execl和Word文件合并"></a>将Execl和Word文件合并</h4><ul>
<li><p>使用Python制作邀请函</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">today=datetime.date.today().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户信息文件</span></span><br><span class="line">customer = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/客户信息.xlsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邀请函模版</span></span><br><span class="line">invitation = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/邀请函模版.docx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邀请函路径</span></span><br><span class="line">invitation_path = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换内容</span></span><br><span class="line">replace_content = &#123;</span><br><span class="line">    <span class="string">&#x27;&lt;姓名&gt;&#x27;</span> : <span class="string">&#x27;no_name&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;性别&gt;&#x27;</span> : <span class="string">&#x27;m_f&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;今天日期&gt;&#x27;</span> : today</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generat_invitation</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    生成邀请函文件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    doc = Document(invitation)</span><br><span class="line">    <span class="comment"># 取出每一段</span></span><br><span class="line">    <span class="keyword">for</span> para <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> replace_content.items():</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> para.text:</span><br><span class="line">                <span class="comment"># 逐个关键字进行替换</span></span><br><span class="line">                para.text = para.text.replace(key, value)</span><br><span class="line"></span><br><span class="line">    file_name = PurePath(invitation_path).with_name(replace_content[<span class="string">&#x27;&lt;姓名&gt;&#x27;</span>]).with_suffix(<span class="string">&#x27;.docx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    doc.save(file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_customer</span>(<span class="params">customer_file: Path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    获取邀请函信息</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 从第一个sheet中取出客户信息</span></span><br><span class="line">    data = xlrd.open_workbook(customer_file)</span><br><span class="line">    table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得客户数量</span></span><br><span class="line">    customer_number = table.nrows</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, customer_number):</span><br><span class="line">        content = table.row_values(rowx=line, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">        replace_content[<span class="string">&#x27;&lt;姓名&gt;&#x27;</span>] = content[<span class="number">0</span>]</span><br><span class="line">        replace_content[<span class="string">&#x27;&lt;性别&gt;&#x27;</span>] = content[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(replace_content)</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;&lt;姓名&gt;&#x27;: &#x27;韩梅梅&#x27;, &#x27;&lt;性别&gt;&#x27;: &#x27;女士&#x27;, &#x27;&lt;今天日期&gt;&#x27;: &#x27;2021-01-01&#x27;&#125;</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;&lt;姓名&gt;&#x27;: &#x27;李雷&#x27;, &#x27;&lt;性别&gt;&#x27;: &#x27;先生&#x27;, &#x27;&lt;今天日期&gt;&#x27;: &#x27;2021-01-01&#x27;&#125;</span></span><br><span class="line">        generat_invitation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_customer(customer)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对不同类型文件进行合并时，要考虑不同的问题</p>
<blockquote>
<ol>
<li>对于支持格式丰富不同的文件时要考虑格式的兼容性；</li>
<li>  对于图片、音乐、视频和Word合并时要考虑是否是受到word支持的通用格式；</li>
<li>  对于像Excel格式于Word合并时能实现更复杂的功能，代码的复杂程度也会随之提高，一 般需要先分析功能，再进行代码编写。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-图片识别</title>
    <url>/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="使用Python实现高效自动化图片组在线-离线识别（转文字）"><a href="#使用Python实现高效自动化图片组在线-离线识别（转文字）" class="headerlink" title="使用Python实现高效自动化图片组在线/离线识别（转文字）"></a>使用Python实现高效自动化图片组在线/离线识别（转文字）</h1><h2 id="图片识别转文字的两种方式："><a href="#图片识别转文字的两种方式：" class="headerlink" title="图片识别转文字的两种方式："></a>图片识别转文字的两种方式：</h2><blockquote>
<p>在线识别</p>
<p>优点： 在线识别在初次进行文字识别的时候，准确率非常高。比如对聊天截图中的识别准确率就高达99%。因为在线识别使用了人工智能领域的深度学习算法和文字识别相结合的技术，能够把图片转换成文字后，还能在语义上把相近的字进行二次纠正。 比如说，被识别的内容包含英文单词“Hello”，一旦它的字母“o”被识别成数字“0”，在 线识别软件就会根据上下文语境把这类错误纠正回来，而这种二次纠正的功能在离线识别软 件中是没有的。</p>
<p>缺点：</p>
<ol>
<li>识别文字的过程需要在公有云的服务器上完成。也 就是说需要通过互联网把图片上传到服务器，那么一旦图片过大，或者图片数量比较多，就会导致上传时间过长。对于一些大批量文字识别场景/实时性要求很高的场景，在线识别不能满足要求</li>
<li>图片需要经过互联网传输，识别以后的图片该怎么保存，怎么销毁，是不是会被其他 人得到，这些都是安全风险。总之，信息泄露的风险比较大。所以像公司的合同、财务资料 等涉密程度比较高的扫描件，很少使用在线识别。</li>
</ol>
</blockquote>
<blockquote>
<p>离线识别</p>
<p>这种方式在识别过程中不需要连接网络，节省了在线传输图片的时间，适合那些对实时性要 求比较高或网络信号比较差的场景。</p>
<p>离线识别方式的问题就在于，初次识别文字的准确率比较低，识别完之后必须要经过人 工二次纠正才行。所以在前期人工校对，花费的时间相对来说会比较长。</p>
</blockquote>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image01.png" class>

<h2 id="在线识别"><a href="#在线识别" class="headerlink" title="在线识别"></a>在线识别</h2><p>在线文字识别方式，识别的主要功能的需要放在公有云的服务器中才能实现，所以在代码实 现中就要考虑用户验证和图片加密传输问题。</p>
<p>用户验证能确保识别的结果交还给你本人，图片加密传输能确保图片上的信息不会被其他人 窃取到。这些功能，各个公有云的AI产品都考虑得非常周全，一般会提供给用户一个扩展 库。你要做的，就是安装这些扩展库。</p>
<p><strong>以百度Ai图片转文字识别产品为例</strong></p>
<blockquote>
<p>pip install baidu-aip</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line">APP_ID = <span class="string">&#x27;&#x27;</span></span><br><span class="line">API_Key = <span class="string">&#x27;&#x27;</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID,API_Key,SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line">image = get_file_content(<span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用文字识别，图片参数为本地图片</span></span><br><span class="line">result = client.basicGeneral(image)</span><br><span class="line">print(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image02.png" class>

<p>当把这三个变量传入AipOcr函数，使用AipOcr函数通过互联网交互后，就可以用来识别用户 是不是被授权使用相应的产品，之后就可以把图片加密发送到AI产品的服务器上了。</p>
<h2 id="离线识别（pytesseract）"><a href="#离线识别（pytesseract）" class="headerlink" title="离线识别（pytesseract）"></a>离线识别（pytesseract）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开图片</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为灰度图片</span></span><br><span class="line">imgry = image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line"><span class="comment"># 二值化，采用阈值分割算法，threhold为分割点，根据图片质量调节</span></span><br><span class="line">threhold = <span class="number">150</span></span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">if</span> j&lt;threhold:</span><br><span class="line">        table.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">temp = imgry.point(table,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">temp = imgry.point(table,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OCR识别，调用pytesseract库，lang指定中文，--psm 6表示按行识别，有助于提升准确率</span></span><br><span class="line">text = pytesseract.image_to_string(temp,lang=<span class="string">&quot;chi_sim+eng&quot;</span>,config=<span class="string">&#x27;--psm 6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印识别结果</span></span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>遇到问题</strong></p>
<p>TesseractNotFoundError: tesseract is not installed or it’s not in your PATH. See README file for more information.</p>
<p><strong>原因</strong>：</p>
<p>pytesseract是依赖c++编写的tesseract工具才能正常工作的，需要先安装teseract</p>
<p><strong>解决</strong>：</p>
<p><a href="https://blog.csdn.net/wang_hugh/article/details/80760940">https://blog.csdn.net/wang_hugh/article/details/80760940</a></p>
</blockquote>
<p>对图片文字离线识别的一般过程如下：</p>
<ul>
<li>图像输入</li>
<li>前期处理，比如二值化，图像降噪，倾斜纠正</li>
<li>文字检测，比如版面分析，字符分割</li>
<li>文本识别，比如字符识别，后期纠正（<strong>影响准确率最大</strong>）</li>
<li>输出文本</li>
</ul>
<p>离线识别训练样本较小，正确率相较于在线识别是不高的。具体的解决方案有以下两种</p>
<blockquote>
<p>通过人工纠正，形成新的训练模型（不断增加算法模型中标本的数量）</p>
</blockquote>
<p>像身份证识别、票据识别、聊天截图等大部分文字识别场景，这些待识别图片采用了印刷体，每个字的间隔都是固定的，所以我们要想提升准确率，通常的做法是对每个字都进行人 工纠错。</p>
<p>所以整个过程你可以理解成三个步骤： 第一步，人工观察； 第二步，对比原始图像； 第三步，把错误的文字手工纠正为正确的汉字。 比如截图中的“某”字，多次识别错误，当我们人工把这些文字改为正确的“某”字之后， 就可以生成一个训练文件，再把训练文件和文字识别的算法合并成新的识别模型。等下次再 识别发票的时候，就可以采用新的模型进行识别。所以再次出  现“某”字，就可以正确识别了。</p>
<p><strong>这种文字标注对于单一场景非常有效，比如名片、火车票、飞机票、发票、车牌的识别场 景，经过手工标注，不断增加样本数量之后，能够让正确率呈对数级别增加。</strong></p>
<blockquote>
<p>使用在线识别软件来优化离线识别软件</p>
</blockquote>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image03.png" class>



<h2 id="识别成功后的文字处理工作"><a href="#识别成功后的文字处理工作" class="headerlink" title="识别成功后的文字处理工作"></a>识别成功后的文字处理工作</h2><p>下图为在线识别的结果</p>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image04.png" class>

<p>为了能够提取文本内容，去掉记录分段信息的”word”和 “{ }”，需要对这段文字再加工处理。</p>
<p>仔细观察的话，就会发现这段文字是有一定规律的，它的写法就是Python的基本数据类型“字典”，字典类型会强调一对或多对数据之间的映射关系。为了将识别的文字结果进行保存，我们还会使用另一个基本数据类型“列表”，一般用来表示多段文字的并列关系， 为了提取文本内容，我接下来把字典转换成列表就可以实现内容的提取了。 从字典到列表转换的功能怎么实现呢？首先来看一下两种数据类型的定义</p>
<p><img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220131094327030.png" alt="image-20220131094327030"></p>
<p>观察这两个数据类型不难发现，把字典的VALUE存放到列表里就能实现内容的提取了，如果 字典里有多个值，可以使用for循环进行遍历，然后批量提取。对于识别的结果，我们可以采 用一段代码进行从字典到列表的转换。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result[<span class="string">&#x27;words_result&#x27;</span>]:</span><br><span class="line">	info.append(i[<span class="string">&#x27;words&#x27;</span>])</span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure>
<p>处理好的内容如下</p>


]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-跨文件字数统计</title>
    <url>/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="使用Python实现快速读写文件，跨文件字数统计"><a href="#使用Python实现快速读写文件，跨文件字数统计" class="headerlink" title="使用Python实现快速读写文件，跨文件字数统计"></a>使用Python实现快速读写文件，跨文件字数统计</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">使用Python来批量统计多个文件的字数和标点符号</span><br></pre></td></tr></table></figure>
<h2 id="实现单个文件字数统计"><a href="#实现单个文件字数统计" class="headerlink" title="实现单个文件字数统计"></a>实现单个文件字数统计</h2><p>统计单个文件的字数，需要用到Python的文件读写函数和变量这两个功能。Python的读写函 数是对文件内容的读取操作，变量呢，用来存储统计好的文件字数。</p>
<ul>
<li>先把要统计的文件读入内存；</li>
<li>再对读入到内存的字数数量进行统计，并用变量保存；</li>
<li>最后是将结果写入统计字数的专用文件中。</li>
</ul>
<h3 id="将文件内容读取到内存中"><a href="#将文件内容读取到内存中" class="headerlink" title="将文件内容读取到内存中"></a>将文件内容读取到内存中</h3><p>Python实现读取文件内容到内存的函数有三个，这三个函数原理相同，但是读取的内容多少有些不同，分别为：</p>
<img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209190932306.png" alt="image-20220209190932306" style="zoom:50%;">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line">file_name = <span class="string">&quot;./e.txt&quot;</span></span><br><span class="line"><span class="comment"># 取得脚本所在目录</span></span><br><span class="line">current_path = pathlib.PurePath(__file__).parent</span><br><span class="line"></span><br><span class="line"><span class="comment">#和脚本同目录下的要打开文件绝对路径</span></span><br><span class="line">file = current_path.joinpath(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    content = f.read()</span><br><span class="line">    words = content.rstrip()</span><br><span class="line">    number = <span class="built_in">len</span>(words)</span><br><span class="line">    print(number)</span><br></pre></td></tr></table></figure>
<p>open()函数参数说明：</p>
<p>第一个参数file变量的值是要操作的文件路径和文件名称，你需要正 确指定它所在的路径和文件名称。第二个参数encoding变量的值指定了以哪种字符编码打开文件，错误的字符编码会导致内容读取异常，文字内容显示为“乱码”。</p>
<h4 id="获取完整路径"><a href="#获取完整路径" class="headerlink" title="获取完整路径"></a>获取完整路径</h4><ul>
<li>在代码中使用pathlib库的PurePath()函数，把当前Python脚本的路径转化为标准的 pathlib格式。</li>
<li>通过parent属性去掉脚本的文件名，取得当前脚本所在的路径。</li>
<li>再通过joinpath()函数把脚本所在的路径和e.txt文件名进行拼接，得到e.txt的完整路径。</li>
</ul>
<p>这种取得脚本同目录下的其他文件完整路径的用法，要比直接指定文件完整路径用法更灵活。</p>
<blockquote>
<p>__file__变量比较特殊，它是在Python中预先定义好的一个变量，默认情况下它的值会被 Python自动设置为当前脚本的完整路径名称。有了它，我就可以通过Python脚本的路径取得 e.txt的完整路径了。</p>
</blockquote>
<h4 id="设置字符编码"><a href="#设置字符编码" class="headerlink" title="设置字符编码"></a>设置字符编码</h4><p>第二个参数的作用是设置open()函数使用何种字符编码打开文件。</p>
<h4 id="函数传参调用"><a href="#函数传参调用" class="headerlink" title="函数传参调用"></a>函数传参调用</h4><p>为什们指定这个参数的时候，要特意写出变量名称encoding呢？</p>
<p>在函数定义的时候我们可以为函数指定一个或多个参数，如果使用了多个参数，你在调用函 数的时候需要按顺序依次传入每一个参数。但是如果你想要使用某个参数默认值或不想按照 顺序传入参数时怎么办呢？函数调用时，还可以根据参数的关键字来指定为函数传入哪些参 数。比如说open()函数的参数有7个，</p>
<p><img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209193920724.png" alt="image-20220209193920724"></p>
<p>在open()函数的定义中，encoding参数是open()函数的第4个参数。如果我们只需要第1个和 第4个参数，其他参数需要保持默认时，就可以使用如下格式调用open()函数：</p>
<p><img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209193956499.png" alt="image-20220209193956499"></p>
<p>在代码中，调用open()函数时，由于file参数是open()函数的第一个参数，因此可以不用指定 参数的关键字。encoding参数并非open()函数定义的第二个参数，而是第四个参数，所以需 要指定它的参数名称为encoding，根据open()函数的定义，encoding=”utf-8”会作为 open()函数的第四个参数使用。这种使用关键字作为函数的参数的方式，也被称作<strong>函数的关键字传参方式</strong>。</p>
<h3 id="with使用"><a href="#with使用" class="headerlink" title="with使用"></a>with使用</h3><p>with关键字下面的代码是缩进形式，和with关键字形成了一个语句块</p>
<p>在with语句 块结束之后，不必手动调用close()函数关闭文件，Python会自动将文件关闭。因此，你会看到我在程序中调用了open()函数打开文件，但是没有调用关闭文件的close()函数。</p>
<p>总的来说，相对于手动调用close()函数来关闭文件，使用with函数减少了打开过多文件造成系统资源浪费和数据丢失的风险。</p>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>正确使用了open()函数的两个参数以后，会返回一个表示文件的对象f, 只有设置了正确 的文件路径、文件名称和字符编码，才能继续进行文件读取操作。文件的读取操作使用的是 read()函数，read()函数会根据文件的对象f，按照open()函数定义好的打开方式进行逐个字 的读取操作。Python对文件的其他操作，全都需要通过文件操作函数调用对象f来完成。</p>
<h4 id="统计文件的字数"><a href="#统计文件的字数" class="headerlink" title="统计文件的字数"></a>统计文件的字数</h4><p>Python的内置函数**len()**来实现</p>
<p>len()函数在Python中最初设计的功能就是统计字符串的长度，即字符串中有多少字符。利用len()函数可以对字符串数据类型进行操作的特性，将文件一次性读入内存，放入字符串数据类型中。我在统计字数之前还增加了一个rstrip()函数，它会自动剔除出现在文件末尾的空行、空格，让你统计的结果更精确。</p>
<p>在进行文件字数统计的时候，需要注意，在代码中使用了read()函数实现了对文件内容的一<br>次性读取到内存的功能。如果你的文件较大，我建议你使用readline()函数按行读取，并逐行<br>统计字数，否则容易出现内存不足的问题。</p>
<h4 id="将统计结果写入文件"><a href="#将统计结果写入文件" class="headerlink" title="将统计结果写入文件"></a>将统计结果写入文件</h4><p>将统计结果写入文件，可以对<strong>open()函数</strong>打开文件方式进行简单的修改，就可以实现文件写入功能了，写入文件的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;total.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encodong=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	 f.write(<span class="string">&quot;15个字符&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>open()函数的第二个参数表示文件的打开方式，它默认值是“r”，代表了文件以读取方式进行打开。这时对象f只能进行文件读取操作，我们需要将第二个参数指定为”w”，就可以使用wirte()函数对文件进行写入操作了。而write()函数的第一个参数就是即将要写入文件的内容。</p>
<h3 id="怎么统计多个文件的次数"><a href="#怎么统计多个文件的次数" class="headerlink" title="怎么统计多个文件的次数"></a>怎么统计多个文件的次数</h3><p>对多个文件的字数统计，就可以使用for循环来实现批量读取多个文件的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Path(src_path)</span><br><span class="line">files = [x <span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath(x).match(<span class="string">&#x27;*.txt&#x27;</span>)]</span><br><span class="line"><span class="keyword">for</span> files <span class="keyword">in</span> files:</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(file,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">words = content.rstrip()</span><br><span class="line">    	number = <span class="built_in">len</span>(words)</span><br></pre></td></tr></table></figure>
<p>数字类型是一种非常适合进行整数、浮点数的转换和算数几何计算最常用的类型。在单文件字数统计的场景，用来储存每个文件的字数是最合适的类型。如果把场景扩展到统计多个文件的字数，使用一个数字类型的变量是不够的，你需要在循环中再增加一个新的数字类型的变量，对多个文件的统计结果进行依次累加就可以了。</p>
]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公</title>
    <url>/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/</url>
    <content><![CDATA[<h1 id="任务场景一：拆分与合并–快速的批量处理内容相似的Excel"><a href="#任务场景一：拆分与合并–快速的批量处理内容相似的Excel" class="headerlink" title="任务场景一：拆分与合并–快速的批量处理内容相似的Excel"></a>任务场景一：拆分与合并–快速的批量处理内容相似的Excel</h1><blockquote>
<p>批量合并</p>
<p>假设你需要对某些工作内容进行问卷调查，这时你用Excel做了调查问卷模版。 我想你会这样做：先把Excel通过工作群分发给所有员工，再把群里收集到的反馈附件汇总 成一个文件。</p>
<p>批量拆分</p>
<p>假设你是公司的财务人员，你需要使用Excel对员工工资进行核算，之后再打印 出来。但是公司要求员工薪水保密，所以每个员工的工资需要拆分成一个独立的文件，最 后还需要打印出来。</p>
</blockquote>
<ul>
<li>解决方案：使用Python实现自动化批量处理。<ul>
<li>安装扩展库：支持Excel读取的扩展库叫做xlrd库，支持Excel写入的扩展库叫做xlwt库</li>
<li>找到整个工作过程当中重复操作的部分；</li>
<li> 将重复操作的部分需要哪些手工操作找出来，使用Python编写程序代替手工操作的部分；</li>
<li> 对重复的部分，使用循环语句进行批量处理。</li>
<li>可以使用绘制时序图来实现手工操作到Python程序的过渡</li>
</ul>
</li>
</ul>
<img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/image.png" class>





<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="Merge-py"><a href="#Merge-py" class="headerlink" title="Merge.py"></a>Merge.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入Excel和文件操作库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要合并excel的路径</span></span><br><span class="line">src_path = <span class="string">&#x27;D:/Python自动化办公/Day01/调查问卷&#x27;</span></span><br><span class="line"><span class="comment"># 指定合并完成的路径</span></span><br><span class="line">dst_file = <span class="string">&#x27;D:/Python自动化办公/Day01/result/结果.xls&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得给目录下所有的xlsx格式文件</span></span><br><span class="line">p = Path(src_path)</span><br><span class="line">files = [x <span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath(x).match(<span class="string">&#x27;*.xls&#x27;</span>)]</span><br><span class="line">print(files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备列表存放读取结果</span></span><br><span class="line">content = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个文件进行重复处理</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="comment"># 用文件作为每个用户的标识</span></span><br><span class="line">    username = file.stem</span><br><span class="line">    data = xlrd.open_workbook(file)</span><br><span class="line">    table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得每一项的结果</span></span><br><span class="line">    answer1 = table.cell_value(rowx=<span class="number">4</span>, colx=<span class="number">4</span>)</span><br><span class="line">    answer2 = table.cell_value(rowx=<span class="number">10</span>, colx=<span class="number">4</span>)</span><br><span class="line">    temp = <span class="string">f&#x27;<span class="subst">&#123;username&#125;</span>,<span class="subst">&#123;answer1&#125;</span>,<span class="subst">&#123;answer2&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并为一行存储</span></span><br><span class="line">    content.append(temp.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    print(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    print(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备写入文件的表头</span></span><br><span class="line">table_header = [<span class="string">&#x27;员工姓名&#x27;</span>, <span class="string">&#x27;第一题&#x27;</span>, <span class="string">&#x27;第二题&#x27;</span>]</span><br><span class="line"></span><br><span class="line">workbook = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">x1sheet = workbook.add_sheet(<span class="string">&quot;统计结果&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入表头</span></span><br><span class="line">row = <span class="number">0</span></span><br><span class="line">col = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> cell_header <span class="keyword">in</span> table_header:</span><br><span class="line">    x1sheet.write(row, col, cell_header)</span><br><span class="line">    col += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向下移动一行</span></span><br><span class="line">row += <span class="number">1</span></span><br><span class="line"><span class="comment"># 取出每一行的内容</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">    col = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 取出每个单元格内容</span></span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> line:</span><br><span class="line">        <span class="comment"># 写入内容</span></span><br><span class="line">        x1sheet.write(row, col, cell)</span><br><span class="line">        <span class="comment"># 向右移动一个单元格</span></span><br><span class="line">        col += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 向下移动一行</span></span><br><span class="line">    row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存最终结果</span></span><br><span class="line">workbook.save(dst_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Split-py"><a href="#Split-py" class="headerlink" title="Split.py"></a>Split.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工资单文件</span></span><br><span class="line">salary_file = <span class="string">&#x27;D:/Python自动化办公/Day01/工资单/工资单.xls&#x27;</span></span><br><span class="line"><span class="comment"># 拆分文件保存路径</span></span><br><span class="line">dst_path = <span class="string">&#x27;D:/Python自动化办公/Day01/工资单&#x27;</span></span><br><span class="line"></span><br><span class="line">data = xlrd.open_workbook(salary_file)</span><br><span class="line">table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 取得表头</span></span><br><span class="line">salary_header = table.row_values(rowx=<span class="number">0</span>, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义写入文件的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span>(<span class="params">filename, cnt</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    filename : 写入的文件名</span></span><br><span class="line"><span class="string">    cnt      : 写入的内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    workbook = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    xlsheet = workbook.add_sheet(<span class="string">&quot;本月工资&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> cnt:</span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> line:</span><br><span class="line">            xlsheet.write(row, col, cell)</span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    workbook.save(PurePath(salary_file).with_name(filename).with_suffix(<span class="string">&#x27;.xls&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得员工数量</span></span><br><span class="line">employee_number = table.nrows</span><br><span class="line"><span class="comment"># 取得每一行,并用第二个单元格作为新的文件名</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,employee_number):</span><br><span class="line">    content = table.row_values(rowx=line, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 将表头和员工数量重新组成一个新的文件 </span></span><br><span class="line">    new_content = []</span><br><span class="line">    <span class="comment"># 增加表头到要写入的内容中</span></span><br><span class="line">    new_content.append(salary_header)</span><br><span class="line">    <span class="comment"># 增加员工工资到要写入的内容中</span></span><br><span class="line">    new_content.append(content)</span><br><span class="line">    <span class="comment"># 调用自定义函数write_to_file()写入新的文件</span></span><br><span class="line">    write_to_file(filename = content[<span class="number">1</span>], cnt = new_content)</span><br></pre></td></tr></table></figure>


<h2 id="Python与Excel交互模块学习"><a href="#Python与Excel交互模块学习" class="headerlink" title="Python与Excel交互模块学习"></a>Python与Excel交互模块学习</h2>]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-长图拼接</title>
    <url>/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="Python自动化办公–长图拼接"><a href="#Python自动化办公–长图拼接" class="headerlink" title="Python自动化办公–长图拼接"></a>Python自动化办公–长图拼接</h1><h2 id="Python调用外部程序的原理"><a href="#Python调用外部程序的原理" class="headerlink" title="Python调用外部程序的原理"></a>Python调用外部程序的原理</h2><blockquote>
<p>导入函数库[对应的Python外部功能已经开发为库]</p>
</blockquote>
<p>例如：Python语言默认是不支持Excel的。那么通过导入函数库xlrd，Python就可以获得对Excel的操作能力。</p>
<blockquote>
<p>需要操作Python语言之外的功能，但这个功能没有人将它开发成函数库， 那如果我们想要使用这些功能，使用的途径就是调用外部命令了，而调用外部命令就需要 Python内部函数库的subprocess模块来实现。</p>
</blockquote>
<ul>
<li><p>实现机制</p>
<p>它的run()函数的参数可以指定一个可以运行的程序的路径，而 Python会根据这个路径来运行可执行文件，然后再根据运行结果，以及Python的逻辑判断去进行后续的自动化处理工作。</p>
</li>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> run,Popen,PIPE</span><br><span class="line"></span><br><span class="line">cmd = [<span class="string">&quot;dir&quot;</span>]</span><br><span class="line">returncode = run(cmd)</span><br><span class="line"><span class="comment"># returncode是dir命令的退出状态码，通常来说, 一个为 0 的退出码表示进程运行正常</span></span><br><span class="line">print(returncode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Popen(cmd,shell=<span class="literal">True</span>,stdout=PIPE,stderr=PIPE,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fs:</span><br><span class="line">    fs.wait(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    files = fs.communicate()[<span class="number">0</span>]</span><br><span class="line">print(files)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码中最核心的函数是run()函数和Popen类。subprocess模块就是通过这两个函数实现 的外部程序调用。</p>
</li>
</ul>
<img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image01.png" class>

<p>和import方式导入函数库的区别是，这种形式可以让你直接使用模块中的类和方法。 如果你使用 “import subprocess”方式导入subprocess库的话，在调用run()函数的时候， 就需要用 “库.函数”的形式在Python中使用库当中的函数，即“subprocess.run()”。在你 多次调用run()函数时，代码会较长，那么使用“from import”方式导入，就可以在当前代 码文件中直接使用run()函数，为代码的阅读带来更好的体验。</p>
 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image02.png" class>

 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image03.png" class>

<p>以上就是用subprocess库实现Python调用可执行程序的方法。Python之所以被我们称作最佳的“<strong>胶水语言</strong>”，就是因为它能轻易“粘合”可执行程序。利用Python灵活的逻辑判 断、循环语法可以实现程序的批量执行和流程管理。</p>
<h2 id="长图拼接"><a href="#长图拼接" class="headerlink" title="长图拼接"></a>长图拼接</h2><p>拼接图片的功能Python本身是不具备的，因此就需要引入外部命令来实现图片拼接功能。</p>
<p>以MacOS平台图像处理软件ImageMagick，它能对图片进行编辑、合并、切割、旋转等90多种操作， ImageMagick软件实现图片拼接的命令格式是这样的：</p>
 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image04.png" class>

<p>在这段命令格式中，composite命令的参数包含了多个图片文件，每个图片需要对照着文件 将图片的路径和文件名写在参数中。如果手工输入图片名称，不仅效率低，而且容易遗漏。 另外，如果需要大量重复使用composite，还需要精细调整合并结果，给composite程序增加很多参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Path(jpg_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加图片命令</span></span><br><span class="line">cmd = [<span class="string">&quot;composite&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加参数</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath.match(<span class="string">&#x27;*.jpg&#x27;</span>):</span><br><span class="line">    cmd.append(x)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 增加结果</span></span><br><span class="line">cmd.append(result_path)</span><br><span class="line"></span><br><span class="line">run(cmd)</span><br></pre></td></tr></table></figure>


<h2 id="视频的拆分与合并"><a href="#视频的拆分与合并" class="headerlink" title="视频的拆分与合并"></a>视频的拆分与合并</h2><p>如何使用 subprocess库调用可执行程序，来进行视频的拆分与合并。</p>
<p><strong>视频拆分的原理</strong></p>
<p>你在电脑本地经常见到的视频格式是MP4，但如果要把视频放在互联网上，为了减少首次播放的加载时间，你就必须把一个MP4切分成多个文件，而且切分之后还需要把格式转换为.TS 格式的视频文件。 </p>
<p>为什么不直接使用MP4格式，而是要把MP4格式改成.TS格式呢？这是因为.TS格式可以保证 多个文件之间的视频无缝播放，而且还会保证视频不会在播放下一个文件的时候，出现破音 或画面中断等影响用户体验的情况。 </p>
<p>当我们将一个视频切分成多个文件的时候，就要考虑文件的播放顺序问题了。为了记录顺序，我们需要在切分之后引入一个索引文件，这个索引文件不用手动编写，我们直接使 <strong>FFmpeg命令</strong>就行了，它可以实现视频格式的转换、合并和拆分。FFmpeg命令会在切分之 后，自动产生一个以.M3U8结尾的索引文件。 </p>
<p>我来解释一下这个索引文件。M3U8文件是指UDF-8编码格式下的M3U视频索引，播放器通 过这个索引文件就可以找到视频下所有的分段，并依次播放视频。</p>
<p>所以，想要使用Python进行视频拆分，我们首先需要FFmpeg命令， 然后通过Python设置FFmpeg的参数，最后再指定MP4文件和.TS文件的路径，这样就能实现拆分视频的功能了。</p>
<p>首先需要下载ffmpeg命令，用于把MP4切分成多段TS文件。</p>
<p>为了实现MP4文件格式的分割，需要使用ffmpeg非常多的参数。不过使用Python进行调用 的好处，就是你不用记住复杂的参数。我们把输入文件路径、切分大小、输出的M3U8和TS 文件指定为四个变量，这样只修改这四个变量，就可以实现拆分功能了。</p>
<blockquote>
<p>相比直接使用FFmpeg，subprocess调用FFmpeg的优势就在于两点，一是不用 记住复杂参数，二是对批量转换视频非常有利</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> run</span><br><span class="line"><span class="comment"># 拆分文件的路径</span></span><br><span class="line">input_video = <span class="string">&quot;/Users/edz/Desktop/05/xxx.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10秒分为一个文件</span></span><br><span class="line">segment_time = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># m3u8文件保存位置</span></span><br><span class="line"><span class="comment"># m3u8_list = &quot;/Users/edz/Desktop/05/xxx.m3u8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ts文件保存位置</span></span><br><span class="line">output_video = <span class="string">&quot;/Users/edz/Desktop/05/video-%04d.ts&quot;</span></span><br><span class="line"></span><br><span class="line">cmd1 = [<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-i&quot;</span>, input_video, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;segment&quot;</span>, <span class="string">&quot;-segment_time&quot;</span>, <span class="built_in">str</span>(segment_time), <span class="string">&quot;-segment_format&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mpegts&quot;</span>, <span class="string">&quot;-segment_list&quot;</span>, m3u8_list, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;copy&quot;</span>, <span class="string">&quot;-bsf:v&quot;</span>, <span class="string">&quot;h264_mp4toannexb&quot;</span>, <span class="string">&quot;-map&quot;</span>, <span class="string">&quot;0&quot;</span>, output_video]</span><br><span class="line"></span><br><span class="line">run(cmd1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line"><span class="comment"># ffmpeg -allowed_extensions ALL -protocol_whitelist &quot;file,http,crypto,tcp,https&quot; -i index.m3u8 -c copy out.mp4</span></span><br></pre></td></tr></table></figure>




























]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>SVN版本控制系统</title>
    <url>/2021/02/06/SVN%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3>]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy1</title>
    <url>/2022/02/21/Scrapy1/</url>
    <content><![CDATA[<h1 id="Scrapy爬虫Section1"><a href="#Scrapy爬虫Section1" class="headerlink" title="Scrapy爬虫Section1"></a>Scrapy爬虫Section1</h1><h2 id="认识Scrapy爬虫"><a href="#认识Scrapy爬虫" class="headerlink" title="认识Scrapy爬虫"></a>认识Scrapy爬虫</h2> <img data-src="/2022/02/21/Scrapy1/image17.png" class>

<p>网络爬虫是指在互联网上自动爬取网站内容信息的程序，也被称作网络蜘蛛或网络机器人。大型的爬虫程序被广泛应用于搜索引擎、数据挖掘等领域，个人用户或企业也可以利用爬虫收集对自身有价值的数据。</p>
<blockquote>
<p>网络爬虫的基本执行流程</p>
</blockquote>
 <img data-src="/2022/02/21/Scrapy1/image01.png" class>

<ul>
<li><p>下载页面</p>
<p>一个网页的内容本质上就是一个HTML文本，爬取一个网页内容之前，首先要根据网页的URL下载网页。</p>
</li>
<li><p>提取页面数据</p>
<p>当一个网页（HTML）下载完成后，对页面中的内容进行分析，并提取出我们感兴趣的数据，提取到的数据可以以多种形式保存起来，比如将数据以某种格式（CSV、JSON）写入文件中，或存储到数据库（MySQL、MongoDB）中。</p>
</li>
<li><p>提取页面链接</p>
<p> 通常，我们想要获取的数据并不只在一个页面中，而是分布在多个页面中，这些页面彼此联系，一个页面中可能包含一个或多个到其他页面的链接，<strong>提取完当前页面中的数据</strong>后，还要**<em>把页面中的某些链接也提取出来**</em>，然后对链接页面进行爬取（循环1-3步骤）。</p>
</li>
</ul>
<p>使用Python可以从头开始写一个爬虫程序，为了避免因制造轮子 而消耗大量时间，在实际应用中我们可以选择使用一些优秀的爬虫框 架，使用框架可以降低开发成本，提高程序质量。所以就有了**<em>Scrapy**</em>的出现。</p>
<h3 id="Scrapy的安装"><a href="#Scrapy的安装" class="headerlink" title="Scrapy的安装"></a>Scrapy的安装</h3><blockquote>
<p>pip install scrapy </p>
</blockquote>
<p>出现图示则代表安装成功。</p>
 <img data-src="/2022/02/21/Scrapy1/image02.png" class>

<h3 id="编写Spider（Scrapy-爬虫程序中最核心的组件）"><a href="#编写Spider（Scrapy-爬虫程序中最核心的组件）" class="headerlink" title="编写Spider（Scrapy 爬虫程序中最核心的组件）"></a>编写Spider（Scrapy 爬虫程序中最核心的组件）</h3><h4 id="Scrapy框架结构及工作原理"><a href="#Scrapy框架结构及工作原理" class="headerlink" title="Scrapy框架结构及工作原理"></a>Scrapy框架结构及工作原理</h4> <img data-src="/2022/02/21/Scrapy1/image03.png" class>

<blockquote>
<p>对**<em>各个组件**</em>的介绍如下图所示</p>
</blockquote>
 <img data-src="/2022/02/21/Scrapy1/image04.png" class>

<blockquote>
<p>对框架中的**<em>数据流**</em>介绍如图所示</p>
</blockquote>
  <img data-src="/2022/02/21/Scrapy1/image05.png" class>

<p>Request和Response是HTTP协议中的术语，即HTTP请求和 HTTP响应，Scrapy框架中定义了相应的Request和Response类，这里的Item代表Spider从页面中爬取的一项数据。</p>
<blockquote>
<p>数据在框架中的流动过程</p>
</blockquote>
<ul>
<li><p>当SPIDER要爬取某URL地址的页面时，需使用该URL构造一个Request对象，提交给ENGINE。</p>
</li>
<li><p>Request对象随后进入SCHEDULER按某种算法进行排队，之后的某个时刻SCHEDULER将其出队，送往DOWNLOADER。</p>
</li>
<li><p>DOWNLOADER根据Request对象中的URL地址发送一次HTTP请求 到网站服务器，之后用服务器返回的HTTP响应构造出一个Response对象，其中包含页面的HTML文本。</p>
</li>
<li><p>Response对象最终会被递送给SPIDER的页面解析函数（构造Request对象时指定）进行处理，页面解析函数从页面中提取数据，封装成Item后提交给ENGINE，Item之后被送往ITEM </p>
<p>PIPELINES进行处理，最终可能由EXPORTER以某种数据格式写入文件（csv，json）；另一方面，页面解析函数还从页面中提取链接（URL），构造出新的 Request对象提交给ENGINE。</p>
</li>
</ul>
<h4 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h4><p>Request对象用来描述一个HTTP请求，下面是其构造器方法的参数列表：</p>
<blockquote>
<p>Request(url[, callback, method=’GET’, headers, body, cookies, meta, encoding=’utf-8’, priority=0, dont_filter=False,errback,flags])</p>
</blockquote>
<p><strong><em>Request参数介绍：</em></strong></p>
<ul>
<li><p>url（必选）</p>
<p>请求页面的url地址，bytes或str类型。</p>
</li>
<li><p>callback</p>
<p>页面解析函数， Callable类型，Request对象请求的页面下载完成后，由该参数指定的页面解析函数被调用。如果未传递该参数，默认**<em>调用Spider的parse**</em>方法。</p>
</li>
<li><p>method </p>
<p>HTTP请求的方法，默认为’GET。</p>
 <img data-src="/2022/02/21/Scrapy1/image06.png" class>

<img data-src="/2022/02/21/Scrapy1/image14.png" class>

</li>
</ul>
<p>虽然参数很多，但除了url参数外，其他都带有默认值。在构造Request对象时，通常我们只需传递一个url参数或再加一个callback参数，其他使用默认值即可。</p>
<blockquote>
<p>&gt;&gt;&gt; request = scrapy.Request(‘<a href="http://books.toscrape.com/&#39;">http://books.toscrape.com/&#39;</a>) </p>
</blockquote>
<h4 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h4><p>Response对象用来描述一个HTTP响应，Response只是一个基类，根据响应内容的不同有如下子类：</p>
<ul>
<li>TextResponse</li>
<li>HtmlResponse</li>
<li>XmlResponse</li>
</ul>
<p>当一个页面下载完成时，下载器依据HTTP响应头部中的 Content-Type信息创建某个Response的子类对象。我们通常爬取的网页，其内容是HTML文本，创建的便是HtmlResponse对象，其 中**<em>HtmlResponse和XmlResponse是TextResponse的子类**</em>。实际上，这3个子类只有细微的差别</p>
<p>​        </p>
<p><strong><em>HtmlResponse对象的属性与方法</em></strong></p>
 <img data-src="/2022/02/21/Scrapy1/image07.png" class>

 <img data-src="/2022/02/21/Scrapy1/image08.png" class>

 <img data-src="/2022/02/21/Scrapy1/image15.png" class>

 <img data-src="/2022/02/21/Scrapy1/image09.png" class>



<h3 id="Spider开发流程"><a href="#Spider开发流程" class="headerlink" title="Spider开发流程"></a>Spider开发流程</h3><p>爬虫开发的逻辑：</p>
 <img data-src="/2022/02/21/Scrapy1/image10.png" class>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> BookItem</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    <span class="comment"># 爬虫名，每一个爬虫的唯一标识</span></span><br><span class="line">    name = <span class="string">&#x27;books&#x27;</span></span><br><span class="line">    <span class="comment"># 第 1 章 1.3.4 实现 Spider</span></span><br><span class="line">    <span class="comment"># 定义爬虫爬取的起始点，起始点可以是多个，这里只有一个。</span></span><br><span class="line">    <span class="comment">#start_urls = [&#x27;http://books.toscrape.com/&#x27;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第 2 章 2.3.3 设定起始爬取点</span></span><br><span class="line">    <span class="comment"># 实现 start_resquests 方法代替start_urls类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(<span class="string">&#x27;http://books.toscrape.com/&#x27;</span>,</span><br><span class="line">                             callback=self.parse,</span><br><span class="line">                             headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozill/5.0&#x27;</span>&#125;,</span><br><span class="line">                             dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 提取数据</span></span><br><span class="line">        <span class="comment"># 重写</span></span><br><span class="line">        <span class="keyword">for</span> sel <span class="keyword">in</span> response.css(<span class="string">&#x27;article.product_pod&#x27;</span>):</span><br><span class="line">            book = BookItem() <span class="comment"># from ..items import BookItem 类</span></span><br><span class="line">            book[<span class="string">&#x27;name&#x27;</span>] = sel.xpath(<span class="string">&#x27;./h3/a/@title&#x27;</span>).extract_first()</span><br><span class="line">            book[<span class="string">&#x27;price&#x27;</span>] = sel.css(<span class="string">&#x27;p.price_color::text&#x27;</span>).extract_first()</span><br><span class="line">            <span class="keyword">yield</span> book</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第 1 章 1.3.4 实现 Spider</span></span><br><span class="line">        <span class="comment"># 以下代码值直接保存，没有通过 Item 封装数据</span></span><br><span class="line">        <span class="comment"># for book in response.css(&#x27;article.product_pod&#x27;):</span></span><br><span class="line">            <span class="comment"># name = book.xpath(&#x27;./h3/a/@title&#x27;).extract_first()</span></span><br><span class="line">            <span class="comment"># price = book.css(&#x27;p.price_color::text&#x27;).extract_first()</span></span><br><span class="line">            <span class="comment"># yield &#123;</span></span><br><span class="line">            <span class="comment">#     &#x27;name&#x27;: name,</span></span><br><span class="line">            <span class="comment">#     &#x27;price&#x27;: price</span></span><br><span class="line">            <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第 1 章 1.3.4 实现 Spider</span></span><br><span class="line">        <span class="comment"># 直接用 Selector 提取下一页链接 （没有用 LinkExtractor 提取链接）</span></span><br><span class="line">        <span class="comment"># 下一页链接在 ul.pager &gt; li.next &gt; a 里</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        &lt;ul class=&quot;pager&quot;&gt;          </span></span><br><span class="line"><span class="string">            &lt;li class=&quot;current&quot;&gt; Page 1 of 50 &lt;/li&gt;           </span></span><br><span class="line"><span class="string">            &lt;li class=&quot;next&quot;&gt;&lt;a href=&quot;catalogue/page-2.html&quot;&gt;next&lt;/a&gt;&lt;/li&gt;            </span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        #default &gt; div &gt; div &gt; div &gt; div &gt; section &gt; div:nth-child(2) &gt; div &gt; ul.pager &gt; li.next &gt; a</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># next_url = response.css(&#x27;ul.pager li.next a::attr(href)&#x27;).extract_first()</span></span><br><span class="line">        <span class="comment"># if next_url:</span></span><br><span class="line">        <span class="comment">#     next_url = response.urljoin(next_url)</span></span><br><span class="line">        <span class="comment">#     yield scrapy.Request(next_url, callback=self.parse)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第6章 使用 LinkExtractor 提取链接</span></span><br><span class="line">        <span class="comment"># 提取下一页链接重写（用 LinkExtractor提取）</span></span><br><span class="line">        <span class="comment"># 说明 from scrapy.linkextractors import LinkExtractor</span></span><br><span class="line">        le = LinkExtractor(restrict_css=<span class="string">&#x27;ul.pager li.next&#x27;</span>)</span><br><span class="line">        links = le.extract_links(response)</span><br><span class="line">        <span class="comment"># print(type(links),links)</span></span><br><span class="line">        <span class="keyword">if</span> links:</span><br><span class="line">            <span class="comment"># 用links[0]获取的Link对象属性是绝对链接地址，无需要用response.urljoin拼接</span></span><br><span class="line">            next_url = links[<span class="number">0</span>].url</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_url, callback=self.parse)</span><br></pre></td></tr></table></figure>
  <img data-src="/2022/02/21/Scrapy1/image16.png" class>



<h4 id="继承scrapy-Spider"><a href="#继承scrapy-Spider" class="headerlink" title="继承scrapy.Spider"></a>继承scrapy.Spider</h4><p>Scrapy框架提供了一个Spider基类，我们编写的Spider需要继承它</p>
<blockquote>
<p>import scrapy </p>
<p>class BooksSpider(scrapy.Spider): </p>
</blockquote>
<p>这个Spider基类实现了以下内容： </p>
<ul>
<li>供Scrapy引擎调用的<strong>接口</strong>，例如用来创建Spider实例的类方法from_crawler。 </li>
</ul>
<p>● 供用户使用的<strong>实用工具函数</strong>，例如可以调用log方法将调试信息输出到日志。 </p>
<p>● 供用户访问的<strong>属性</strong>，例如可以通过settings属性访问配置文件中的配置。 </p>
<h4 id="为Spider命名"><a href="#为Spider命名" class="headerlink" title="为Spider命名"></a>为Spider命名</h4><p>在一个Scrapy项目中可以实现多个Spider，每个Spider需要有一个能够区分彼此的唯一标识，Spider的类属性name便是这个唯一标识。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksSpider</span>(<span class="params">scrapy.Spider</span>):</span> </span><br><span class="line">    name = <span class="string">&quot;books&quot;</span> </span><br><span class="line">    	...</span><br></pre></td></tr></table></figure>
<p>执行scrapy crawl命令时就用到了这个标识，告诉Scrapy使用哪个Spider进行爬取。</p>
<h4 id="设定起始爬取点"><a href="#设定起始爬取点" class="headerlink" title="设定起始爬取点"></a>设定起始爬取点</h4><p>Spider必然要从某个或某些页面开始爬取，我们称这些页面为**<em>起始爬取点**</em>，可以通过类属性start_urls来设定起始爬取点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksSpider</span>(<span class="params">scrapy.Spider</span>):</span> </span><br><span class="line">    ... </span><br><span class="line">    start_urls = [<span class="string">&#x27;http://books.toscrape.com/&#x27;</span>]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>start_urls通常被实现成一个列表，其中放入所有起始爬取点的url。</p>
<p>请求页 面下载一定要提交Request对象，这时候，我们仅仅定义了URL列表，Spider基类的start_requests方法帮助我们基于URL构造并提交了Request对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params">object_ref</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls: </span><br><span class="line">            <span class="keyword">yield</span> self.make_requests_from_url(url)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_requests_from_url</span>(<span class="params">self, url</span>):</span> </span><br><span class="line">        <span class="keyword">return</span> Request(url, dont_filter=<span class="literal">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError ..</span><br></pre></td></tr></table></figure>
 <img data-src="/2022/02/21/Scrapy1/image11.png" class>

<p>由于起始爬取点的下载请求是由引擎调用Spider对象的 start_requests方法产生的，因此我们也可以在BooksSpider中实现start_requests方法（**<em>覆盖基类Spider的start_requests方法**</em>），直接构造并提交起始爬取点的Request对象。在某些场景下使用这种方式更加灵活，例如有时想为Request添加特定的HTTP请求头部,或想为Request指定特定的页面解析函数</p>
 <img data-src="/2022/02/21/Scrapy1/image12.png" class>





<h4 id="实现页面解析函数"><a href="#实现页面解析函数" class="headerlink" title="实现页面解析函数"></a>实现页面解析函数</h4><p>页面解析函数也就是构造Request对象时**<em>通过callback参数指定**</em> 的回调函数（或默认的parse方法）。页面解析函数是实现Spider中最核心的部分，它需要完成以下两项工作：</p>
 <img data-src="/2022/02/21/Scrapy1/image13.png" class>

<p>一个页面中可能包含多项数据以及多个链接，因此页面解析函数被要求返回一个可迭代对象（通常被实现成一个生成器函数），每次迭代返回一项数据（Item或字典）或一个Request对象。</p>
]]></content>
      <categories>
        <category>Scrapy爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Section1</title>
    <url>/2022/02/21/Section1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Stack</title>
    <url>/2021/03/11/Stack/</url>
    <content><![CDATA[<h2 id="栈刷题总结"><a href="#栈刷题总结" class="headerlink" title="栈刷题总结"></a>栈刷题总结</h2><h3 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1.有效的括号"></a>1.有效的括号</h3><h4 id="知识点补充："><a href="#知识点补充：" class="headerlink" title="知识点补充："></a>知识点补充：</h4><blockquote>
<p>stack.pop()和stack.peek的区别：</p>
<p>相同点：大家都返回栈顶元素</p>
<p>不同点：satck.pop()返回栈顶元素后会将栈顶元素删除，而stack.peek()只返回不删除</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//栈+哈希表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character,Character&gt; pairs = <span class="keyword">new</span> HashMap&lt;Character,Character&gt;();</span><br><span class="line">        pairs.put(<span class="string">&#x27;]&#x27;</span>,<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;&#125;&#x27;</span>,<span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        pairs.put(<span class="string">&#x27;)&#x27;</span>,<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">          <span class="keyword">char</span> ch = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(pairs.containsKey(ch))&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty()||stack.peek()!=pairs.get(ch))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-比较含退格的两个字符串"><a href="#2-比较含退格的两个字符串" class="headerlink" title="2.比较含退格的两个字符串"></a>2.比较含退格的两个字符串</h3><p>####2.1方法一：重构字符串(利用StringBuffer的可扩展性)</p>
<p>用栈处理字符串，如果是需要删除的元素，就将其出栈，如果是需要压入栈的元素，就使其入栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iii Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(S).equals(build(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        StringBuffer ret = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> length = str.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> ch = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(ch!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                ret.append(ch);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(ret.length()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    ret.deleteCharAt(ret.length()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//不是String类型的想转换为String类型直接引用toString()方法就行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间和空间度均为O(M+N)。</p>
<h4 id="2-2双指针"><a href="#2-2双指针" class="headerlink" title="2.2双指针"></a>2.2双指针</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暂时不懂，后期可以再看一下官方题解</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度为O(M+N),空间复杂度为O(1)。</p>
<h4 id="2-3栈"><a href="#2-3栈" class="headerlink" title="2.3栈"></a>2.3栈</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">backspaceCompare</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> build(S).equals(build(T));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">build</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack  = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            Character C = str.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(C!=<span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                stack.push(C);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!stack.isEmpty())&#123;        <span class="comment">//要考虑到栈不为空的条件</span></span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="3-化栈为队"><a href="#3-化栈为队" class="headerlink" title="3.化栈为队"></a>3.化栈为队</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        peek();</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stack2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty()&amp;&amp;stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h3 id="4-用两个栈实现队列"><a href="#4-用两个栈实现队列" class="headerlink" title="4.用两个栈实现队列"></a>4.用两个栈实现队列</h3><p>#####实现队列最直观的方式是链表，但是用栈stack也可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack2;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> stack2.isEmpty() ? -<span class="number">1</span> : stack2.pop();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.pop();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * CQueue obj = new CQueue();</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.deleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h3 id="5-用栈实现队列"><a href="#5-用栈实现队列" class="headerlink" title="5.用栈实现队列"></a>5.用栈实现队列</h3><p>为了满足队列的 <strong>FIFO</strong> 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一：使用两个栈来执行入队O(n)和出队O(1)操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">            front = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> s =  stack1.pop();</span><br><span class="line">        <span class="keyword">if</span>(!stack1.isEmpty())&#123;</span><br><span class="line">            front = stack1.peek();    <span class="comment">//j将新的栈顶元素赋值给front</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二：使用两个栈来执行入队O(1)和出队O(1)操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt;stack2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack1.isEmpty())&#123;</span><br><span class="line">            front = x;   <span class="comment">//代表每次stack1空了之后，再压入的队首元素会更新。</span></span><br><span class="line">        &#125;</span><br><span class="line">        stack1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(stack2.isEmpty())&#123;</span><br><span class="line">          <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">              stack2.push(stack1.pop());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!stack2.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> stack2.peek();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty()&amp;&amp;stack2.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用front来保存队首元素，确保在peek()操作时，如果stack2是空的，可以直接返回之前保存的队首元素。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="/2021/03/11/Stack/Users\xinghaodong\AppData\Roaming\Typora\typora-user-images\image-20210223121515059.png" alt="image-20210223121515059"></p>
<h3 id="6-用队列实现栈"><a href="#6-用队列实现栈" class="headerlink" title="6.用队列实现栈"></a>6.用队列实现栈</h3><h4 id="6-1使用两个队列"><a href="#6-1使用两个队列" class="headerlink" title="6.1使用两个队列"></a>6.1使用两个队列</h4><p>一个队列用于存储栈内元素，另一个队列作为辅助栈。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue2.offer(x);</span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.offer(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();   <span class="comment">//queue1此时就是按照栈的顺序来存储元素的，所以直接poll即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="6-2LinkedList作为堆栈和链表使用的总结"><a href="#6-2LinkedList作为堆栈和链表使用的总结" class="headerlink" title="6.2LinkedList作为堆栈和链表使用的总结"></a>6.2LinkedList作为堆栈和链表使用的总结</h4><p>ava里的LinkedList可以同时作为堆栈和队列使用，因此在使用的时候总是会弄混他们的方法，此文就简单总结一下作为不同数据结构使用时的用法。</p>
<h5 id="作为队列"><a href="#作为队列" class="headerlink" title="作为队列"></a>作为队列</h5><p><img data-src="https://upload-images.jianshu.io/upload_images/25254-15c6e9f6ec53c3f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/416/format/webp" alt="img"></p>
<p>方法</p>
<blockquote>
<p>声明</p>
</blockquote>
<p>任意两种方法：</p>
<ul>
<li>一是直接声明LinkedList：<br><code>LinkedList&lt;T&gt; q = new LinkedList&lt;T&gt;();</code></li>
<li>或者使用java.util.Queue接口，其底层关联到一个LinkedList实例。<br><strong><code>Queue&lt;T&gt; q = new LinkedList&lt;T&gt;();</code></strong><br>由于只暴露部分基于队列实现的接口，所以可以提供安全的队列实现。</li>
</ul>
<blockquote>
<p>入队</p>
</blockquote>
<p><strong><code>void offer(T v)</code></strong></p>
<blockquote>
<p>出队</p>
</blockquote>
<ul>
<li><strong><code>T poll()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T remove()</code>,  如果队列为空，则抛出异常</li>
</ul>
<blockquote>
<p>看看队首元素不移除它。</p>
</blockquote>
<ul>
<li><strong><code>T peek()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T element()</code>,  如果队列为空，则抛出异常</li>
</ul>
<blockquote>
<p>是否为空</p>
</blockquote>
<ul>
<li><code>boolean isEmpty()</code>, 空返回true，否则返回false</li>
</ul>
<h5 id="作为堆栈"><a href="#作为堆栈" class="headerlink" title="作为堆栈"></a>作为堆栈</h5><p><img data-src="https://upload-images.jianshu.io/upload_images/25254-05ecccef371c9492.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/631/format/webp" alt="img"></p>
<p>方法</p>
<blockquote>
<p>声明</p>
</blockquote>
<p>任意两种方法：</p>
<ul>
<li>一是直接声明LinkedList：<br><code>LinkedList&lt;T&gt; stack = new LinkedList&lt;T&gt;();</code></li>
<li>请注意，LinkedList实现的堆栈名称是Deque:<br><strong><code>Deque&lt;T&gt; stack = new LinkedList&lt;T&gt;();</code></strong><br>由于只暴露部分基于堆栈实现的接口，所以可以提供安全的队列实现。</li>
</ul>
<blockquote>
<p>入栈</p>
</blockquote>
<p><strong><code>void addFirst(T v)</code></strong><br> <strong><code>void push(T v)</code></strong></p>
<blockquote>
<p>出栈</p>
</blockquote>
<ul>
<li><strong><code>T pop()</code></strong></li>
<li><code>T poll()</code></li>
</ul>
<blockquote>
<p>peek()</p>
</blockquote>
<p>看看队首元素不移除它。</p>
<ul>
<li><strong><code>T peek()</code></strong>, 如果队列为空，则返回null</li>
<li><code>T element()</code>,  如果队列为空，则抛出异常</li>
</ul>
<blockquote>
<p>是否为空</p>
</blockquote>
<ul>
<li><code>boolean isEmpty()</code>, 空返回true，否则返回false</li>
</ul>
<p>####6.3用一个队列实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.top();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>


<h3 id="7-棒球比赛"><a href="#7-棒球比赛" class="headerlink" title="7.棒球比赛"></a>7.棒球比赛</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calPoints</span><span class="params">(String[] ops)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">for</span>(String op:ops)&#123;</span><br><span class="line">            <span class="keyword">if</span>(op.equals(<span class="string">&quot;+&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> top = stack.pop();</span><br><span class="line">                <span class="keyword">int</span> newtop = top+stack.peek();</span><br><span class="line">                stack.push(top);</span><br><span class="line">                stack.push(newtop);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op.equals(<span class="string">&quot;C&quot;</span>))&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(op.equals(<span class="string">&quot;D&quot;</span>))&#123;</span><br><span class="line">                stack.push(<span class="number">2</span>*stack.peek());</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(Integer.valueOf(op));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:stack)&#123;</span><br><span class="line">            ans = ans+n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-用栈操作构建数组"><a href="#8-用栈操作构建数组" class="headerlink" title="8.用栈操作构建数组"></a>8.用栈操作构建数组</h3><h3 id="9-删除最外层的括号"><a href="#9-删除最外层的括号" class="headerlink" title="9.删除最外层的括号"></a>9.删除最外层的括号</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Swagger使用</title>
    <url>/2021/04/07/Swagger%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Swagger简介"><a href="#Swagger简介" class="headerlink" title="Swagger简介"></a>Swagger简介</h2><p><strong>前后端分离</strong></p>
<p>Vue + SpringBoot<br>后端<strong>时代</strong>：前端只用管理静态页面；html ⇒ 后端。模板引擎JSP ⇒ 后端是主力。</p>
<p>前后端分离时代：</p>
<ul>
<li>后端：后端控制层，服务层，数据访问层【后端团队】</li>
<li>前端：前端控制层，视图层【前端团队】<ul>
<li>伪造后端数据，json。已经存在了，不需要后端，前端工程依旧能够跑起来。</li>
</ul>
</li>
<li>前后端如何交互？ ===&gt; API</li>
<li>前后端相对独立，松耦合；</li>
<li>前后端甚至可以部署在不同的服务器上；</li>
</ul>
<p>产生一个问题：</p>
<ul>
<li>前后端集成联调，前端人员无法和后端人员无法做到，“即时协商，尽早解决”，最终导致问题集中爆发；</li>
</ul>
<p>解决方案：</p>
<ul>
<li>首先指定schema[计划的提纲]，实时更新最新API，降低集成的风险；</li>
<li>早些年：指定word计划文档；</li>
<li>前后端分离：<ul>
<li>前端测试后端接口：postman</li>
<li>后端提供接口，需要实时更新最新的消息及改动！</li>
</ul>
</li>
</ul>
<h2 id="Swagger"><a href="#Swagger" class="headerlink" title="Swagger"></a>Swagger</h2><ul>
<li>号称世界上最流行的Api框架</li>
<li>RestFul Api 文档在线自动生成工具 =&gt; Api文档与Api定义同步更新</li>
<li>直接运行，可以在线测试API接口；</li>
<li>支持多种语言：（Java、Php…）</li>
</ul>
<p>官网：<a href="https://swagger.io/">https://swagger.io/</a></p>
<p>在项目中使用swagger需要springbox；</p>
<ul>
<li>swagger2</li>
<li>ui</li>
</ul>
<h2 id="SpringBoot集成Swagger"><a href="#SpringBoot集成Swagger" class="headerlink" title="SpringBoot集成Swagger"></a>SpringBoot集成Swagger</h2><ol>
<li>新建一个SpringBoot - web项目</li>
<li>导入相关依赖<img data-src="/2021/04/07/Swagger%E4%BD%BF%E7%94%A8/01.png" class>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个Hello工程</li>
<li>配置Swagger ==&gt; Config</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.swagger.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> springfox.documentation.swagger2.annotations.EnableSwagger2;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>   <span class="comment">// 开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>
<ol>
<li>测试运行 <a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></li>
<li><img data-src="/2021/04/07/Swagger%E4%BD%BF%E7%94%A8/03.png" class>

</li>
</ol>
<h2 id="配置Swagger"><a href="#配置Swagger" class="headerlink" title="配置Swagger"></a>配置Swagger</h2><p>swagger的bean实例Docket；（在上面SwaggerConfig 类中添加）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger2</span>   <span class="comment">// 开启Swagger2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置了swagger的Docket 的 bean 实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置 swagger 信息 = apiInfo</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">apiInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//作者信息</span></span><br><span class="line">        Contact contact = <span class="keyword">new</span> Contact(<span class="string">&quot;秦疆&quot;</span>, <span class="string">&quot;https://blog.kuangstudy.com/&quot;</span>, <span class="string">&quot;24736743@qq.com&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfo(<span class="string">&quot;狂神的SwaggerAPI文档&quot;</span>,</span><br><span class="line">                <span class="string">&quot;即时在小的帆也能远航&quot;</span>,</span><br><span class="line">                <span class="string">&quot;v1.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://blog.kuangstudy.com/&quot;</span>,</span><br><span class="line">                contact,</span><br><span class="line">                <span class="string">&quot;Apache 2.0&quot;</span>,</span><br><span class="line">                <span class="string">&quot;http://www.apache.org/licenses/LICENSE-2.0&quot;</span>,</span><br><span class="line">                <span class="keyword">new</span> ArrayList()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>
<h2 id="Swagger配置扫描接口"><a href="#Swagger配置扫描接口" class="headerlink" title="Swagger配置扫描接口"></a>Swagger配置扫描接口</h2><p>Docket.select()<br>接着上面的docket() 讲解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//配置了swagger的Docket 的 bean 实例</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                <span class="comment">// RequestHandlerSelectors, 配置要扫描的包</span></span><br><span class="line">                <span class="comment">// basePackage(): 指定要扫描的包</span></span><br><span class="line">                <span class="comment">// any(): 扫描全部</span></span><br><span class="line">                <span class="comment">// none(): 都不扫描</span></span><br><span class="line">                <span class="comment">// withClassAnnotation : 扫描类上的注解, 参数是一个注解的反射对象</span></span><br><span class="line">                <span class="comment">// 例如：withClassAnnotation(RestController.class) 只扫描类上有@RestController的生成文档</span></span><br><span class="line">                <span class="comment">// withMethodAnnotation: 扫描方法上的注解, 参数是一个注解的反射对象</span></span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.swagger.controller&quot;</span>))</span><br><span class="line">                <span class="comment">// paths(): 过滤什么路径</span></span><br><span class="line">                .paths(PathSelectors.ant(<span class="string">&quot;/kuang/**&quot;</span>))</span><br><span class="line">                .build();  <span class="comment">//build</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p>配置是否启动Swagger（<strong>enable 是否启动Swagger， 如果为false， 则Swagger 不能再浏览器中访问</strong>）</p>
<img data-src="/2021/04/07/Swagger%E4%BD%BF%E7%94%A8/03.png" class>
<p>问题：我只希望我的Swagger在生产环境中使用，在发布的时候不使用？<br>解题思路：</p>
<ul>
<li>判断是不是生产环境 flag = false</li>
<li>注入enable(flag)</li>
</ul>
<p>解题步骤：<br>1.先在resources目录下创建两个properties文件，如下图</p>
<img data-src="/2021/04/07/Swagger%E4%BD%BF%E7%94%A8/04.png" class>
<p>接下来在application.properties文件中激活环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在application-dev.properties中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8081</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>在application-pro.properties中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8082</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>2.接着上面的docket()，在方法中加入形参Environment获取application.properties中的设置的环境</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Docket <span class="title">docket</span><span class="params">(Environment environment)</span></span>&#123;</span><br><span class="line">     <span class="comment">// 设置要显示的Swagger环境</span></span><br><span class="line">     Profiles profiles = Profiles.of(<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">     <span class="comment">// 通过 environment.acceptsProfiles(profiles) 判断是否处在自己设定的环境当中</span></span><br><span class="line">     <span class="keyword">boolean</span> flag = environment.acceptsProfiles(profiles);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">             .apiInfo(apiInfo())</span><br><span class="line">             <span class="comment">//此处判断是生产环境 flag 就是为true 就可以访问Swagger</span></span><br><span class="line">             .enable(flag)</span><br><span class="line">             </span><br><span class="line">             .select()</span><br><span class="line">             .apis(RequestHandlerSelectors.basePackage(<span class="string">&quot;com.kuang.swagger.controller&quot;</span>))</span><br><span class="line"><span class="comment">//                .paths(PathSelectors.ant(&quot;/kuang/**&quot;))</span></span><br><span class="line">             .build();  <span class="comment">//build</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>
<p>3.在浏览器上请求<a href="http://localhost:8081/swagger-ui.html#/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AESwagger%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9spring.profiles.active%E4%B8%BApro">http://localhost:8081/swagger-ui.html#/就可以访问Swagger，我们可以修改spring.profiles.active为pro</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">spring.profiles.active=pro</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>然后在浏览器上请求<a href="http://localhost:8082/swagger-ui.html#/%E4%BC%9A%E5%87%BA%E7%8E%B0%F0%9F%98%B1">http://localhost:8082/swagger-ui.html#/会出现😱</a> Could not render e, see the console.</p>
<h2 id="配置API文档的分组"><a href="#配置API文档的分组" class="headerlink" title="配置API文档的分组"></a>配置API文档的分组</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">.groupName(<span class="string">&quot;狂神&quot;</span>)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>配置多个分组，多个Docket实例即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Docket <span class="title">docket1</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;A&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Docket <span class="title">docket2</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;B&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="meta">@Bean</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Docket <span class="title">docket3</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2).groupName(<span class="string">&quot;C&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>
<p>Swagger中就会出现多个分组</p>
<img data-src="/2021/04/07/Swagger%E4%BD%BF%E7%94%A8/05.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.swagger.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModel(&quot;用户实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;用户名&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty(&quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>
<p>controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kuang.swagger.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kuang.swagger.pojo.User;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiOperation;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PostMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只要我们的接口中，返回值中存在实体类, 他就会扫描到Swagger中</span></span><br><span class="line">    <span class="meta">@PostMapping(value = &quot;/user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;hello控制类&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/hello2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello2</span><span class="params">(<span class="meta">@ApiParam(&quot;用户名&quot;)</span> String username)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@ApiOperation(&quot;Post测试类&quot;)</span></span><br><span class="line">    <span class="meta">@GetMapping(value = &quot;/postt&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">postt</span><span class="params">(<span class="meta">@ApiParam(&quot;用户名&quot;)</span> User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>我们可以通过Swagger给一些比较比较难理解的属性后接口，增加注释信息</li>
<li>接口文档实时更新</li>
<li>可以在线测试</li>
</ol>
]]></content>
      <categories>
        <category>项目工具</category>
      </categories>
      <tags>
        <tag>Swagger</tag>
      </tags>
  </entry>
  <entry>
    <title>Undo页与redo页</title>
    <url>/2021/02/14/Undo%E9%A1%B5%E4%B8%8Eredo%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h2><p>是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用Undo Log来实现多版本并发控制(简称：MVCC)。</p>
<ul>
<li>事务的原子性(Atomicity)<br>事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。</li>
<li>原理<br>Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为Undo Log）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。<br>除了可以保证事务的原子性，Undo Log也可以用来辅助完成事务的持久化。</li>
<li>事务的持久性(Durability)<br>事务一旦完成，该事务对数据库所做的所有修改都会持久的保存到数据库中。为了保证持久性，数据库系统会将修改后的数据完全的记录到持久的存储上。</li>
<li>用Undo Log实现原子性和持久化的事务的简化过程<br>假设有A、B两个数据，值分别为1,2。<br>A.事务开始.<br>B.记录A=1到undo log.<br>C.修改A=3.<br>D.记录B=2到undo log.<br>E.修改B=4.<br>F.将undo log写到磁盘。<br>G.将数据写到磁盘。<br>H.事务提交<br>这里有一个隐含的前提条件：‘数据都是先读到内存中，然后修改内存中的数据，最后将数据写回磁盘’。</li>
</ul>
<p>之所以能同时保证原子性和持久化，是因为以下特点：<br>A. 更新数据前记录Undo log。<br>B. 为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>C. Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的,可以用来回滚事务。</p>
<p>D. 如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p>
<p>缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。</p>
<p>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一<br>种机制来实现持久化，即Redo Log.</p>
<h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><ul>
<li>原理<br>和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，<br>不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</li>
<li>Undo + Redo事务的简化过程<br>假设有A、B两个数据，值分别为1,2.<br>A.事务开始.<br>B.记录A=1到undo log.<br>C.修改A=3.<br>D.记录A=3到redo log.<br>E.记录B=2到undo log.<br>F.修改B=4.<br>G.记录B=4到redo log.<br>H.将redo log写入磁盘。<br>I.事务提交</li>
<li>Undo + Redo事务的特点<br>A. 为了保证持久性，必须在事务提交前将Redo Log持久化。<br>B. 数据不需要在事务提交前写入磁盘，而是缓存在内存中。<br>C. Redo Log保证事务的持久性。<br>D. Undo Log保证事务的原子性。<br>E. 有一个隐含的特点，数据必须要晚于redo log写入持久存储。</li>
<li>IO性能<br>Undo + Redo的设计主要考虑的是提升IO性能。虽说通过缓存数据，减少了写数据的IO. 但是却引入了新的IO，即写Redo Log的IO。如果Redo Log的IO性能不好，就不能起到提高性能的目的。</li>
</ul>
<p>为了保证Redo Log能够有比较好的IO性能，InnoDB 的 Redo Log的设计有以下几个特点：</p>
<p>A. 尽量保持Redo Log存储在一段连续的空间上。因此在系统第一次启动时就会将日志文件的空间完全分配。以顺序追加的方式记录Redo Log,通过顺序IO来改善性能。<br>B. 批量写入日志。日志并不是直接写入文件，而是先写入redo log buffer.当需要将日志刷新到磁盘时 (如事务提交),将许多日志一起写入磁盘.<br>C. 并发的事务共享Redo Log的存储空间，它们的Redo Log按语句的执行顺序，依次交替的记录在一起，以减少日志占用的空间。例如,Redo Log中的记录内容可能是这样的：<br>记录1: &lt;trx1, insert …&gt;<br>记录2: &lt;trx2, update …&gt;<br>记录3: &lt;trx1, delete …&gt;<br>记录4: &lt;trx3, update …&gt;<br>记录5: &lt;trx2, insert …&gt;<br>D. 因为C的原因,当一个事务将Redo Log写入磁盘时，也会将其他未提交的事务的日志写入磁盘。<br>E. Redo Log上只进行顺序追加的操作，当一个事务需要回滚时，它的Redo Log记录也不会从Redo Log中删除掉。</p>
<h2 id="恢复-Recovery"><a href="#恢复-Recovery" class="headerlink" title="恢复(Recovery)"></a>恢复(Recovery)</h2><ul>
<li>恢复策略<br>前面说到未提交的事务和回滚了的事务也会记录Redo Log，因此在进行恢复时,这些事务要进行特殊的的处理.有2中不同的恢复策略：<br>A. 进行恢复时，只重做已经提交了的事务。<br>B. 进行恢复时，重做所有事务包括未提交的事务和回滚了的事务。然后通过Undo Log回滚那些未提交的事务。</li>
<li>InnoDB存储引擎的恢复机制<br>MySQL数据库InnoDB存储引擎使用了B策略, InnoDB存储引擎中的恢复机制有几个特点：<br>A. 在重做Redo Log时，并不关心事务性。 恢复时，没有BEGIN，也没有COMMIT,ROLLBACK的行为。也不关心每个日志是哪个事务的。尽管事务ID等事务相关的内容会记入Redo Log，这些内容只是被当作要操作的数据的一部分。<br>B. 使用B策略就必须要将Undo Log持久化，而且必须要在写Redo Log之前将对应的Undo Log写入磁盘。<br>Undo和Redo Log的这种关联，使得持久化变得复杂起来。为了降低复杂度，InnoDB将Undo Log看作数据，因此记录Undo Log的操作也会记录到redo log中。这样undo log就可以象数据一样缓存起来， 而不用在redo log之前写入磁盘了。<br>包含Undo Log操作的Redo Log，看起来是这样的<br>记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;<br>记录2: &lt;trx1, insert …&gt;<br>记录3: &lt;trx2, Undo log insert &lt;undo_update …&gt;&gt;<br>记录4: &lt;trx2, update …&gt;<br>记录5: &lt;trx3, Undo log insert &lt;undo_delete …&gt;&gt;<br>记录6: &lt;trx3, delete …&gt;<br>C. 到这里，还有一个问题没有弄清楚。既然Redo没有事务性，那岂不是会重新执行被回滚了的事务？<br>确实是这样。同时Innodb也会将事务回滚时的操作也记录到redo log中。回滚操作本质上也是对数据进行修改，因此回滚时对数据的操作也会记录到Redo Log中。<br>一个回滚了的事务的Redo Log，看起来是这样的：<br>记录1: &lt;trx1, Undo log insert &lt;undo_insert …&gt;&gt;<br>记录2: &lt;trx1, insert A…&gt;<br>记录3: &lt;trx1, Undo log insert &lt;undo_update …&gt;&gt;<br>记录4: &lt;trx1, update B…&gt;<br>记录5: &lt;trx1, Undo log insert &lt;undo_delete …&gt;&gt;<br>记录6: &lt;trx1, delete C…&gt;<br>记录7: &lt;trx1, insert C&gt;<br>记录8: &lt;trx1, update B to old value&gt;<br>记录9: &lt;trx1, delete A&gt;<br>一个被回滚了的事务在恢复时的操作就是先redo再undo，因此不会破坏数据的一致性.</li>
<li>InnoDB存储引擎中相关的函数<br>Redo: recv_recovery_from_checkpoint_start()<br>Undo: recv_recovery_rollback_active()<br>Undo Log的Redo Log: trx_undof_page_add_undo_rec_log()</li>
</ul>
]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>InnoDB存储引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>XML配置文件详解</title>
    <url>/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="配置文档顶层结构"><a href="#配置文档顶层结构" class="headerlink" title="配置文档顶层结构"></a>配置文档顶层结构</h2><img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/01.png" class>



<h2 id="属性（properties"><a href="#属性（properties" class="headerlink" title="属性（properties)"></a>属性（properties)</h2><h3 id="属性配置的几种方式"><a href="#属性配置的几种方式" class="headerlink" title="属性配置的几种方式"></a>属性配置的几种方式</h3><blockquote>
<p>在外部进行配置，并且进行动态替换，即在Java属性文件中配置这些属性</p>
</blockquote>
<blockquote>
<p>在properties元素的子元素中进行设置</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dev_user&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;F2Fa3!33TYyg&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，既使用了外部文件进行配置的方式，又使用了子元素配置方式。</p>
<p>设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username&#125;&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中的 username 和 password 将会由 properties 子元素中设置的相应值来替换。</p>
<p>driver 和 url 属性将会由 config.properties 文件中对应的值来替换。这样就为配置提供了诸多灵活选择。</p>
<blockquote>
<p>在 SqlSessionFactoryBuilder.build() 方法中传入属性值</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, props);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 或者 ...</span></span><br><span class="line"></span><br><span class="line">SqlSessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader, environment, props);</span><br></pre></td></tr></table></figure>


<h3 id="属性配置读取的优先级"><a href="#属性配置读取的优先级" class="headerlink" title="属性配置读取的优先级"></a>属性配置读取的优先级</h3><p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p>
<ul>
<li>首先读取在 properties 元素体内指定的属性。          </li>
<li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据          url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。          </li>
<li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。          </li>
</ul>
<p>因此，<strong>通过方法参数传递的属性具有最高优先级，resource/url        属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性</strong>。</p>
<h3 id="使用占位符指定默认值"><a href="#使用占位符指定默认值" class="headerlink" title="使用占位符指定默认值"></a>使用占位符指定默认值</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;username:ut_user&#125;&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 如果属性 &#x27;username&#x27; 没有被配置，&#x27;username&#x27; 属性的值将为 &#x27;ut_user&#x27; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个特性默认是关闭的，需要添加一个特定的属性；欸启用这个特性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis.parsing.PropertyParser.enable-default-value&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 启用默认值特性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果你在属性名中使用了 <code>&quot;:&quot;</code> 字符（如：<code>db:username</code>），或者在 SQL 映射中使用了 OGNL 表达式的三元运算符（如： <code>$&#123;tableName != null ?tableName : &#39;global_constants&#39;&#125;</code>），就需要设置特定的属性来修改分隔属性名和默认值的字符。例如：        </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;org/mybatis/example/config.properties&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;org.apache.ibatis.parsing.PropertyParser.default-value-separator&quot;</span> <span class="attr">value</span>=<span class="string">&quot;?:&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 修改默认值的分隔符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;db:username?:ut_user&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="设置（settings"><a href="#设置（settings" class="headerlink" title="设置（settings)"></a>设置（settings)</h2><p>MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。</p>
<p>具体的详细设置类目不在罗列，可以参考官方文档。</p>
<blockquote>
<p>一个完整的settings元素的示例</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="类型别名（typeAliases"><a href="#类型别名（typeAliases" class="headerlink" title="类型别名（typeAliases)"></a>类型别名（typeAliases)</h2><p>类型别名可为 Java 类型设置一个缩写名字。它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Post&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Post&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Section&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Section&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Tag&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Tag&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>


<blockquote>
<p>也可以指定一个包名,mybatis会在包名下面搜索需要的Java Bean</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line">&lt;/typeAliases</span><br></pre></td></tr></table></figure>
<p>每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean的首字母小写的非限定类名来作为它的别名。比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="java内建的类型别名"><a href="#java内建的类型别名" class="headerlink" title="java内建的类型别名"></a>java内建的类型别名</h3><img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/02.png" class>

<img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/03.png" class>





<h2 id="对象工厂-objectFactory"><a href="#对象工厂-objectFactory" class="headerlink" title="对象工厂(objectFactory)"></a>对象工厂(objectFactory)</h2><p>每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来<strong>完成实例化工作</strong>。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。 如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ExampleObjectFactory.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleObjectFactory</span> <span class="keyword">extends</span> <span class="title">DefaultObjectFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.create(type);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">create</span><span class="params">(Class type, List&lt;Class&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.create(type, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collection.class.isAssignableFrom(type);</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">&quot;org.mybatis.example.ExampleObjectFactory&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;someProperty&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ObjectFactory 接口很简单，它包含两个创建实例用的方法，一个是处理默认无参构造方法的，另外一个是处理带参数的构造方法的 。另外，setProperties 方法可以被用来配置ObjectFactory，在初始化你的 ObjectFactory 实例后， objectFactory 元素体中定义的属性会被传递给 setProperties 方法。</p>
<h2 id="数据库厂商标识"><a href="#数据库厂商标识" class="headerlink" title="数据库厂商标识"></a>数据库厂商标识</h2><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 <code>databaseId</code> 属性。 MyBatis 会加载带有匹配当前数据库 <code>databaseId</code> 属性和所有不带 <code>databaseId</code> 属性的语句。 如果同时找到带有 <code>databaseId</code> 和不带 <code>databaseId</code> 的相同语句，则后者会被舍弃。 为支持多厂商特性，只要像下面这样在 mybatis-config.xml 文件中加入 <code>databaseIdProvider</code> 即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>databaseIdProvider 对应的 DB_VENDOR 实现会将 databaseId 设置为          <code>DatabaseMetaData#getDatabaseProductName()</code> 返回的字符串。          由于通常情况下这些字符串都非常长，而且相同产品的不同版本会返回不同的值，你可能想通过设置属性别名来使其变短：        </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;SQL Server&quot;</span> <span class="attr">value</span>=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DB2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;db2&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Oracle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;oracle&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 在提供了属性别名时，databaseIdProvider 的 DB_VENDOR 实现会将 databaseId 设置为数据库产品名与属性中的名称第一个相匹配的值，如果没有匹配的属性，将会设置为 “null”。 在这个例子中，如果          </p>
<p><code>getDatabaseProductName()</code> 返回“Oracle (DataDirect)”，databaseId 将被设置为“oracle”。      </p>
<p>你可以通过实现接口 <code>org.apache.ibatis.mapping.DatabaseIdProvider</code> 并在 mybatis-config.xml 中注册来构建自己的 DatabaseIdProvider：        </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DatabaseIdProvider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties p)</span> </span>&#123; <span class="comment">// 从 3.5.2 开始，该方法为默认方法</span></span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">String <span class="title">getDatabaseId</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="映射文件（mappers）"><a href="#映射文件（mappers）" class="headerlink" title="映射文件（mappers）"></a>映射文件（mappers）</h2><p>首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉MyBatis 到哪里去找映射文件。 你可以使用相对于**<u>类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。</u>**</p>
<img data-src="/2021/03/13/XML%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/04.png" class>





















]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>中断</title>
    <url>/2021/02/03/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断使得硬件得以发出通知给处理器，是一种变内核主动为硬件主动的方式。中断本质上是一种特殊的电信号。硬件在生成中断的时候并不需要考虑与处理器的时钟同步，即中断可以随时产生，<strong>内核随时可能因为新到来的中断而被打断</strong>。</p>
<img data-src="/2021/02/03/%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD1.png" class>

<p>不同的设备对应的中断不同，而每个中断都通过唯一的数字标识，这样，操作系统才能给不同的中断提供对应的中断处理程序。硬件发出中断，就是在提醒内核，有新的请求需要读取并处理。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>异常与中断不同之处就是在于异常在产生时必须要考虑处理器与时钟同步，所以其经常被称为同步中。</p>
<p>异常的产生原因：</p>
<blockquote>
<p>1.处理器由于执行到编程失误而导致的错误指令（如被0除）</p>
</blockquote>
<blockquote>
<p>2.执行期间出现特殊情况，例如缺页</p>
</blockquote>
<blockquote>
<p>3.系统调用陷入内核—–引起了系统调用处理程序异常</p>
</blockquote>
<p>以上，产生异常，都需要内核处理。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>内核通过执行中断处理程序(interrupt handler)来对某一特定的中断进行响应，产生中断的每一个设备都有一个相应的中断处理程序。一个设备的中断处理程序是其设备驱动程序的一部分—–设备驱动程序是<strong>用于对设备进行管理的内核代码</strong>。</p>
<p>中断处理程序被内核调用，运行于中断上下文，该上下文的执行代码不可阻塞。</p>
<h3 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h3><p>将中断处理分为两个部分。</p>
<blockquote>
<p>中断处理程序是上半部分（top half），接收到一个中断会被立即执行，只做有严格时限的工作。</p>
</blockquote>
<blockquote>
<p>能够被允许稍后完成的工作会被推迟到下半部去执行。即处理和操作中断的非即时完成请求会在随后的下半部中执行。</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><p>当执行一个中断处理程序时，内核处于中断上下文中(interrupt context)。</p>
<p>注意：</p>
<ul>
<li>中断上下文没有后备进程，所以其不可以睡眠。如果一个函数要进行睡眠，就不能出现在中断处理程序中。</li>
<li>中断处理程序实际上打断了其他的代码，这种异步执行的特性，要求所有的中断处理程序必须尽可能的快速、简单。尽量将工作从中断处理程序中分离出来，放在中断下半部执行。</li>
<li>中断处理程序栈是一个配置选项。在内核早期版本中，中断处理程序是共享别人的堆栈，获取空间时非常节约。后期，中断处理程序有了自己的栈（中断栈），但无论无何，在内核中还是要尽可能的节省空间的使用，因为内核栈本身就是有限的。</li>
<li><strong>进程上下文是可以睡眠的</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数现代硬件都通过中断来与操作系统进行通信。对给定的硬件进行管理的驱动程序注册中断处理程序，是为了响应并处理来自相关硬件的中断。中断过程所作的工作包括应答并重新设置硬件，从设备拷贝数据到内存以及反之，处理硬件请求，并发送新的硬件请求。</p>
<p>内核提供的接口包括注册和注销中断处理程序、禁止中断、屏蔽中断线以及检查中断系统的状态。</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>云计算</title>
    <url>/2021/10/07/%E4%BA%91%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>创建高性能索引</title>
    <url>/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>索引（在MySQL中也叫做“键（key）是**<em>存储引擎用于快速找到记录**</em>的一种数据结构。 这是索引的基本功能。在MySQL中，存储引擎用书本目录类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行</p>
<p>索引可以包含一个或多个列的值。如果索引包含多个列，那么**<em>列的顺序**</em>也十分重要，因为MySQL只能高效地使用索引的<u><strong>最左前缀列</strong></u>。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的，</p>
<p><img data-src="/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220222091253478.png" alt="image-20220222091253478"></p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>索引有很多种类型，可以为不同的场景提供更好的性能。在MySQL中，索引是在**<em>存储引擎层**</em>而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<p>MySQL支持的索引类型，以及它们的优点和缺点如下：</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引，它使用 B-Tree数据结构来存储数据，大多数MySQL引擎都支持这种索引。</p>
<blockquote>
<p>实际上很多存储引擎使用的是**<em>B+Tree**</em>,即每一个叶子节点都包含指向下一个叶子节点的指针，从 而方便叶子节点的范围遍历。</p>
</blockquote>
<p>存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MylSAM 使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如 MylSAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</p>
<p><img data-src="/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220222092648551.png" alt="image-20220222092648551"></p>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层査找。通过比较节点页的值和要査找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值 的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页（不同引擎的“指针”类型不同）    </p>
<blockquote>
<p>B-Tree对索引列是顺序组织存储的，所以很适合査找范围数据。索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">	last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    dob 	  <span class="type">date</span>         <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender    enum(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>.</span><br><span class="line">    key(last_name,first_name,dob)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>
<p><strong><em>B-Tree索引对以下类型的查询有效：</em></strong><br><img data-src="/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220222093555561.png" alt="image-20220222093555561"></p>
]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库索引</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列MQ</title>
    <url>/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/</url>
    <content><![CDATA[<h2 id="MQ的基本概念"><a href="#MQ的基本概念" class="headerlink" title="MQ的基本概念"></a>MQ的基本概念</h2><p>MQ全称 Message Queue（消息队列），是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。消息队列已经逐渐成为企业IT系统内部通信的核心手段。它具有低耦合、可靠投递、广播、流量控制、最终一致性等一系列功能，成为异步RPC的主要手段之一。 当今市面上有很多主流的消息中间件，如老牌的ActiveMQ、RabbitMQ，炙手可热的Kafka，阿里巴巴自主开发的Notify、MetaQ、RocketMQ等。</p>
<p>当你需要使用消息队列时，首先需要考虑它的必要性。可以使用mq的场景有很多，最常用的几种，是做业务解耦/最终一致性/广播/错峰流控等。反之，如果需要强一致性，关注业务逻辑的处理结果，则RPC显得更为合适</p>
<p>如果没有消息队列，分布式系统之间可能互相通过远程调用来实现不同系统之间的访问。</p>
 <img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/01.png" class>

<p>MQ，消息队列，存储消息的<strong>中间件</strong>,分布式系统通信两种方式：直接远程调用 和 借助第三方 完成间接通信,发送方称为生产者，接收方称为消费者。</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/02.png" class>

<h2 id="MQ的优势与劣势"><a href="#MQ的优势与劣势" class="headerlink" title="MQ的优势与劣势"></a>MQ的优势与劣势</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><blockquote>
<p>应用解耦</p>
</blockquote>
<p>解耦是消息队列要解决的最本质问题。所谓解耦，简单点讲就是一个事务，只关心核心的流程。而需要依赖其他系统但不那么重要的事情，**==有通知即可，无需等待结果==**。换句话说，基于消息的模型，关心的是“通知”，而非“处理”。 </p>
<p>比如在美团旅游，我们有一个产品中心，产品中心上游对接的是主站、移动后台、旅游供应链等各个数据源；下游对接的是筛选系统、API系统等展示系统。当上游的数据发生变更的时候，如果不使用消息系统，势必要调用我们的接口来更新数据，就特别依赖产品中心接口的稳定性和处理能力。但其实，作为旅游的产品中心，也许只有对于旅游自建供应链，产品中心更新成功才是他们关心的事情。而对于团购等外部系统，产品中心更新成功也好、失败也罢，并不是他们的职责所在。他们只需要保证在信息变更的时候通知到我们就好了。 而我们的下游，可能有更新索引、刷新缓存等一系列需求。对于产品中心来说，这也不是我们的职责所在。说白了，如果他们定时来拉取数据，也能保证数据的更新，只是实时性没有那么强。但使用接口方式去更新他们的数据，显然对于产品中心来说太过于“重量级”了，只需要发布一个产品ID变更的通知，由下游系统来处理，可能更为合理。 再举一个例子，对于我们的订单系统，订单最终支付成功之后可能需要给用户发送短信积分什么的，但其实这已经不是我们系统的核心流程了。如果外部系统速度偏慢（比如短信网关速度不好），那么主流程的时间会加长很多，用户肯定不希望点击支付过好几分钟才看到结果。那么我们只需要通知短信系统“我们支付成功了”，不一定非要等待它处理完成。</p>
 <img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/03.png" class>

<p>例如，在上面的例子中，订单系统过分依赖剩余四个系统。用户向订单系统发送消息，订单系统分别向下层的四个系统传递用户消息。这样一来，不仅时间上效率很低，而且，一旦下层的某个系统挂掉，订单系统以及上层用户迟迟得不到反馈，这对于“争分夺秒”的电商行业是不能承受的。而添加了MQ之后，订单系统只需要将消息发给MQ，并且MQ可以先行通知用户操作成功，而不一定非要等到下层子系统操作完成之后在进行反馈。同时，如果下层系统挂掉(通常很快就可以修复，只有几分钟，但是对业务的影响是巨大的），订单系统因为由消息队列的存在，仍旧可以给予用户反馈，提升了客户的访问体验。</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/04.png" class>

<blockquote>
<p>异步提速，削峰填谷</p>
</blockquote>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/05.png" class>

<p><strong>在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下数据库压力剧增，使得响应速度变慢。但是在使用消息队列之后，用户的请求数据发送给消息队列之后立即 返回，再由消息队列的消费者进程从消息队列中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库（消息队列也比数据库有更好的伸缩性），因此响应速度得到大幅改善。</strong></p>
<p>通过以上分析我们可以得出<strong>消息队列具有很好的削峰作用的功能</strong>——即<strong>通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。</strong> 举例：在电子商务一些秒杀、促销活动中，合理使用消息队列可以有效抵御促销活动刚开始大量订单涌入对系统的冲击。如下图所示：</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/06.png" class>

<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/07.png" class>

<p>因为<strong>用户请求数据写入消息队列之后就立即返回给用户了，但是请求数据在后续的业务校验、写数据库等操作中可能失败</strong>。因此使用消息队列进行异步处理之后，需要<strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，订单数据写入消息队列，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>，以免交易纠纷。这就类似我们平时手机订火车票和电影票。</p>
<blockquote>
<p>利用消息队列实现事件驱动结构</p>
</blockquote>
<p>最常见的<strong>事件驱动架构</strong>类似生产者消费者模式，在大型网站中通常用利用消息队列实现事件驱动结构。</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/08.png" class>

<p><strong>消息队列利用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接受者（消费者）订阅消息。</strong> 从上图可以看到<strong>消息发送者（生产者）和消息接受者（消费者）之间没有直接耦合</strong>，消息发送者将消息发送至分布式消息队列即结束对消息的处理，消息接受者从分布式消息队列获取该消息后进行后续处理，并不需要知道该消息从何而来。<strong>对新增业务，只要对该类消息感兴趣，即可订阅该消息，对原有系统和业务没有任何影响，从而实现网站业务的可扩展性设计</strong>。</p>
<p>消息接受者对消息进行过滤、处理、包装后，构造成一个新的消息类型，将消息继续发送出去，等待其他消息接受者订阅该消息。因此基于事件（消息对象）驱动的业务架构可以是一系列流程。</p>
<p><strong>另外为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。</strong></p>
<p><strong>备注：</strong> 不要认为消息队列只能利用发布-订阅模式工作，只不过在解耦这个特定业务环境下是使用发布-订阅模式的。<strong>除了发布-订阅模式，还有点对点订阅模式（一个消息只有一个消费者），我们比较常用的是发布-订阅模式。</strong> 另外，这两种消息模型是 JMS 提供的，AMQP 协议还提供了 5 种消息模型。</p>
<blockquote>
<p>广播</p>
</blockquote>
<p>消息队列的基本功能之一是进行广播。如果没有消息队列，每当一个新的业务方接入，我们都要联调一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。 比如本文开始提到的产品中心发布产品变更的消息，以及景点库很多去重更新的消息，可能“关心”方有很多个，但产品中心和景点库只需要发布变更消息即可，谁关心谁接入。</p>
<blockquote>
<p>错峰与流控</p>
</blockquote>
<p>试想上下游对于事情的处理能力是不同的。比如，Web前端每秒承受上千万的请求，并不是什么神奇的事情，只需要加多一点机器，再搭建一些LVS负载均衡设备和Nginx等即可。但<strong>数据库的处理能力却十分有限</strong>，即使使用SSD加分库分表，单机的处理能力仍然在万级。由于成本的考虑，我们不能奢求数据库的机器数量追上前端。 这种问题同样存在于系统和系统之间，如短信系统可能由于短板效应，速度卡在网关上（每秒几百次请求），跟前端的并发量不是一个数量级。但用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过协商、滑动窗口等复杂的方案也不是说不能实现。但系统复杂性指数级增长，势必在上游或者下游做存储，并且要处理定时、拥塞等一系列问题。而且每当有处理能力有差距的时候，都需要单独开发一套逻辑来维护这套逻辑。所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p>
<p>总而言之，消息队列不是万能的。<strong>对于需要强事务保证而且延迟敏感的，RPC是优于消息队列</strong>的。 <strong>对于一些无关痛痒，或者对于别人非常重要但是对于自己不是那么关心的事情，可以利用消息队列去做。</strong> 支持最终一致性的消息队列，能够用来处理<strong>延迟不那么敏感</strong>的“分布式事务”场景，而且相对于笨重的分布式事务，可能是更优的处理方式。 当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的“漏斗”。在下游有能力处理的时候，再进行分发。 如果下游有很多系统关心你的系统发出的通知的时候，果断地使用消息队列吧</p>
<h3 id="MQ的劣势"><a href="#MQ的劣势" class="headerlink" title="MQ的劣势"></a>MQ的劣势</h3><blockquote>
<p>一致性问题</p>
</blockquote>
<p>A 系统处理完业务，通过 MQ 给B、C、D三个系统发消息数据，如果 B 系统、C 系统处理成功，D 系统处理失败。如何保证消息数据处理的一致性？</p>
<p>最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。当然有个时间限制，理论上越快越好，但实际上在各种异常的情况下，可能会有一定延迟达到最终一致状态，但最后两个系统的状态是一样的。 </p>
<p>业界有一些为“最终一致性”而生的消息队列，如Notify（阿里）、QMQ（去哪儿）等，其设计初衷，就是为了交易系统中的高可靠通知。 </p>
<p>以一个银行的转账过程来理解最终一致性，转账的需求很简单，如果A系统扣钱成功，则B系统加钱一定成功。反之则一起回滚，像什么都没发生一样。 然而，这个过程中存在很多可能的意外： 1. A扣钱成功，调用B加钱接口失败。 2. A扣钱成功，调用B加钱接口虽然成功，但获取最终结果时网络异常引起超时。 3. A扣钱成功，B加钱失败，A想回滚扣的钱，但A机器down机。</p>
<p>可见，想把这件看似简单的事真正做成，真的不那么容易。所有跨VM的一致性问题，从技术的角度讲通用的解决方案是：</p>
<ul>
<li><p>强一致性，分布式事务，但落地太难且成本太高。</p>
</li>
<li><p>最终一致性，主要是用“记录”和“补偿”的方式。在做所有的不确定的事情之前，先把事情记录下来，然后去做不确定的事情，结果可能是：成功、失败或是不确定，“不确定”（例如超时等）可以等价为失败。成功就可以把记录的东西清理掉了，对于失败和不确定，可以依靠定时任务等方式把所有失败的事情重新搞一遍，直到成功为止。</p>
<p> 回到刚才的例子，系统在A扣钱成功的情况下，把要给B“通知”这件事记录在库里（为了保证最高的可靠性可以把通知B系统加钱和扣钱成功这两件事维护在一个本地事务里），通知成功则删除这条记录，通知失败或不确定则依靠定时任务补偿性地通知我们，直到我们把状态更新成正确的为止。 整个这个模型依然可以基于RPC来做，但可以抽象成一个统一的模型，基于消息队列来做一个“企业总线”。 具体来说，本地事务维护业务变化和通知消息，一起落地（失败则一起回滚），然后RPC到达broker，在broker成功落地后，RPC返回成功，本地消息可以删除。否则本地消息一直靠定时任务轮询不断重发，这样就保证了消息可靠落地broker。 broker往consumer发送消息的过程类似，一直发送消息，直到consumer发送消费成功确认。 我们先不理会重复消息的问题，通过两次消息落地加补偿，下游是一定可以收到消息的。然后依赖状态机版本号等方式做判重，更新自己的业务，就实现了最终一致性。</p>
</li>
</ul>
<blockquote>
<p>系统可用性降低</p>
</blockquote>
<p>系统引入的外部依赖越多，系统稳定性越差。一旦 MQ 宕机，就会对业务造成影响。如何保证MQ的高可用？</p>
<img data-src="/2021/03/13/%E5%88%9D%E8%AF%86RabbitMQ/09.png" class>



<blockquote>
<p>系统复杂度提高</p>
</blockquote>
<p>MQ 的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过 MQ 进行异步调用。如何保证消息没有被重复消费？怎么处理消息丢失情况？那么保证消息传递的顺序性？</p>
<h2 id="MQ的应用场景"><a href="#MQ的应用场景" class="headerlink" title="MQ的应用场景"></a>MQ的应用场景</h2><p>①生产者不需要从消费者处获得反馈。引入消息队列之前的直接调用，其接口的返回值应该为空，这才让明明下层的动作还没做，上层却当成动作做完了继续往后走，即所谓异步成为了可能。</p>
<p>②容许短暂的不一致性。</p>
<p>③确实是用了有效果。即解耦、提速、削峰这些方面的收益，超过加入MQ，管理MQ这些成本。</p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针问题</title>
    <url>/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="环形列表I"><a href="#环形列表I" class="headerlink" title="环形列表I"></a>环形列表I</h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个链表，判断链表中是否有环。</p>
<p>如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。</p>
<p>如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p> 进阶：</p>
<p>你能用 O(1)（即，常量）内存解决此问题吗？</p>
<p> 示例 1：</p>
<p> <img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114100453506.png" alt="image-20210114100453506"></p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：true<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114100714252.png" alt="image-20210114100714252"></p>
<p>输入：head = [1,2], pos = 0<br>输出：true<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114100749569.png" alt="image-20210114100749569" style="zoom:150%;">

<p>输入：head = [1], pos = -1<br>输出：false<br>解释：链表中没有环。</p>
<p>提示：</p>
<p>链表中节点的数目范围是 [0, 104]<br>-105 &lt;= Node.val &lt;= 105<br>pos 为 -1 或者链表中的一个 有效索引 </p>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>####方法一：哈希表<br>思路及算法</p>
<p>最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。</p>
<p>具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pulic <span class="class"><span class="keyword">class</span> <span class="title">solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolen <span class="title">hascirle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        Set&lt;ListNOde&gt; seen = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span>( head !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!seen.add(head))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#####复杂度分析</p>
<p>时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。</p>
<p>空间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。</p>
<h4 id="方式二；双指针–快慢指针"><a href="#方式二；双指针–快慢指针" class="headerlink" title="方式二；双指针–快慢指针"></a>方式二；双指针–快慢指针</h4><p>方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。</p>
<p>假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。</p>
<p>我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<p> 为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？</p>
<p>观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。</p>
<p>当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">puclic <span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolen <span class="title">hascycle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow!=fast)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>||fast.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(N)O(N)，其中 NN 是链表中的节点数。</p>
<p>当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。</p>
<p>当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 NN 轮。</p>
<p>空间复杂度：O(1)O(1)。我们只使用了两个指针的额外空间</p>
<h2 id="环形列表II"><a href="#环形列表II" class="headerlink" title="环形列表II"></a>环形列表II</h2><h3 id="题目说明-1"><a href="#题目说明-1" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p>
<p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p>
<p>说明：不允许修改给定的链表。</p>
<p>进阶：</p>
<p>你是否可以使用 O(1) 空间解决此题？</p>
<p> 示例 1：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114102706369.png" alt="image-20210114102706369"></p>
<p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br>示例 2：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114102721841.png" alt="image-20210114102721841"></p>
<p>输入：head = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br>示例 3：</p>
<p><img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114102737481.png" alt="image-20210114102737481"></p>
<p>输入：head = [1], pos = -1<br>输出：返回 null<br>解释：链表中没有环。</p>
<p>提示：</p>
<p>链表中节点的数目范围在范围 [0, 104] 内<br>-105 &lt;= Node.val &lt;= 105<br>pos 的值为 -1 或者链表中的一个有效索引</p>
<h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><p>一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pos = head;</span><br><span class="line">        Set&lt;ListNode&gt; visited = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">        <span class="keyword">while</span> (pos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited.contains(pos)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                visited.add(pos);</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。</p>
<p>空间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。</p>
<h4 id="方法二：双指针–快慢指针"><a href="#方法二：双指针–快慢指针" class="headerlink" title="方法二：双指针–快慢指针"></a>方法二：双指针–快慢指针</h4><p>我们使用两个指针，\textit{fast}fast 与 \textit{slow}slow。它们起始都位于链表的头部。随后，\textit{slow}slow 指针每次向后移动一个位置，而 \textit{fast}fast 指针向后移动两个位置。如果链表中存在环，则 \textit{fast}fast 指针最终将再次与 \textit{slow}slow 指针在环中相遇。</p>
<p>如下图所示，设链表中环外部分的长度为 aa。\textit{slow}slow 指针进入环后，又走了 bb 的距离与 \textit{fast}fast 相遇。此时，\textit{fast}fast 指针已经走完了环的 nn 圈，因此它走过的总距离为 a+n(b+c)+b=a+(n+1)b+nca+n(b+c)+b=a+(n+1)b+nc</p>
 <img data-src="/2021/01/14/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210114103031586.png" alt="image-20210114103031586" style="zoom:50%;">

<p>根据题意，任意时刻，\textit{fast}fast 指针走过的距离都为 \textit{slow}slow 指针的 22 倍。因此，我们有</p>
<p>a+(n+1)b+nc=2(a+b) \implies a=c+(n-1)(b+c)<br>a+(n+1)b+nc=2(a+b)⟹a=c+(n−1)(b+c)</p>
<p>有了 a=c+(n-1)(b+c)a=c+(n−1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1n−1 圈的环长，恰好等于从链表头部到入环点的距离。</p>
<p>因此，当发现 \textit{slow}slow 与 \textit{fast}fast 相遇时，我们再额外使用一个指针 \textit{ptr}ptr。起始，它指向链表头部；随后，它和 \textit{slow}slow 每次向后移动一个位置。最终，它们会在入环点相遇。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">if</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode ptr = head;</span><br><span class="line">                <span class="keyword">while</span> (ptr != slow) &#123;</span><br><span class="line">                    ptr = ptr.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#####复杂度分析</p>
<p>时间复杂度：O(N)O(N)，其中 NN 为链表中节点的数目。在最初判断快慢指针是否相遇时，\textit{slow}slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)O(N)+O(N)=O(N)。</p>
<p>空间复杂度：O(1)O(1)。我们只使用了 \textit{slow}, \textit{fast}, \textit{ptr}slow,fast,ptr 三个指针。</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>初识递归</title>
    <url>/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="二叉搜索树的范围和"><a href="#二叉搜索树的范围和" class="headerlink" title="二叉搜索树的范围和"></a>二叉搜索树的范围和</h2><h3 id="DFS深度优先搜索"><a href="#DFS深度优先搜索" class="headerlink" title="DFS深度优先搜索"></a>DFS深度优先搜索</h3><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">       ans = <span class="number">0</span> ;</span><br><span class="line">        dfs(root,low,high);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(L&lt;=node.val&amp;&amp;node.val&lt;=R)&#123;</span><br><span class="line">                ans+=node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.val&gt;L)&#123;</span><br><span class="line">                dfs(node.left,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node.val&lt;R)&#123;</span><br><span class="line">                dfs(node.right,L,R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-迭代"><a href="#2-迭代" class="headerlink" title="2.迭代"></a>2.迭代</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rangeSumBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(node.val&gt;=low&amp;&amp;node.val&lt;=high)&#123;</span><br><span class="line">                    ans+=node.val;             <span class="comment">//注意：在这里不要写成ans+=node;</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.val&gt;low)&#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.val&lt;high)&#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeftHight = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> maxRightHighgt = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(maxLeftHight,maxRightHighgt)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/01.png" class>



<h2 id="面试题：汉诺塔"><a href="#面试题：汉诺塔" class="headerlink" title="面试题：汉诺塔"></a>面试题：汉诺塔</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在经典汉诺塔问题中，有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:</span><br><span class="line">(1) 每次只能移动一个盘子;</span><br><span class="line">(2) 盘子只能从柱子顶端滑出移到下一根柱子;</span><br><span class="line">(3) 盘子只能叠在比它大的盘子上。</span><br><span class="line"></span><br><span class="line">请编写程序，用栈将所有盘子从第一根柱子移到最后一根柱子。</span><br><span class="line"></span><br><span class="line">你需要原地修改栈。</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/02.gif" class>





<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/03.gif" class>







<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hanota</span><span class="params">(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        将A柱子上面的盘子，通过辅助柱子B移动到C柱子的上面，需要用到递归和分治的算法</span></span><br><span class="line"><span class="comment">        先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；</span></span><br><span class="line"><span class="comment">		再将最大的盘子从 A 移到 C；</span></span><br><span class="line"><span class="comment">		再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> n = A.size();  <span class="comment">//先用n来表示柱子A上盘子的规模</span></span><br><span class="line">        moveable(n,A,B,C);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveable</span><span class="params">(<span class="keyword">int</span> num,List&lt;Integer&gt;A,List&lt;Integer&gt; B,List&lt;Integer&gt; C)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">1</span>)&#123;</span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>));    <span class="comment">//只有一个盘子，直接移动即可</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            moveable(num-<span class="number">1</span>,A,C,B);         <span class="comment">//以C柱为辅助，将A柱上的n-1个圆盘移动至B柱</span></span><br><span class="line">            C.add(A.remove(A.size()-<span class="number">1</span>));   <span class="comment">//将A柱的最大圆盘放在C柱底端</span></span><br><span class="line">            moveable(num-<span class="number">1</span>,B,A,C);         <span class="comment">//以A柱为辅助柱，将B柱的n-1个圆盘移动至C柱</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/04.png" class>





<h2 id="递归顺序查找树"><a href="#递归顺序查找树" class="headerlink" title="递归顺序查找树"></a>递归顺序查找树</h2><p>给你一个树，请你 按中序遍历 重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</p>
<p>示例 ：</p>
<p>输入：[5,3,6,2,4,null,8,1,null,null,null,7,9] </p>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/05.png" class>

<h3 id="方法一：中序遍历-构造新的树"><a href="#方法一：中序遍历-构造新的树" class="headerlink" title="方法一：中序遍历+构造新的树"></a>方法一：中序遍历+构造新的树</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; vals = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//获取到了升序的数组vals</span></span><br><span class="line">        inorder(root,vals);</span><br><span class="line">        <span class="comment">//下面的过程是重构树的过程，要求没有左节点，只有右节点</span></span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        TreeNode cur = ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v : vals)&#123;</span><br><span class="line">            cur.right = <span class="keyword">new</span> TreeNode(v);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.right;   <span class="comment">//返回的即为第一个节点，这里也体现出了设立ans的作用，类似于链表中的哨兵，在构建完成之后方便返回</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历-----递归部分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node, List&lt;Integer&gt; vals)</span></span>&#123;</span><br><span class="line">        <span class="comment">//不要忘了node为空的终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        inorder(node.left,vals);        <span class="comment">//从当前结点出发，先遍历左子树</span></span><br><span class="line">        vals.add(node.val);                 <span class="comment">//node的左子树遍历完成，将node加入数组</span></span><br><span class="line">        inorder(node.right,vals);       <span class="comment">//遍历当前节点的右子树，将其值加入数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/06.png" class>

<h3 id="方法二：中序递归遍历-更改树的连接关系"><a href="#方法二：中序递归遍历-更改树的连接关系" class="headerlink" title="方法二：中序递归遍历+更改树的连接关系"></a>方法二：中序递归遍历+更改树的连接关系</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode cur;    <span class="comment">//作为成员变量，可以被各个方法引用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">increasingBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode ans = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        cur = ans;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">return</span> ans.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        inorder(node.left);</span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        cur.right = node;</span><br><span class="line">        cur = node;</span><br><span class="line">        inorder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="面试题：biNode"><a href="#面试题：biNode" class="headerlink" title="面试题：biNode"></a>面试题：biNode</h2><p>二叉树数据结构TreeNode可用来表示单向链表（其中left置空，right为下一个链表节点）。实现一个方法，把二叉搜索树转换为单向链表，要求依然符合二叉搜索树的性质，转换操作应是原址的，也就是在原始的二叉搜索树上直接修改。</p>
<p>返回转换后的单向链表的头节点。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    TreeNode head = <span class="keyword">new</span> TreeNode(-<span class="number">1</span>);</span><br><span class="line">    TreeNode prev = head;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">convertBiNode</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        makelist(root);</span><br><span class="line">        <span class="keyword">return</span> head.right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makelist</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="comment">//采用中序遍历，最后会得到一个升序的单链表</span></span><br><span class="line">        <span class="comment">//最后返回的仍然是树，但是左子树为空，并且题目要求在原址修改，所以直接返回树即可</span></span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        makelist(node.left);</span><br><span class="line">        prev.right = node;</span><br><span class="line">        prev = node;  </span><br><span class="line">        node.left = <span class="keyword">null</span>;</span><br><span class="line">        makelist(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​      </p>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/07.png" class>



<p>这个图可以解释上面递归顺序查找树和biNode两道题中类似下面这样的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> cur.right = node;</span><br><span class="line"> cur = node;</span><br><span class="line"></span><br><span class="line">prev.right = node;</span><br><span class="line"> prev = node; </span><br></pre></td></tr></table></figure>
<p>第一条指令用于更新结点指向，后一天指令用于prev的指向，即指向下一个元素，方便下一次访问</p>
<h2 id="面试题16-11-跳水板"><a href="#面试题16-11-跳水板" class="headerlink" title="面试题16.11 跳水板"></a>面试题16.11 跳水板</h2><p>你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。</p>
<p>返回的长度需要从小到大排列。</p>
 <img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/08.png" class>



<h2 id="二叉树的坡度"><a href="#二叉树的坡度" class="headerlink" title="二叉树的坡度"></a>二叉树的坡度</h2><p>给定一个二叉树，计算 整个树 的坡度 。</p>
<p>一个树的 节点的坡度 定义即为，该节点左子树的节点之和和右子树节点之和的 差的绝对值 。如果没有左子树的话，左子树的节点之和为 0 ；没有右子树的话也是一样。空结点的坡度是 0 。</p>
<p>整个树的坡度就是其<strong>所有节点的坡度之和。</strong></p>
 <img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/09.png" class>

<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/10.png" class>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量可以不赋初值，局部变量必须要赋初值，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findTilt</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        calculate(root);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后期需要用到，所以每次递归的结果用left和right接收一下</span></span><br><span class="line">        <span class="keyword">int</span> left = calculate(node.left);</span><br><span class="line">        <span class="keyword">int</span> right = calculate(node.right);</span><br><span class="line">        count+=Math.abs(left-right);</span><br><span class="line">        <span class="keyword">return</span> left+right+node.val;    <span class="comment">//返回当前结点之和，便于下次递归使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img data-src="/2021/02/03/%E5%88%9D%E8%AF%86%E9%80%92%E5%BD%92/11.png" class>



























]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>在Linux环境安装redis</title>
    <url>/2021/03/18/%E5%9C%A8Linux%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85redis/</url>
    <content><![CDATA[<h2 id="开发环境搭建"><a href="#开发环境搭建" class="headerlink" title="开发环境搭建"></a>开发环境搭建</h2><h3 id="云服务器部署redis"><a href="#云服务器部署redis" class="headerlink" title="云服务器部署redis"></a>云服务器部署redis</h3><h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><blockquote>
<p>下载</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-stable.tar.gz </span><br></pre></td></tr></table></figure>
<p>这样就直接下载好了稳定版本。</p>
<blockquote>
<p>解压</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar zxvf redis-stable.tar.gz</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入到redis的src目录下</span></span><br><span class="line">cd redis/src</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<blockquote>
<p>报错处理方法</p>
</blockquote>
<ul>
<li><p>出现了 <strong>zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory</strong></p>
<ul>
<li><blockquote>
<pre><code class="shell">make MALLOC=libc
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 出现了serve.c方面的报错</span><br><span class="line"></span><br><span class="line"> &#123;%asset_image 01.png%&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gcc的版本太低，因为redis本身使用C语言写的，在编译时需要用到GCC编译器，版本过低的话，就会报这个错。</span><br><span class="line"></span><br><span class="line">&gt;[root@localhost redis-6.0.1]# gcc -v                             # 查看gcc版本</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# yum -y install centos-release-scl  # 升级到9.1版本</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# scl enable devtoolset-9 bash</span><br><span class="line">&gt;以上为临时启用，如果要长期使用gcc 9.1的话：</span><br><span class="line">&gt;[root@localhost redis-6.0.1]# echo &quot;source &#x2F;opt&#x2F;rh&#x2F;devtoolset-9&#x2F;enable&quot; &gt;&gt;&#x2F;etc&#x2F;profile</span><br><span class="line"></span><br><span class="line">再执行编译，PREFIX 安装目录</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;shell</span><br><span class="line">[root@localhost redis-6.0.1]# make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis</span><br></pre></td></tr></table></figure></code></pre>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>安装成功</p>
</blockquote>




<blockquote>
<p>启动redis服务</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis/src</span><br><span class="line"><span class="meta">#</span><span class="bash">运行以下命令</span></span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure>
<p>启动成功界面</p>
 



<p><strong>接下来就可以愉快的使用redis了。</strong></p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><blockquote>
<p>redis的启动方式</p>
</blockquote>
<ul>
<li><p>直接启动</p>
<p>进入到redis根目录，执行以下命令，其中，加上‘&amp;’号可以使redis以后台程序运行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. /redis-server  &amp;</span><br></pre></td></tr></table></figure></li>
<li><p>通过指定配置文件来启动</p>
<p> 可以为redis服务启动指定配置文件，例如配置为/etc/redis/6379.conf。当然，配置文件不是绝对的，可以通过个人来指定。</p>
<p>最好不要在原来的redis-conf上进行修改，最好复制一个新的配置文件。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">. /redis-server  /etc/redis/6379 .conf</span><br></pre></td></tr></table></figure>
<p>​        如果更改了端口，使用<code>redis-cli</code>客户端连接时，也需要指定端口，例如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 6380</span><br></pre></td></tr></table></figure>
<ul>
<li><p>使用redis启动脚本来设置开机自启动</p>
<p> 启动脚本 redis_init_script 位于位于Redis的 /utils/ 目录下，redis_init_script脚本代码如下：</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta"> #</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment"># Simple Redis init.d script conceived to work on Linux systems</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> as it does use of the /proc filesystem.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## BEGIN INIT INFO</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Provides:     redis_6379</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Start:        2 3 4 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Default-Stop:         0 1 6</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Short-Description:    Redis data structure server</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Description:          Redis data structure server. See https://redis.io</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## END INIT INFO</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">redis服务器监听端口</span></span><br><span class="line">REDISPORT=6379 </span><br><span class="line"><span class="meta">#</span><span class="bash">服务端所处位置</span></span><br><span class="line">EXEC=/usr/local/bin/redis-server</span><br><span class="line"><span class="meta">#</span><span class="bash">客户端位置</span></span><br><span class="line">CLIEXEC=/usr/local/bin/redis-cli</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">redis的PID文件位置，需要修改</span></span><br><span class="line">PIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pid</span><br><span class="line"><span class="meta">#</span><span class="bash">redis的配置文件位置，需将<span class="variable">$&#123;REDISPORT&#125;</span>修改为文件名</span></span><br><span class="line">CONF=&quot;/etc/redis/$&#123;REDISPORT&#125;.conf&quot;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">    start)</span><br><span class="line">        if [ -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE exists, process is already running or crashed&quot;</span><br><span class="line">        else</span><br><span class="line">                echo &quot;Starting Redis server...&quot;</span><br><span class="line">                $EXEC $CONF</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    stop)</span><br><span class="line">        if [ ! -f $PIDFILE ]</span><br><span class="line">        then</span><br><span class="line">                echo &quot;$PIDFILE does not exist, process is not running&quot;</span><br><span class="line">        else</span><br><span class="line">                PID=$(cat $PIDFILE)</span><br><span class="line">                echo &quot;Stopping ...&quot;</span><br><span class="line">                $CLIEXEC -p $REDISPORT shutdown</span><br><span class="line">                while [ -x /proc/$&#123;PID&#125; ]</span><br><span class="line">                do</span><br><span class="line">                    echo &quot;Waiting for Redis to shutdown ...&quot;</span><br><span class="line">                    sleep 1</span><br><span class="line">                done</span><br><span class="line">                echo &quot;Redis stopped&quot;</span><br><span class="line">        fi</span><br><span class="line">        ;;</span><br><span class="line">    *)</span><br><span class="line">        echo &quot;Please use start or stop as first argument&quot;</span><br><span class="line">Type  :quit&lt;Enter&gt;  to exit Vim   </span><br></pre></td></tr></table></figure>
<p>此处直接配置开启自启动 <code>chkconfig redisd on</code> 将报错误： <code>service redisd does not support chkconfig</code> </p>
<p>在启动脚本开头添加如下两行注释以修改其运行级别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line"># chkconfig:   2345 90 10</span><br><span class="line"># description:  Redis is a persistent key-value database</span><br><span class="line">#</span><br></pre></td></tr></table></figure>


<p>设置即可成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置为开机自启动服务器</span><br><span class="line">chkconfig redisd on</span><br><span class="line">#打开服务</span><br><span class="line">service redisd start</span><br><span class="line">#关闭服务</span><br><span class="line">service redisd stop</span><br></pre></td></tr></table></figure>


<h4 id="远程连接工具"><a href="#远程连接工具" class="headerlink" title="远程连接工具"></a>远程连接工具</h4>]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>环境部署</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾收集器与内存分配策略</title>
    <url>/2021/02/05/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>哈希表easy篇总结</title>
    <url>/2021/03/11/%E5%93%88%E5%B8%8C%E8%A1%A8easy%E7%AF%87%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>##哈希表刷题总结</p>
<h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>哈希表（Hash Table，也叫散列表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做哈希函数，存放记录的数组称做哈希表。</p>
<p>一个通俗的例子是，为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 xx 到首字母 F(x)F(x) 的一个函数关系），在首字母为 WW 的表中查找 “王” 姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母” 是这个例子中哈希函数的函数法则 F()F()，存放首字母的表对应哈希表。关键字和函数法则理论上可以任意确定。</p>
<p>哈希表是使用 O(1)O(1) 时间进行数据的插入删除和查找，但是哈希表不保证表中数据的有序性，<del>这样在哈希表中查找最大数据或者最小数据的时间是 O(N)O(N) 实现。</del>哈希表不支持需要元素间任何排序信息的操作，例如findMin、findMax或者打印输出排序号的整张表。</p>
<h3 id="设计哈希映射"><a href="#设计哈希映射" class="headerlink" title="设计哈希映射"></a>设计哈希映射</h3><p>哈希表是一个在不同语言中都有的通用数据结构。例如，Python 中的 dict 和 Java 中的 Hashmap。哈希表的特性是可以根据给出的 key 快速访问 value。</p>
<p>设计哈希表有两个问题需要去解决： 1). 如何设计哈希方法？ 和 2).如何避免哈希碰撞？ 。</p>
<p>1). 如何设计哈希方法？：哈希方法会将键值映射到某块存储空间，一个好的哈希方法应该将不同的键值 均匀 地分布在存储空间中。</p>
<p>2). 如何避免哈希碰撞？：哈希方法要将大量的键值映射到一个有限的空间里,这样就有可能会将不同的键值映射到同一个存储空间，这种情况称为 ‘哈希碰撞’ 。哈希碰撞是不可避免的，但可以用策略来解决哈希碰撞。</p>
<h3 id="1-有多少小于当前数字的数字"><a href="#1-有多少小于当前数字的数字" class="headerlink" title="1.有多少小于当前数字的数字"></a>1.有多少小于当前数字的数字</h3><p>####一、暴力求解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] smallerNumbersThanCurrent(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">//第一种方法1：暴力求解法，逐一遍历除当前元素之外的所有元素</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        复杂度分析：</span></span><br><span class="line"><span class="comment">        空间复杂度为O(n)，需要存储新的答案数组</span></span><br><span class="line"><span class="comment">        时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">int</span> newtime[] = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;length;h++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&gt;nums[h])&#123;</span><br><span class="line">                    time++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newtime[i] = time;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newtime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二、计数排序"><a href="#二、计数排序" class="headerlink" title="二、计数排序"></a>二、计数排序</h4><h4 id="三、快速排序"><a href="#三、快速排序" class="headerlink" title="三、快速排序"></a>三、快速排序</h4><h4 id="四、排序与映射结合"><a href="#四、排序与映射结合" class="headerlink" title="四、排序与映射结合"></a>四、排序与映射结合</h4><h3 id="2-第一个只出现一次的字符"><a href="#2-第一个只出现一次的字符" class="headerlink" title="2.第一个只出现一次的字符"></a>2.第一个只出现一次的字符</h3><h4 id="3-1哈希表的遍历"><a href="#3-1哈希表的遍历" class="headerlink" title="3.1哈希表的遍历"></a>3.1哈希表的遍历</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Character,Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] string = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:string)&#123;</span><br><span class="line">            dic.put(c,!dic.containsKey(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:string)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.get(c))</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">复杂度分析：</span></span><br><span class="line"><span class="comment">时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">空间复杂度：O(1)</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>


<h4 id="3-2有序hash表的遍历"><a href="#3-2有序hash表的遍历" class="headerlink" title="3.2有序hash表的遍历"></a>3.2有序hash表的遍历</h4><p>哈希表是 去重 的，即哈希表中键值对数量 ≤ 字符串 s 的长度。因此，相比于方法一，方法二减少了第二轮遍历的循环次数。当字符串很长（重复字符很多）时，方法二则效率更高。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Boolean&gt; dic = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] string = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c:string)&#123;</span><br><span class="line">            dic.put(c,!dic.containsKey(c));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Character,Boolean&gt; d : dic.entrySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(d.getValue())</span><br><span class="line">                <span class="keyword">return</span> d.getKey();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-3补充知识：Java中的Character类"><a href="#3-3补充知识：Java中的Character类" class="headerlink" title="3.3补充知识：Java中的Character类"></a>3.3补充知识：Java中的Character类</h4><p>Character 类用于对单个字符进行操作。</p>
<p>Character 类在对象中包装一个基本类型 <strong>char</strong> 的值(类似于Integer与int的关系)</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Unicode 字符表示形式</span></span><br><span class="line"><span class="keyword">char</span> uniChar = <span class="string">&#x27;\u039A&#x27;</span>; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] charArray =&#123; <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>然而，在实际开发过程中，我们经常会遇到需要使用对象，而不是内置数据类型的情况。为了解决这个问题，Java语言为内置数据类型char提供了<strong>包装类Character类</strong>。</p>
<p>Character类提供了一系列方法来操纵字符。你可以使用Character的构造方法创建一个Character类对象，例如：</p>
<p>在某些情况下，Java编译器会自动创建一个Character对象。</p>
<p>例如，将一个char类型的参数传递给需要一个Character类型参数的方法时，那么编译器会自动地将char类型参数转换为Character对象。 这种特征称为装箱，反过来称为拆箱。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始字符 &#x27;a&#x27; 装箱到 Character 对象 ch 中</span></span><br><span class="line">Character ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 原始字符 &#x27;x&#x27; 用 test 方法装箱</span></span><br><span class="line"><span class="comment">// 返回拆箱的值到 &#x27;c&#x27;</span></span><br><span class="line"><span class="keyword">char</span> c = test(<span class="string">&#x27;x&#x27;</span>);</span><br></pre></td></tr></table></figure>


<p><img data-src="/2021/03/11/%E5%93%88%E5%B8%8C%E8%A1%A8easy%E7%AF%87%E6%80%BB%E7%BB%93/Users\xinghaodong\AppData\Roaming\Typora\typora-user-images\image-20210202160601128.png" alt="image-20210202160601128"></p>
<p>###3.只出现一次的字符</p>
<p>####3.1哈希表两次遍历</p>
<p>使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用Hash表的第一次遍历</span></span><br><span class="line">        HashMap&lt;Integer,Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            dic.put(i,!dic.containsKey(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.get(i))</span><br><span class="line">                <span class="keyword">return</span> i;   <span class="comment">//不能返回nums[i],这里的增强for循环中的i代表的是nums[]中的某一个元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;   <span class="comment">//当表示如不存在所求值时，，不能返回null,要返回-1.    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2位运算"><a href="#3-2位运算" class="headerlink" title="3.2位运算"></a>3.2位运算</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            single ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> single;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="3-3集合运算"><a href="#3-3集合运算" class="headerlink" title="3.3集合运算"></a>3.3集合运算</h4><p>使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</p>
<h4 id="3-4集合放入与删除"><a href="#3-4集合放入与删除" class="headerlink" title="3.4集合放入与删除"></a>3.4集合放入与删除</h4><p>使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。</p>
<h3 id="4-岛屿的周长"><a href="#4-岛屿的周长" class="headerlink" title="4.岛屿的周长"></a>4.岛屿的周长</h3><p>####方法一：迭代</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> land=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> border=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = grid.length;</span><br><span class="line">        <span class="keyword">int</span> k = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> h=<span class="number">0</span>;h&lt;k;h++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][h]==<span class="number">1</span>)&#123;</span><br><span class="line">                    land++;</span><br><span class="line">                    <span class="keyword">if</span>(i&lt;grid.length-<span class="number">1</span>&amp;&amp;grid[i+<span class="number">1</span>][h]==<span class="number">1</span>)&#123;</span><br><span class="line">                    border++;</span><br><span class="line">                    &#125;</span><br><span class="line">                     <span class="keyword">if</span>(h&lt;grid[<span class="number">0</span>].length-<span class="number">1</span>&amp;&amp;grid[i][h+<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">                    border++;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>*land-<span class="number">2</span>*border;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">找规律，凡是两个陆地相接，必然在最后的周长计算里面损失两个边长值</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<h4 id="方法二：DFS深度优先搜索"><a href="#方法二：DFS深度优先搜索" class="headerlink" title="方法二：DFS深度优先搜索"></a>方法二：DFS深度优先搜索</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">从土地到土地，之间不会产生周长，但从土地迈入海洋，之间会产生 1 个周长，从土地迈出矩阵边界，也会产生 1 个周长。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dfsfunction</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][]grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;=grid.length||j&lt;<span class="number">0</span>||j&gt;=grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//当前正好要越界，周长值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//说明从陆地来到了海上，周长值+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(grid[i][j]==<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">//DFS需要记录状态，避免重复访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j]=<span class="number">2</span>; <span class="comment">//到此，该节点已经访问完毕，状态变更</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从当前模块开始，向上下左右进行遍历，其实有递归的思想，最后的结果随着递归的出栈，子问题的解自上而下的返回，最终得出大问题的解</span></span><br><span class="line">        <span class="keyword">return</span> dfsfunction(i-<span class="number">1</span>,j,grid)+dfsfunction(i,j-<span class="number">1</span>,grid)+dfsfunction(i+<span class="number">1</span>,j,grid)+dfsfunction(i,j+<span class="number">1</span>,grid);       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = grid.length;</span><br><span class="line">        <span class="keyword">int</span> col = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                       <span class="keyword">return</span> dfsfunction(i,j,grid); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="官方题解1-迭代—-利用算子"><a href="#官方题解1-迭代—-利用算子" class="headerlink" title="官方题解1:迭代—-利用算子"></a>官方题解1:迭代—-利用算子</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dx = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] dy = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.length, m = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                        <span class="keyword">int</span> tx = i + dx[k];</span><br><span class="line">                        <span class="keyword">int</span> ty = j + dy[k];</span><br><span class="line">                        <span class="keyword">if</span> (tx &lt; <span class="number">0</span> || tx &gt;= n || ty &lt; <span class="number">0</span> || ty &gt;= m || grid[tx][ty] == <span class="number">0</span>) &#123;</span><br><span class="line">                            cnt += <span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans += cnt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>####官方题解2:DFS—-利用算子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    constexpr <span class="keyword">static</span> <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    constexpr <span class="keyword">static</span> <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= n || y &lt; <span class="number">0</span> || y &gt;= m || grid[x][y] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tx = x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> ty = y + dy[i];</span><br><span class="line">            res += dfs(tx, ty, grid, n, m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans += dfs(i, j, grid, n, m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>这个题放在散列表题目下，个人觉得是因为可以使用散列表去记录方格的访问状态</p>
<p>key用来放方格点，value用true或者false来代表方格是否被访问过。</p>
<h3 id="5-岛屿的数量"><a href="#5-岛屿的数量" class="headerlink" title="5.岛屿的数量"></a>5.岛屿的数量</h3><p>###6.岛屿的最大面积</p>
<h3 id="7-查找常用字符"><a href="#7-查找常用字符" class="headerlink" title="7.查找常用字符"></a>7.查找常用字符</h3><p>总体来说，还是hash表的思路，重点在于用一个数组创建索引，用另外一个数组更新值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历、计数、更新</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">用数组实现一个哈希表，以字符为数组下标索引：字符-&#x27;a&#x27;=索引---即：0-&#x27;a&#x27;,2-&#x27;b&#x27;,3-&#x27;c&#x27;,25-&#x27;z&#x27;.</span></span><br><span class="line"><span class="comment">用freq数组存储当前遍历字符串中各字符的数量,在遍历完成后，</span></span><br><span class="line"><span class="comment">以各字符数量的最小值更新minfreq数组，遍历完成后即可得到公共字符的数量集合hash，</span></span><br><span class="line"><span class="comment">将minfreq数组中的非0值还原成字符串加入到列表中，即可得到答案。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">commonChars</span><span class="params">(String[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] minfreq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];   <span class="comment">//建立minfreq[c]来存储各字符串中c出现的最小次数</span></span><br><span class="line">        Arrays.fill(minfreq,Integer.MAX_VALUE);<span class="comment">//将指定的int值分配给指定的int数组的每个元素，即此时minfreq中的每个元素值均为Integer.MAX_VALUE。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String word:A)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] freq = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">int</span> length = word.length();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">                <span class="keyword">char</span> ch =word.charAt(i);</span><br><span class="line">                ++freq[ch-<span class="string">&#x27;a&#x27;</span>];             <span class="comment">//ch-&#x27;a&#x27;创建索引</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">                minfreq[i] = Math.min(minfreq[i],freq[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;minfreq[i];j++)&#123;</span><br><span class="line">                ans.add(String.valueOf((<span class="keyword">char</span>)(i+<span class="string">&#x27;a&#x27;</span>)));  <span class="comment">//i+&#x27;a&#x27;是在将还原minfreq中的字符还原成字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="8-唯一元素的和"><a href="#8-唯一元素的和" class="headerlink" title="8.唯一元素的和"></a>8.唯一元素的和</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfUnique</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Boolean&gt; dic = <span class="keyword">new</span> HashMap&lt;Integer,Boolean&gt;();</span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            dic.put(i,!dic.containsKey(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.get(i))&#123;</span><br><span class="line">                sum+=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串调用length，调用的是方法，因而要加()；数组调用length，调用的是属性，不需要加()。</span></span><br></pre></td></tr></table></figure>














]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统初瞰</title>
    <url>/2021/10/29/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%88%9D%E7%9E%B0/</url>
    <content><![CDATA[<h2 id="一、走进推荐系统的世界"><a href="#一、走进推荐系统的世界" class="headerlink" title="一、走进推荐系统的世界"></a>一、走进推荐系统的世界</h2><p>“啤酒与尿布” 的故事相信很多人都听过，年轻爸爸去超市购买尿布时，经常会买点啤酒犒劳自己。因此，沃尔玛将这两种商品进行了捆绑销售，最终获得了更好的销量。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/tdJ56hy73JzRx6F1Fdac.jpeg" alt="23张图，带你入门推荐系统"></p>
<p>“啤酒与尿布”的故事</p>
<p>这个故事背后的理论依据就是 “推荐算法”，因为尿布和啤酒经常出现在同一个购物车中，那么向购买尿布的年轻爸爸推荐啤酒确实有一定道理。</p>
<h3 id="1-推荐系统到底解决的是什么问题？"><a href="#1-推荐系统到底解决的是什么问题？" class="headerlink" title="1. 推荐系统到底解决的是什么问题？"></a>1. 推荐系统到底解决的是什么问题？</h3><p>推荐系统从20世纪90年代就被提出来了，但是真正进入大众视野以及在各大互联网公司中流行起来，还是最近几年的事情。</p>
<p>随着移动互联网的发展，越来越多的信息开始在互联网上传播，产生了严重的信息过载。因此，如何从众多信息中找到用户感兴趣的信息，这个便是推荐系统的价值。精准推荐解决了用户痛点，提升了用户体验，最终便能留住用户。</p>
<p>推荐系统本质上就是一个信息过滤系统，通常分为：召回、排序、重排序这3个环节，每个环节逐层过滤，最终从海量的物料库中筛选出几十个用户可能感兴趣的物品推荐给用户。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/l3M22Y9Gl96kIA9wSO0P.png" alt="23张图，带你入门推荐系统"></p>
<p>推荐系统的分阶段过滤流程</p>
<h3 id="2-推荐系统的应用场景"><a href="#2-推荐系统的应用场景" class="headerlink" title="2. 推荐系统的应用场景"></a>2. 推荐系统的应用场景</h3><p>哪里有海量信息，哪里就有推荐系统，我们每天最常用的APP都涉及到推荐功能：</p>
<ul>
<li>资讯类：今日头条、腾讯新闻等</li>
<li>电商类：淘宝、京东、拼多多、亚马逊等</li>
<li>娱乐类：抖音、快手、爱奇艺等</li>
<li>生活服务类：美团、大众点评、携程等</li>
<li>社交类：微信、陌陌、脉脉等</li>
</ul>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/DJTxPLhs3b2CkIQ2KjlQ.png" alt="23张图，带你入门推荐系统"></p>
<p>头条、京东、网易云音乐中的推荐功能</p>
<p>推荐系统的应用场景通常分为以下两类：</p>
<ul>
<li>基于用户维度的推荐：根据用户的历史行为和兴趣进行推荐，比如淘宝首页的猜你喜欢、抖音的首页推荐等。</li>
<li>基于物品维度的推荐：根据用户当前浏览的标的物进行推荐，比如打开京东APP的商品详情页，会推荐和主商品相关的商品给你。</li>
</ul>
<h3 id="3-搜索、推荐、广告三者的异同"><a href="#3-搜索、推荐、广告三者的异同" class="headerlink" title="3. 搜索、推荐、广告三者的异同"></a>3. 搜索、推荐、广告三者的异同</h3><p>搜索和推荐是AI算法最常见的两个应用场景，在技术上有相通的地方。这里提到广告，主要考虑很多没做过广告业务的同学不清楚为什么广告和搜索、推荐会有关系，所以做下解释。</p>
<ul>
<li>搜索：有明确的搜索意图，搜索出来的结果和用户的搜索词相关。</li>
<li>推荐：不具有目的性，依赖用户的历史行为和画像数据进行个性化推荐。</li>
<li>广告：借助搜索和推荐技术实现广告的精准投放，可以将广告理解成搜索推荐的一种应用场景，技术方案更复杂，涉及到智能预算控制、广告竞价等。</li>
</ul>
<h2 id="二、推荐系统的整体架构"><a href="#二、推荐系统的整体架构" class="headerlink" title="二、推荐系统的整体架构"></a>二、推荐系统的整体架构</h2><p><img data-src="http://image.woshipm.com/wp-files/2020/10/PA8qx7X5tW3yPM7jKQ7D.png" alt="23张图，带你入门推荐系统"></p>
<p>推荐系统的整体架构</p>
<p>上面是推荐系统的整体架构图，自下而上分成了多层，各层的主要作用如下：</p>
<ul>
<li>数据源：推荐算法所依赖的各种数据源，包括物品数据、用户数据、行为日志、其他可利用的业务数据、甚至公司外部的数据；</li>
<li>计算平台：负责对底层的各种异构数据进行清洗、加工，离线计算和实时计算；</li>
<li>数据存储层：存储计算平台处理后的数据，根据需要可落地到不同的存储系统中，比如Redis中可以存储用户特征和用户画像数据，ES中可以用来索引物品数据，Faiss中可以存储用户或者物品的embedding向量等；</li>
<li>召回层：包括各种推荐策略或者算法，比如经典的协同过滤，基于内容的召回，基于向量的召回，用于托底的热门推荐等。为了应对线上高并发的流量，召回结果通常会预计算好，建立好倒排索引后存入缓存中；</li>
<li>融合过滤层：触发多路召回，由于召回层的每个召回源都会返回一个候选集，因此这一层需要进行融合和过滤；</li>
<li>排序层：利用机器学习或者深度学习模型，以及更丰富的特征进行重排序，筛选出更小、更精准的推荐集合返回给上层业务。</li>
</ul>
<p>从数据存储层到召回层、再到融合过滤层和排序层，候选集逐层减少，但是精准性要求越来越高，因此也带来了计算复杂度的逐层增加，这个便是推荐系统的最大挑战。</p>
<p>其实对于推荐引擎来说，最核心的部分主要是两块：特征和算法。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/7BwaFaznNDQVbRJn6i6y.png" alt="23张图，带你入门推荐系统"></p>
<p>推荐引擎的核心功能和技术方案</p>
<p>特征计算由于数据量大，通常采用大数据的离线和实时处理技术，像Spark、Flink等。然后将计算结果保存在Redis或者其他存储系统中（比如HBase、MongoDB或者ES），供召回和排序模块使用。</p>
<p>召回算法的作用是：从海量数据中快速获取一批候选数据，要求是快和尽可能的准。这一层通常有丰富的策略和算法，用来确保多样性，为了更好的推荐效果，某些算法也会做成近实时的。</p>
<p>排序算法的作用是：对多路召回的候选集进行精细化排序。它会利用物品、用户以及它们之间的交叉特征，然后通过复杂的机器学习或者深度学习模型进行打分排序，这一层的特点是计算复杂但是结果更精准。</p>
<h2 id="三、图解经典的协同过滤算法"><a href="#三、图解经典的协同过滤算法" class="headerlink" title="三、图解经典的协同过滤算法"></a>三、图解经典的协同过滤算法</h2><p>了解了推荐系统的整体架构和技术方案后，下面带大家深入一下算法细节，这里选择图解的是推荐系统中的明星算法：协同过滤（Collaborative Filtering，CF）。</p>
<p>对于工程同学来说，可能觉得 AI 算法晦涩难懂，门槛太高，确实很多深度学习算法的确是这样，但是协同过滤却是一个简单同时效果很好的算法，只要你有初中数学的基础就能看懂。</p>
<h3 id="1-协同过滤是什么？"><a href="#1-协同过滤是什么？" class="headerlink" title="1. 协同过滤是什么？"></a>1. 协同过滤是什么？</h3><p>协同过滤算法的核心就是「找相似」，它基于用户的历史行为（浏览、收藏、评论等），去发现用户对物品的喜好，并对喜好进行度量和打分，最终筛选出推荐集合，它又包括两个分支：</p>
<p><strong>1）基于用户的协同过滤</strong></p>
<p>User-CF，核心是找相似的人。</p>
<p>比如下图中，用户 A 和用户 C 都购买过物品 a 和物品 b，那么可以认为 A 和 C 是相似的，因为他们共同喜欢的物品多。这样，就可以将用户 A 购买过的物品 d 推荐给用户 C。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/fR4FCKovZM14CyUN5SUp.png" alt="23张图，带你入门推荐系统"></p>
<p>基于用户的协同过滤示例</p>
<p><strong>2）基于物品的协同过滤</strong></p>
<p>Item-CF，核心是找相似的物品。比如下图中，物品 a 和物品 b 同时被用户 A，B，C 购买了，那么物品 a 和 物品 b 被认为是相似的，因为它们的共现次数很高。</p>
<p>这样，如果用户 D 购买了物品 a，则可以将和物品 a 最相似的物品 b 推荐给用户 D。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/lTBoS62bdkl7UABH1j69.png" alt="23张图，带你入门推荐系统"></p>
<p>基于物品的协同过滤示例</p>
<h3 id="2-如何找相似？"><a href="#2-如何找相似？" class="headerlink" title="2. 如何找相似？"></a>2. 如何找相似？</h3><p>前面讲到，协同过滤的核心就是找相似，User-CF是找用户之间的相似，Item-CF是找物品之间的相似，那到底如何衡量两个用户或者物品之间的相似性呢？</p>
<p>我们都知道，对于坐标中的两个点，如果它们之间的夹角越小，这两个点越相似，这就是初中学过的余弦距离，它的计算公式如下：</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/cRZVdbR9aBSUd50iDrx1.png" alt="23张图，带你入门推荐系统"></p>
<p>举个例子，A坐标是（0，3，1），B坐标是（4，3，0），那么这两个点的余弦距离是0.569，余弦距离越接近1，表示它们越相似。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/GgBtexz9xXrWVVd6l0Uv.png" alt="23张图，带你入门推荐系统"></p>
<p>除了余弦距离，衡量相似性的方法还有很多种，比如：欧式距离、皮尔逊相关系数、Jaccard 相似系数等等，这里不做展开，只是计算公式上的差异而已。</p>
<h3 id="3-Item-CF的算法流程"><a href="#3-Item-CF的算法流程" class="headerlink" title="3. Item-CF的算法流程"></a>3. Item-CF的算法流程</h3><p>清楚了相似性的定义后，下面以Item-CF为例，详细说下这个算法到底是如何选出推荐物品的？</p>
<p>第一步：整理物品的共现矩阵</p>
<p>假设有 A、B、C、D、E 5个用户，其中用户 A 喜欢物品 a、b、c，用户 B 喜欢物品 a、b等等。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/GS77wKUXFNn8rP4IqqIF.png" alt="23张图，带你入门推荐系统"></p>
<p>所谓共现，即：两个物品被同一个用户喜欢了。比如物品 a 和 b，由于他们同时被用户 A、B、C 喜欢，所以 a 和 b 的共现次数是3，采用这种统计方法就可以快速构建出共现矩阵。</p>
<p>第二步：计算物品的相似度矩阵</p>
<p>对于 Item-CF 算法来说，一般不采用前面提到的余弦距离来衡量物品的相似度，而是采用下面的公式：</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/ZGWFevvkP2qbNy9mjZUn.png" alt="23张图，带你入门推荐系统"></p>
<p>其中，N(u) 表示喜欢物品 u 的用户数，N(v) 表示喜欢物品 v 的用户数，两者的交集表示同时喜欢物品 u 和物品 v 的用户数。很显然，如果两个物品同时被很多人喜欢，那么这两个物品越相似。</p>
<p>基于第1步计算出来的共现矩阵以及每个物品的喜欢人数，便可以构造出物品的相似度矩阵：</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/SEUFaXvTrlIZ4NwMMUHG.png" alt="23张图，带你入门推荐系统"></p>
<p>第三步：推荐物品</p>
<p>最后一步，便可以基于相似度矩阵推荐物品了，公式如下：</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/sehIXEYg91OlQ4oGwwBf.png" alt="23张图，带你入门推荐系统"></p>
<p>其中，Puj 表示用户 u 对物品 j 的感兴趣程度，值越大，越值得被推荐。N(u) 表示用户 u 感兴趣的物品集合，S(j,N) 表示和物品 j 最相似的前 N 个物品，Wij 表示物品 i 和物品 j 的相似度，Rui表示用户 u 对物品 i 的兴趣度。</p>
<p>上面的公式有点抽象，直接看例子更容易理解，假设我要给用户 E 推荐物品，前面我们已经知道用户 E 喜欢物品 b 和物品 c，喜欢程度假设分别为 0.6 和 0.4。那么，利用上面的公式计算出来的推荐结果如下：</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/cHWgi8xs5QeilawOcyIc.png" alt="23张图，带你入门推荐系统"></p>
<p>因为物品 b 和物品 c 已经被用户 E 喜欢过了，所以不再重复推荐。最终对比用户 E 对物品 a 和物品 d 的感兴趣程度，因为 0.682 &gt; 0.3，因此选择推荐物品 a。</p>
<h2 id="四、从0到1搭建一个推荐系统"><a href="#四、从0到1搭建一个推荐系统" class="headerlink" title="四、从0到1搭建一个推荐系统"></a>四、从0到1搭建一个推荐系统</h2><p>有了上面的理论基础后，我们就可以用 Python 快速实现出一个推荐系统。</p>
<h3 id="1-选择数据集"><a href="#1-选择数据集" class="headerlink" title="1. 选择数据集"></a>1. 选择数据集</h3><p>这里采用的是推荐领域非常经典的 MovieLens 数据集，它是一个关于电影评分的数据集，官网上提供了多个不同大小的版本，下面以 ml-1m 数据集（大约100万条用户评分记录）为例。</p>
<p>下载解压后，文件夹中包含：ratings.dat、movies.dat、users.dat 3个文件，共6040个用户，3900部电影，1000209条评分记录。各个文件的格式都是一样的，每行表示一条记录，字段之间采用 :: 进行分割。</p>
<p>以ratings.dat为例，每一行包括4个属性：UserID, MovieID, Rating, Timestamp。通过脚本可以统计出不同评分的人数分布：</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/8cEVSn9SRtllHfsN7XHl.jpeg" alt="23张图，带你入门推荐系统"></p>
<h3 id="2-读取原始数据"><a href="#2-读取原始数据" class="headerlink" title="2. 读取原始数据"></a>2. 读取原始数据</h3><p>程序主要使用数据集中的 ratings.dat 这个文件，通过解析该文件，抽取出 user_id、movie_id、rating 3个字段，最终构造出算法依赖的数据，并保存在变量 dataset 中，它的格式为：dict[user_id][movie_id] = rate</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/qgkENiWG0sCSUce0DQhX.jpeg" alt="23张图，带你入门推荐系统"></p>
<h3 id="3-构造物品的相似度矩阵"><a href="#3-构造物品的相似度矩阵" class="headerlink" title="3. 构造物品的相似度矩阵"></a>3. 构造物品的相似度矩阵</h3><p>基于第 2 步的 dataset，可以进一步统计出每部电影的评分次数以及电影的共生矩阵，然后再生成相似度矩阵。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/8vL2jjyfSgiCb8PTJi8k.png" alt="23张图，带你入门推荐系统"></p>
<h3 id="4-基于相似度矩阵推荐物品"><a href="#4-基于相似度矩阵推荐物品" class="headerlink" title="4. 基于相似度矩阵推荐物品"></a>4. 基于相似度矩阵推荐物品</h3><p>最后，可以基于相似度矩阵进行推荐了，输入一个用户id，先针对该用户评分过的电影，依次选出 top 10 最相似的电影，然后加权求和后计算出每个候选电影的最终评分，最后再选择得分前 5 的电影进行推荐。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/g85iBVfEtMFaHFbYtpG2.png" alt="23张图，带你入门推荐系统"></p>
<h3 id="5-调用推荐系统"><a href="#5-调用推荐系统" class="headerlink" title="5. 调用推荐系统"></a>5. 调用推荐系统</h3><p>下面选择UserId=1 这个用户，看下程序的执行结果。由于推荐程序输出的是 movieId 列表，为了更直观的了解推荐结果，这里转换成电影的标题进行输出。</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/WJcKchOscTClEcmu3p5f.png" alt="23张图，带你入门推荐系统"></p>
<p>最终推荐的前5个电影为：</p>
<p><img data-src="http://image.woshipm.com/wp-files/2020/10/t4Q0R80zxGFFk2ekQvF1.png" alt="23张图，带你入门推荐系统"></p>
<h2 id="五、线上推荐系统的挑战"><a href="#五、线上推荐系统的挑战" class="headerlink" title="五、线上推荐系统的挑战"></a>五、线上推荐系统的挑战</h2><p>通过上面的介绍，大家对推荐系统的基本构成应该有了一个初步认识，但是真正运用到线上真实环境时，还会遇到很多算法和工程上的挑战，绝对不是几十行 Python 代码可以搞定的。</p>
<blockquote>
<ol>
<li>上面的示例使用了标准化的数据集，而线上环境的数据是非标准化的，因此涉及到海量数据的收集、清洗和加工，最终构造出模型可使用的数据集。</li>
<li>复杂且繁琐的特征工程，都说算法模型的上限由数据和特征决定。对于线上环境，需要从业务角度选择出可用的特征，然后对数据进行清洗、标准化、归一化、离散化，并通过实验效果进一步验证特征的有效性。</li>
<li>算法复杂度如何降低？比如上面介绍的Item-CF算法，时间和空间复杂度都是O(N×N)，而线上环境的数据都是千万甚至上亿级别的，如果不做算法优化，可能几天都跑不出数据，或者内存中根本放不下如此大的矩阵数据。</li>
<li>实时性如何满足？因为用户的兴趣随着他们最新的行为在实时变化的，如果模型只是基于历史数据进行推荐，可能结果不够精准。因此，如何满足实时性要求，以及对于新加入的物品或者用户该如何推荐，都是要解决的问题。</li>
<li>算法效果和性能的权衡。从算法角度追求多样性和准确性，从工程角度追求性能，这两者之间必须找到一个平衡点。</li>
<li>推荐系统的稳定性和效果追踪。需要有一套完善的数据监控和应用监控体系，同时有 ABTest 平台进行灰度实验，进行效果对比。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>推荐系统</category>
      </categories>
      <tags>
        <tag>推荐系统入门</tag>
      </tags>
  </entry>
  <entry>
    <title>封装Mybatis输出结果与模糊查询</title>
    <url>/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="resultType"><a href="#resultType" class="headerlink" title="resultType"></a>resultType</h3><p>resultType: 执行 sql 得到 ResultSet 转换的类型，使用类型的完全限定名或别名。 注意如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身。resultType 和 resultMap，不能同时使用。</p>
<h4 id="resultType-1"><a href="#resultType-1" class="headerlink" title="resultType"></a>resultType</h4><img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/01.png" class>



<blockquote>
<p>简单类型</p>
</blockquote>
<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countStudent</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>mapper文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;countStudent&quot;</span> resultType=<span class="string">&quot;int&quot;</span>&gt;</span><br><span class="line">	 <span class="function">select <span class="title">count</span><span class="params">(*)</span> from student</span></span><br><span class="line"><span class="function">&lt;/select&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRetunInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> count = studentDao.countStudent();</span><br><span class="line">     System.out.println(<span class="string">&quot;学生总人数：&quot;</span>+ count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>对象类型</p>
</blockquote>
<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Student <span class="title">selectById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>mapper文件：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectById&quot;</span> resultType=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span><br><span class="line">     select id,name,email,age from student where id=#&#123;studentId&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/02.png" class>

 <img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/03.png" class>



<blockquote>
<p>Map</p>
</blockquote>
<p>sql 的查询结果作为 Map 的 key 和 value。推荐使用 Map。 注意：Map 作为接口返回值，sql 语句的查询结果最多只能有一条记录。大于一条记录是错误。</p>
<p>接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Map&lt;Object,Object&gt; <span class="title">selectReturnMap</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure>
<p>mapper文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectReturnMap&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;java.util.HashMap&quot;</span>&gt;</span></span><br><span class="line">	 select name,email from student where id = #&#123;studentId&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>测试方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     Map&lt;Object,Object&gt; retMap = studentDao.selectReturnMap(<span class="number">1002</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;查询结果是 Map:&quot;</span>+retMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="resultMap"><a href="#resultMap" class="headerlink" title="resultMap"></a>resultMap</h4><p>resultMap 可以自定义 sql 的结果和 java 对象属性的映射关系。更灵活的把列值赋值给指定属性。 常用在列名和 java 对象属性名不一样的情况。</p>
<p> 使用方式： </p>
<p>1.先定义 resultMap,指定列名和属性的对应关系。</p>
<p> 2.在<select>中把 resultType 替换为 resultMap。</select></p>
<blockquote>
<p>接口方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectUseResultMap</span><span class="params">(QueryParam param)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>mapper文件</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建 resultMap</span></span><br><span class="line"><span class="comment">     id:自定义的唯一名称，在&lt;select&gt;使用</span></span><br><span class="line"><span class="comment">     type:期望转为的 java 对象的全限定名称或别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;studentMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.bjpowernode.domain.Student&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 主键字段使用 id --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--非主键字段使用 result--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;email&quot;</span> <span class="attr">property</span>=<span class="string">&quot;email&quot;</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;age&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--resultMap: resultMap 标签中的 id 属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUseResultMap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;studentMap&quot;</span>&gt;</span></span><br><span class="line">     select id,name,email,age from student where name=#&#123;queryName&#125; or</span><br><span class="line">    age=#&#123;queryAge&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>测试方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectUseResultMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam param = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     param.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     param.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;Student&gt; stuList = studentDao.selectUseResultMap(param);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实体类属性名和列名不同的处理方式"><a href="#实体类属性名和列名不同的处理方式" class="headerlink" title="实体类属性名和列名不同的处理方式"></a>实体类属性名和列名不同的处理方式</h3><h4 id="使用列别名和"><a href="#使用列别名和" class="headerlink" title="使用列别名和"></a>使用列别名和<resultType></resultType></h4><ul>
<li> 创建新的实体类 PrimaryStudent</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bjpowernode.domain;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Description: 实体类 &lt;/p&gt;</span></span><br><span class="line"><span class="comment">* &lt;p&gt;Company: http://www.bjpowernode.com</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> Integer stuId;</span><br><span class="line">     <span class="keyword">private</span> String stuName;</span><br><span class="line">     <span class="keyword">private</span> Integer stuAge;</span><br><span class="line">     <span class="comment">// set , get 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;PrimaryStudent&gt; <span class="title">selectUseFieldAlias</span><span class="params">(QueryParam param)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Mapper文件</p>
</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;select id=<span class="string">&quot;selectUseFieldAlias&quot;</span></span><br><span class="line">resultType=<span class="string">&quot;com.bjpowernode.domain.PrimaryStudent&quot;</span>&gt;</span><br><span class="line">     select id as stuId, name as stuName,age as stuAge</span><br><span class="line">     from student where name=#&#123;queryName&#125; or age=#&#123;queryAge&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectUseFieldAlias</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam param = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     param.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     param.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;PrimaryStudent&gt; stuList;</span><br><span class="line">     stuList = studentDao.selectUseFieldAlias(param);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用 "></a>使用 <resultMap></resultMap></h4><ul>
<li><p>接口方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">List&lt;PrimaryStudent&gt; <span class="title">selectUseDiffResultMap</span><span class="params">(QueryParam param)</span></span>;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>mapper文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 创建 resultMap</span></span><br><span class="line"><span class="comment"> id:自定义的唯一名称，在&lt;select&gt;使用</span></span><br><span class="line"><span class="comment"> type:期望转为的 java 对象的全限定名称或别名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;primaryStudentMap&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">&quot;com.bjpowernode.domain.PrimaryStudent&quot;</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 主键字段使用 id --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuId&quot;</span> /&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--非主键字段使用 result--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;name&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuName&quot;</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;age&quot;</span> <span class="attr">property</span>=<span class="string">&quot;stuAge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--resultMap: resultMap 标签中的 id 属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUseDiffResultMap&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;primaryStudentMap&quot;</span>&gt;</span></span><br><span class="line">     select id,name,email,age from student</span><br><span class="line">     where name=#&#123;queryName&#125; or age=#&#123;queryAge&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ul>
<li><p>测试方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelectUseDiffResultMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">     QueryParam param = <span class="keyword">new</span> QueryParam();</span><br><span class="line">     param.setQueryName(<span class="string">&quot;李力&quot;</span>);</span><br><span class="line">     param.setQueryAge(<span class="number">20</span>);</span><br><span class="line">     List&lt;PrimaryStudent&gt; stuList;</span><br><span class="line">     stuList = studentDao.selectUseDiffResultMap(param);</span><br><span class="line">     stuList.forEach( stu -&gt; System.out.println(stu));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="模糊like"><a href="#模糊like" class="headerlink" title="模糊like"></a>模糊like</h3><p>模糊查询的实现有两种方式， 一是 java 代码中给查询数据加上“%” ; 二是在 mapper 文件 sql 语句的条件位置加上“%”。</p>
<img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/04.png" class>

 <img data-src="/2021/03/14/%E5%B0%81%E8%A3%85Mybatis%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C/05.png" class>

]]></content>
      <categories>
        <category>Mybatis框架</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统种类</title>
    <url>/2022/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>消息队列产品与RabbitMQ的简介</title>
    <url>/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="MQ常见产品"><a href="#MQ常见产品" class="headerlink" title="MQ常见产品"></a>MQ常见产品</h2><p>目前业界有很多的 MQ 产品，例如 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMq等，也有直接使用 Redis 充当消息队列的案例，而这些消息队列产品，各有侧重，在实际选型时，需要结合自身需求及 MQ 产品特征，综合考虑。</p>
<table>
<thead>
<tr>
<th></th>
<th><strong>RabbitMQ</strong></th>
<th><strong>ActiveMQ</strong></th>
<th><strong>RocketMQ</strong></th>
<th><strong>Kafka</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公司/社区</td>
<td>Rabbit</td>
<td>Apache</td>
<td>阿里</td>
<td>Apache</td>
</tr>
<tr>
<td>开发语言</td>
<td>Erlang</td>
<td>Java</td>
<td>Java</td>
<td>Scala&amp;Java</td>
</tr>
<tr>
<td>协议支持</td>
<td>AMQP，XMPP，SMTP，STOMP</td>
<td>OpenWire,STOMP，REST,XMPP,AMQP</td>
<td>自定义</td>
<td>自定义协议，社区封装了http协议支持</td>
</tr>
<tr>
<td>客户端支持语言</td>
<td>官方支持Erlang，Java，Ruby等,社区产出多种API，几乎支持所有语言</td>
<td>Java，C，C++，Python，PHP，Perl，.net等</td>
<td>Java，C++（不成熟）</td>
<td>官方支持Java,社区产出多种API，如PHP，Python等</td>
</tr>
<tr>
<td>单机吞吐量</td>
<td>万级（其次）</td>
<td>万级（最差）</td>
<td>十万级（最好）</td>
<td>十万级（次之）</td>
</tr>
<tr>
<td>消息延迟</td>
<td>微妙级</td>
<td>毫秒级</td>
<td>毫秒级</td>
<td>毫秒以内</td>
</tr>
<tr>
<td>功能特性</td>
<td>并发能力强，性能极其好，延时低，社区活跃，管理界面丰富</td>
<td>老牌产品，成熟度高，文档较多</td>
<td>MQ功能比较完备，扩展性佳</td>
<td>只支持主要的MQ功能，毕竟是为大数据领域准备的。</td>
</tr>
</tbody></table>
<ul>
<li>ActiveMQ 的社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用。</li>
<li>RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</li>
<li>RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的</li>
<li>kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。</li>
</ul>
<h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>2007年，Rabbit 技术公司基于 AMQP 标准开发的 RabbitMQ 1.0 发布。RabbitMQ 采用 Erlang 语言开发。Erlang 语言由 Ericson 设计，专门为开发高并发和分布式系统的一种语言，在电信领域使用广泛。</p>
<p>RabbitMQ基础架构如下图：</p>
<img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/02.png" class>

<h3 id="相关概念与基础架构"><a href="#相关概念与基础架构" class="headerlink" title="相关概念与基础架构"></a>相关概念与基础架构</h3><blockquote>
<p>RabbitMQ的相关概念</p>
</blockquote>
<ul>
<li><p> Broker：接收和分发消息的应用，RabbitMQ Server就是 Message Broker。</p>
</li>
<li><p>Virtual host：出于多租户和安全因素设计的，把 AMQP 的基本组件划分到一个虚拟的分组中，类似于网络中的 namespace 概念。当多个不同的用户使用同一个 RabbitMQ server 提供的服务时，可以划分出多个vhost，每个用户在自己的 vhost 创建 exchange／queue 等。</p>
</li>
<li><p>Connection：publisher／consumer 和 broker 之间的 TCP 连接。</p>
</li>
<li><p>Channel：如果每一次访问 RabbitMQ 都建立一个 Connection，在消息量大的时候建立 TCP Connection的开销将是巨大的，效率也较低。Channel 是在 connection 内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的 channel 进行通讯，AMQP method 包含了channel id 帮助客户端和message broker 识别 channel，所以 channel 之间是完全隔离的。Channel 作为轻量级的 Connection 极大减少了操作系统建立 TCP connection 的开销。</p>
</li>
<li><p>message 到达 broker 的第一站，根据分发规则，匹配查询表中的 routing key，分发消息到queue 中去。常用的类型有：direct (point-to-point), topic (publish-subscribe) and fanout (multicast)。</p>
</li>
<li><p>Queue：消息最终被送到这里等待 consumer 取走。</p>
</li>
<li><p>Bingding：exchange 和 queue 之间的虚拟连接，binding 中可以包含 routing key。Binding 信息被保存到 exchange 中的查询表中，用于 message 的分发依据。</p>
</li>
</ul>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><p>RabbitMQ 提供了 6 种工作模式：简单模式、work queues、Publish/Subscribe 发布与订阅模式、Routing 路由模式、Topics 主题模式、RPC 远程调用模式（远程调用，不太算 MQ；暂不作介绍）。</p>
<p><a href="https://www.rabbitmq.com/getstarted.html">官网对应模式介绍</a></p>
 <img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/03.png" class>



<h3 id="AMQP与JMS"><a href="#AMQP与JMS" class="headerlink" title="AMQP与JMS"></a>AMQP与JMS</h3><p>首先明确AMQP是协议，类比HTTP；JMS是API规范接口，类比JDBC。</p>
<h4 id="JMS简介"><a href="#JMS简介" class="headerlink" title="JMS简介"></a>JMS简介</h4><p>JMS（JAVA Message Service,java消息服务）是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。<strong>JMS（JAVA Message Service,Java消息服务）API是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p>
<p><strong>ActiveMQ 就是基于 JMS 规范实现的。</strong></p>
<h5 id="JMS两种消息模型"><a href="#JMS两种消息模型" class="headerlink" title="JMS两种消息模型"></a>JMS两种消息模型</h5><blockquote>
<p>点到点（P2P）模型</p>
</blockquote>
<img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/04.png" class>



<p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，**<em>一条消息只能被一个消费者使用**</em>，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送100条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）</p>
<blockquote>
<p>发布、订阅（Pub/Sub)模型</p>
</blockquote>
<img data-src="/2021/03/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BA%A7%E5%93%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%9E%8B/05.png" class>

<p>发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）</strong>作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p>
<h5 id="JMS五种不同的消息正文格式"><a href="#JMS五种不同的消息正文格式" class="headerlink" title="JMS五种不同的消息正文格式"></a>JMS五种不同的消息正文格式</h5><p>JMS定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。</p>
<ul>
<li>StreamMessage – Java原始值的数据流</li>
<li>MapMessage–一套名称-值对</li>
<li>TextMessage–一个字符串对象</li>
<li>ObjectMessage–一个序列化的 Java对象</li>
<li>BytesMessage–一个字节的数据流</li>
</ul>
<h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准,为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p>
<p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p>
<table>
<thead>
<tr>
<th>对比</th>
<th align="center">JMS</th>
<th>AMQP</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td align="center"></td>
<td></td>
</tr>
<tr>
<td>定义</td>
<td align="center">Java API</td>
<td>协议</td>
</tr>
<tr>
<td>跨语言</td>
<td align="center">否</td>
<td>是</td>
</tr>
<tr>
<td>跨平台</td>
<td align="center">否</td>
<td>是</td>
</tr>
<tr>
<td>支持消息类型</td>
<td align="center">提供两种消息模型：①Peer-2-Peer;②Pub/sub</td>
<td>提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>
</tr>
<tr>
<td>支持消息类型</td>
<td align="center">支持多种消息类型 ，我们在上面提到过</td>
<td>byte[]（二进制</td>
</tr>
</tbody></table>
<p>####总结</p>
<ul>
<li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而JMS所定义的是API规范。在 Java 体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而AMQP天然具有跨平台、跨语言特性。</li>
<li>JMS 支持TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。</li>
<li>由于Exchange 提供的路由算法，AMQP可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li>
</ul>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网刷题-操作系统2</title>
    <url>/2022/02/18/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>类文件结构</title>
    <url>/2021/01/16/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>#类文件结构</p>
<h2 id="虚拟机的无关性"><a href="#虚拟机的无关性" class="headerlink" title="虚拟机的无关性"></a>虚拟机的无关性</h2><p>Java的宣传口号是: <strong><em>WRITE ONCE , RUN ANYWHREE</em></strong></p>
<p>java虚拟机力求实现的两种无关性：</p>
<ol>
<li><p>平台无关性</p>
<p>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——–字节码（ByteCode）是构成平台无关性的基础，虚拟机可以载入同一种平台无关的字节码。</p>
</li>
<li><p>语言无关性：</p>
<p><strong>举例</strong>：除了Java之外，Clojure、Groovy、JRuby、Jython、Scala都可以在Java虚拟机上运行</p>
<p>实现语言无关性的基础是Java虚拟机不与任何语言绑定，只与**<em>“Class文件”这种特殊的二进制文件格式**</em>相关联，Class文件包含了Java虚拟机指令集和符号表以及若干其他辅助信息，在Class文件中使用了许多强制性的语法和结构化约束，任何一门语言都可以表示为被JAVA虚拟机锁接受的有效的Class文件。虚拟机只关心Class文件本身，而不关心Class文件的来源是哪种语言。</p>
<p>在Class文件中，各种关键字、变量、和运算符号的语义都是有多条字节码命令组合而成的，字节码命令所能提供的语义描述能力必然要比java语言本身更为强大，所以Java虚拟机提供的支持远比java语言本身强大。</p>
</li>
</ol>
<h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格的按照顺序紧凑的排列在Class文件中，中间没有任何的分隔符，这使得整个Class文件中存储的内容几乎全是程序运行的必要数据，没有空隙存在。</p>
<p>Class文件格式采用一种类似于C语言中struct的伪结构来进行存储数据：包括<strong>无符号数+表</strong></p>
<p>1、无符号数：基本数据类型</p>
<p>2、表：有多个无符号数或者其他表作为数据项构成的复合数据类型，习惯性的以__info结尾。表用于描述有层次关系的复合结构的数据。整个class文件本质上就是一张表。</p>
<h3 id="magic-numer与class文件版本"><a href="#magic-numer与class文件版本" class="headerlink" title="magic numer与class文件版本"></a>magic numer与class文件版本</h3><h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><h3 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h3><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>###属性表集合</p>
]]></content>
      <categories>
        <category>JVM虚拟机</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>系统调用是内核与用户进程进行交互的一组接口，这些接口让应用程序受限制的访问硬件设备，提供了创建新进程并与已有进程进行交互通信的机制，也提供了申请操作系统其他资源的能力。</p>
<p>系统调用在Linux系统中的地位如下图所示：</p>
<img data-src="/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/OIP1.jpg" class>

<h3 id="2-与内核通信"><a href="#2-与内核通信" class="headerlink" title="2.与内核通信"></a>2.与内核通信</h3><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。这样的中间层有如下作用：</p>
<blockquote>
<p>1.为用户空间提供了一种硬件的抽象接口。</p>
</blockquote>
<blockquote>
<p>2.系统调用确保了系统的稳定与安全。内核可以作为硬件设备与用户空间之间的中间人，基于权限、用户类型和一些其他的规则对需要进行的访问做出裁决。</p>
</blockquote>
<blockquote>
<p>3.避免用户空间的应用程序对硬件资源随意访问而内核一无所知，这样既无法实现多任务和虚拟内存，也不能确保良好的稳定性和安全性。</p>
</blockquote>
<p><strong>Linux中：系统调用是用户空间访问内核的唯一手段—-除了异常和陷入外，它们是内核唯一的合法入口</strong></p>
<h3 id="3-API、POSIX、C库"><a href="#3-API、POSIX、C库" class="headerlink" title="3.API、POSIX、C库"></a>3.API、POSIX、C库</h3><p>应用程序通过在用户空间实现的应用编程接口（API）而不是直接通过系统调用。</p>
<blockquote>
<p>1.API实际上并不需要与内核提供的系统调用一一对应，程序员只跟API打交道。</p>
<p>2.内核只跟系统调用打交道，库函数以及应用程序如何使用系统调用不是内核所关心的。</p>
<p>3.API可以实现成一个系统调用，也可以实现多个系统调用，甚至也可以不实现系统调用。</p>
</blockquote>
<p>在UNIX中，最流行的应用编程接口是基于POSIX标准的。</p>
<p>Linux系统调用作为C库的一部分提供。C库实现了Unix系统的主要API，包括标准C库函数和系统调用接口，此外，C库提供了POSIX的绝大部分API。</p>
<h3 id="4-系统调用-syscall"><a href="#4-系统调用-syscall" class="headerlink" title="4.系统调用(syscall)"></a>4.系统调用(syscall)</h3><p><strong>通过在C库中定义的函数调用来执行</strong></p>
<p>系统调用在出现错误的时候C库会将错误码写入errno全局变量。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<p>为了保证32为操作系统和64位操作系统的兼容，系统调用在用户空间和内核空间有着不同的返回值类型。用户空间为int，内核空间为long。系统调用在内核中前面会加上sys_。例如：返回当前进程PID的系统调用get_pid（）在内核中被定义为sys_getpid()。</p>
<h4 id="4-1系统调用号"><a href="#4-1系统调用号" class="headerlink" title="4.1系统调用号"></a>4.1系统调用号</h4><p>在Linux中，每个系统调用都会被赋予一个系统调用号（独一无二的）。进程在执行系统调用时，不需要提及系统调用的名称，只需要使用系统调用号即可。</p>
<p><strong>系统调用号相当重要，一旦分配好就不能再更改，因为会导致之前编译好的应用程序崩溃。</strong>即使这个系统调用被删除，它所占用的系统调用号也不允许被回收利用。</p>
<p>内核记录了系统调用表中的所有已经注册过的系统调用的列表，存储在sys_call_table中，这个表为每一个有效的</p>
<p>系统调用指定了唯一的系统调用号。</p>
<h4 id="4-2系统调用的性能"><a href="#4-2系统调用的性能" class="headerlink" title="4.2系统调用的性能"></a>4.2系统调用的性能</h4><p>Linux系统调用比其他许多的操作系统执行要快。原因如下：</p>
<blockquote>
<p>1.Linux很短的上下文切换时间，进出内核都被优化的极为高效。</p>
<p>2.系统调用处理程序和每个系统调用本身非常简洁。</p>
</blockquote>
<h3 id="5-系统调用处理程序"><a href="#5-系统调用处理程序" class="headerlink" title="5.系统调用处理程序"></a>5.系统调用处理程序</h3><p>应用程序通过<strong>软中断</strong>的方式来告诉内核自己期望执行一个系统调用，希望系统当前可以从用户态切换到内核态，这样内核就可以代表应用程序在内核空间中执行系统调用。</p>
<p><strong>软中断</strong>：通过引起一个异常来促使系统切换到内核态前去执行异常处理程序。此时的异常处理程序其实就是<strong>系统调用处理程序</strong>。</p>
<p>在X86系统中预定义的软中断是中断号128，通过int $0x80来触发中断。这条指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序（系统调用处理程序）。</p>
<h4 id="5-1指定恰当的系统调用"><a href="#5-1指定恰当的系统调用" class="headerlink" title="5.1指定恰当的系统调用"></a>5.1指定恰当的系统调用</h4><p>在陷入内核空间时，要将系统调用号传给内核空间。X86系统，系统调用号是通过eax寄存器传递给内核的。system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。大于或者等于NR_syscalls，函数就返回-ENOSYS,否则，执行相应的系统调用。</p>
<p>系统调用表中的表项是以64位类型存放的，所以内核需要将给定的系统调用号乘4，然后用所得结果在表中查询位置。</p>
<h4 id="5-2参数传递"><a href="#5-2参数传递" class="headerlink" title="5.2参数传递"></a>5.2参数传递</h4><p>部分系统调用除了系统调用号之外，还需要传入一些外部参数，在发生陷入的时候，一并传给内核，同样是放在寄存器中。<strong>给用户空间的返回值同样是通过寄存器来传递的</strong></p>
<h3 id="6-系统调用的实现"><a href="#6-系统调用的实现" class="headerlink" title="6.系统调用的实现"></a>6.系统调用的实现</h3><h4 id="6-1实现系统调用"><a href="#6-1实现系统调用" class="headerlink" title="6.1实现系统调用"></a>6.1实现系统调用</h4><p>要求：</p>
<ul>
<li>Linux中不提倡采用多用途的系统调用（一个系统调用通过传递不同的参数值来完成选择的工作）</li>
<li>系统调用的接口应该力求简洁，参数尽量少。提供标志参数以确保向前兼容。</li>
<li>系统调用的设计越通用越好。</li>
</ul>
<h4 id="6-2参数验证"><a href="#6-2参数验证" class="headerlink" title="6.2参数验证"></a>6.2参数验证</h4><p>系统调用必须检查参数是否合法有效。系统调用在内核空间中执行，任由用户将不合法的输入传递给内核，系统大的安全和稳定性将面临考验。进程不能让内核访问那些他没有权限访问的数据。</p>
<ul>
<li>与文件IO有关的系统调用需要检查文件描述符是否有效，与进程有关的函数必须检查提供的PID是否有效。</li>
<li>检查用户提供的指针是否有效<ul>
<li>指针指向的内存区域只能属于用户空间，进程不能告诉内核去读内核空间中的数据。</li>
<li>指针指向的内存区域在自己的进程中，不能让内核去读其他进程中的数据。</li>
<li>进程不能越过内存访问限制（可读、可写、可执行）</li>
</ul>
</li>
<li>检查是否有合法权限</li>
</ul>
<p>内核提供了两个方法来完成必须的检查和内核空间与用户空间之间的数据来回拷贝</p>
<ul>
<li>写入：copy_to_user()</li>
<li>读取：copy_from_user()</li>
</ul>
<p>这两个方法可能会引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，进程会休眠，直到缺页处理程序将该页从硬盘从新换回物理内存。</p>
<h3 id="7-系统调用上下文"><a href="#7-系统调用上下文" class="headerlink" title="7.系统调用上下文"></a>7.系统调用上下文</h3><p>在进程调用系统调用时，会有进程上下文。既可以被抢占也可以休眠。</p>
<p>可以休眠说明系统调用可以利用内核提供的绝大部分功能。可以被抢占说明该系统调用时可重入的（新的进程同样可以使用相同的系统调用）。</p>
<p>系统调用返回时，控制权仍然在system_call()中，它最终会负责切换到内核工作空间，并让用户进程继续执行下去。</p>
<h4 id="7-1绑定一个系统调用的最后步骤"><a href="#7-1绑定一个系统调用的最后步骤" class="headerlink" title="7.1绑定一个系统调用的最后步骤"></a>7.1绑定一个系统调用的最后步骤</h4><blockquote>
<p>1.在系统调用表中的最后加入一个表项。从0开始算起，系统调用在表中的位置就是他的系统调用号。</p>
</blockquote>
<blockquote>
<p>2.系统调用必须被编译进内核映像（不能被编译成模块）</p>
</blockquote>
<h4 id="7-2从用户空间访问系统调用"><a href="#7-2从用户空间访问系统调用" class="headerlink" title="7.2从用户空间访问系统调用"></a>7.2从用户空间访问系统调用</h4><p>系统调用靠的时C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用。</p>
<p><strong>Linux新系统调用增添频率很低，说明Linux系统是一个相对较为稳定并且功能已经较为完善的操作系统</strong></p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>Linux系统内核设计</tag>
      </tags>
  </entry>
  <entry>
    <title>红队常用行话总结一</title>
    <url>/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/</url>
    <content><![CDATA[<h2 id="漏洞利用术语解读"><a href="#漏洞利用术语解读" class="headerlink" title="漏洞利用术语解读"></a>漏洞利用术语解读</h2><blockquote>
<p>Vulnerability:即漏洞，</p>
</blockquote>
<p>是指计算机软件、硬件、系统、应用、协议等方面的缺陷，使得其保密性、完整性、可用性、访问控制等方面面临威胁。</p>
<ul>
<li><p>基于技术分类，有命令执行、权限绕过、缓存区溢出、注入、解析、弱口令、信息泄露等漏洞</p>
</li>
<li><p>基于时间分类，有0day、1day、Nday等漏洞</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/01.png" class>

<img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/02.png" class>

</li>
</ul>
<blockquote>
<p>Poc (Proof of Content)概念验证</p>
</blockquote>
<p>泛指对某些想法的一个较短而不完整的实现；在网络安全领域，通常指的是一段漏洞验证程序或者说是攻击样例，仅能验证漏洞存在，但并不能对漏洞造成实质性利用。在[计算机安全]术语中，<strong>概念验证</strong>经常被用来作为<a href="https://zh.wikipedia.org/wiki/0day">0day</a>、<a href="https://zh.wikipedia.org/wiki/Exploit">exploit</a>的别名。（通常指并没有充分利用这个漏洞的exploit）</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/03.png" class>

<blockquote>
<p>Exploit 漏洞利用</p>
</blockquote>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/04.png" class>



<p>代表一段有漏洞价值的攻击代码或者漏洞利用过程，目的是获取未经授权的访问或者执行意外操作。常见的漏洞利用手段包括SQL注入、缓存区溢出、远程代码执行等。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/05.png" class>

 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/06.png" class>



<blockquote>
<p>Payload 攻击载荷</p>
</blockquote>
<p>通常是指Exploit在拿下目标之后，攻击者在目标机器上执行的定制代码或者程序，包括但不限于系统命令、会话建立、Shellcode等。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/07.png" class>



<blockquote>
<p>Shellcode</p>
</blockquote>
<ul>
<li><p>shell：泛指系统控制权或者操作界面（CLI/GUI），通常在Exploit漏洞利用之后，首先要做的就是拿shell，以此进行进一步操作。</p>
</li>
<li><p>shellcode：用于获取控制权或者操作界面的攻击载荷代码，通常采用二进制机器代码，shellcode也是payload的一种类型</p>
</li>
<li><p>正反shell：shell需要绑定至指定IP地址后端口号上面，这个动作就是bindshell；有攻击方主动连接至受害者，则为正向shell；反之，由受害者主动连接至攻击方，则为反向shell。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/08.png" class>

</li>
</ul>
<p>shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机械码，让电脑可以执行攻击者的任意指令。</p>
<ul>
<li>本地shellcode：本地运行的shellcode经常用于利用软件<a href="https://zh.wikipedia.org/wiki/%E6%BC%8F%E6%B4%9E">漏洞</a>提升权限。比如在Linux下由普通权限提升至<a href="https://zh.wikipedia.org/wiki/Root%E6%9D%83%E9%99%90">root权限</a>。</li>
<li>远程shellcode：借由抓软件漏洞获得特定的shellcode，再经由C或Python撰写远端攻击程式，进而取得对方电脑之root权限。</li>
</ul>
<h2 id="恶意程序术语解读"><a href="#恶意程序术语解读" class="headerlink" title="恶意程序术语解读"></a>恶意程序术语解读</h2><blockquote>
<p>Malware(Malicious Software) </p>
</blockquote>
<p>即恶意程序或软件，泛指病毒、蠕虫、木马、勒索软件、间谍软件，用于对目标系统进行入侵、控制、窃取、破坏等。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/09.png" class>

<blockquote>
<p>Worm</p>
</blockquote>
<p>Worm即蠕虫病毒，能够独立于其他文件或者程序运行，能够给予网络进行自我复制或者传播，能实现从点到面的超大规模的破坏行为（例如占用CPU或带宽资源、修改删除文件）。</p>
<p>计算机病毒不同的是，计算机蠕虫不需要附在别的程序内，可能不用用户介入操作也能自我复制或运行。计算机蠕虫未必会直接破坏被感染的系统，却几乎都对网络有害。计算机蠕虫可能会执行垃圾代码以发动分布式拒绝服务攻击，令计算机的执行效率极大程度降低，从而影响计算机的正常使用；可能会损毁或修改目标计算机的文件；亦可能只是浪费<a href="https://zh.wikipedia.org/wiki/%E9%A0%BB%E5%AF%AC">带宽</a>。（恶意的）计算机蠕虫可根据其目的分成2类：</p>
<ul>
<li>一种是面对大规模计算机使用网络发动拒绝服务的计算机蠕虫，虽说会绑架计算机，但用户可能还可以正常使用，只是会被占用一部分运算、连网能力。</li>
<li>另一种是针对个人用户的以执行大量垃圾代码的计算机蠕虫。计算机蠕虫多不具有跨平台性，但是在其他平台下，可能会出现其平台特有的非跨平台性的平台版本。</li>
</ul>
<p>计算机蠕虫的传播过程：蠕虫程序常驻于一台或多台机器中，通常它会扫描其他机器是否有感染同种计算机蠕虫，如果没有，就会通过其内置的传播手段进行感染，以达到使计算机瘫痪的目的。其通常会以宿主机器作为扫描源。通常采用：<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6">垃圾邮件</a>、漏洞传播这2种方法来传播</p>
<p>例子：2006年的熊猫烧香，通过网站投毒、局域网共享等方式植入系统并进行传播，Windows用户中毒后，后缀名为.exe的文件无法执行，文件图标会变成熊猫烧香的图案。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/10.png" class>





<blockquote>
<p>Virus病毒</p>
</blockquote>
<p>通常依附于其他文件或者程序上，不进行自我复制获知或者传播，当受害者运行其它程序时则病毒启动，对目标系统造成破坏（例如修改删除文件）。</p>
<p>例子：1998年的<strong>CIH病毒</strong>，能够破坏BIOS和硬盘，是电脑可以完全瘫痪，被公认为有史以来最为危险、破坏力最强的病毒之一。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/11.png" class>

<p>! <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/12.png" class></p>
<p>由于<a href="https://zh.wikipedia.org/wiki/%E4%B8%96%E7%95%8C">世界</a><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>[桌面环境]90%的市场都是使用<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E8%BD%AF">微软</a>[Windows] 系列产品 ， 所以病毒作者纷纷把病毒攻击对象选为Windows。制作病毒者首先应该确定要攻击的操作系统版本有何<a href="https://zh.wikipedia.org/wiki/%E6%BC%8F%E6%B4%9E">漏洞</a>，这才是他所写的病毒能够利用的关键。Windows当时并没有有效的安全与防御功能，且用户常以管理员权限运行未经安全检查的软件，这也为Windows下病毒的泛滥提供了温床。<a href="https://zh.wikipedia.org/wiki/Linux">Linux</a>、<a href="https://zh.wikipedia.org/wiki/Mac_OS">Mac OS</a>等<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>，因使用的人群比较少，病毒一般不容易扩散。大多病毒发布作者的目的有多种，包括恶作剧、想搞破坏、报复及想出名与对研究病毒有特殊嗜好。 病毒主要通过<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E8%B7%AF">网路</a>浏览以及<a href="https://zh.wikipedia.org/wiki/%E4%B8%8B%E8%BD%BD">下载</a>，<a href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E5%AD%90%E9%83%B5%E4%BB%B6">电子邮件</a>以及可移动<a href="https://zh.wikipedia.org/wiki/%E7%A3%81%E7%A2%9F">磁盘</a>等途径迅速传播。[<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92#cite_note-mc-4">4</a></p>
<p>Trojan Horse(特洛伊木马)</p>
<p>通常潜伏于“合法”软件中运行（也可以独立运行），不复制传播且高度隐蔽。木马运行时可以创建“后门”或者“隧道”，攻击者通过后门实现对目标系统的远程控制、监听、破坏行为。RAT（Remote Access Trojan）远控木马属于木马的一种，例如灰鸽子、冰河、Gh0st、ZXShell。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/13.png" class>





<blockquote>
<p>Ransomware(勒索软件)</p>
</blockquote>
<p>能够独立于其他文件运行，能够基于网络进行自我复制或者传播，通过对目标系统进行加密劫持，实现对受害者的钱财勒索。在所有的恶意程序类别中，勒索软件时面向个人和机构的最直接、最有效、最野蛮的“敛财方式”。</p>
 <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/14.png" class>

<blockquote>
<p>Spyware(间谍软件)</p>
</blockquote>
<p>流氓软件或者恶意软件，指未经用户许可搜集用户个人信息的恶意程序。通过搜集网站的浏览记录、键盘记录、账号密码等隐私信息，再以网站劫持、网址导航、弹框广告等方式变现盈利。</p>
  <img data-src="/2021/03/02/%E7%BA%A2%E9%98%9F%E5%B8%B8%E7%94%A8%E8%A1%8C%E8%AF%9D/15.png" class>



<blockquote>
<p>Rootkits</p>
</blockquote>
<p>可看作升级型的木马病毒，泛指可以获取到<strong>root</strong>权限的恶意程序，以管理员权限运行、修改系统核心文件、绕过杀毒软件，包括系统内核rootkit、硬件固件rootkit、内存rootkit等类型。相比木马，Rootkits通常具备更高权限、更加隐蔽、更难查杀、更大危害等特征。、</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>红队攻防入门1</title>
    <url>/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/</url>
    <content><![CDATA[<h2 id="红队攻防入门1–初识红队"><a href="#红队攻防入门1–初识红队" class="headerlink" title="红队攻防入门1–初识红队"></a>红队攻防入门1–初识红队</h2><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F1.png" class>

<p>###红队概念</p>
<p><strong>红队（Red Team）即安全团队最大化模拟真实世界里面的入侵事件，采用入侵者的战术、技术、流程，以此来检验蓝队（Blue Team）的威胁检测和应急响应的机制和效率，最终帮助企业真正提高整个安全建设、安全运营、安全管理等能力。</strong></p>
<p>####1.1红队VS渗透测试</p>
<p>在企业内部的一般的渗透测试，很多就是点到为止，并不会被授予很多的权限。而红队整体来看，在合法合规的前提下，在充分沟通的前提下，授权范围会更加广泛，真实程度更加贴合实战。</p>
<img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F2.jpg" class>

<h4 id="1-2红队VS蓝队"><a href="#1-2红队VS蓝队" class="headerlink" title="1.2红队VS蓝队"></a>1.2红队VS蓝队</h4><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F3.jpg" class>

<p>无论是Red Team 还是Blue Team,这些概念都来自真实的战争领域。</p>
<blockquote>
<p>作为红队，是以攻击方的方式做安全工作的，常见的技术概念有APT攻击、渗透测试、零日漏洞、武器开发。</p>
</blockquote>
<blockquote>
<p>作为蓝队，则以防御方的方式做安全工作，是安全合规、安全运营、应急响应、态势感知、威胁情报等等。</p>
</blockquote>
<p>####1.3 红队常用模型框架</p>
 <img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F4.jpg" class>



<p>#####1.3.1渗透测试执行标准PTES</p>


<p>PTES中文全名【渗透测试执行标准】，他是有2010年由业界网络安全专家共同发起并定义的规范，目标是希望为企业和安全服务商，指定整个渗透测试的标准流程，方便大家工作和沟通。</p>
<p>PTES 包括 7 个标准步骤，即前期交互、情报收集、威胁建模、漏洞分析、渗透利用、报告输出等，一般的渗透测试工作，基本都绕不开这些步骤，可以看成一个标准的工作流。</p>
<p><strong>① 前期交互</strong></p>
<p>前期交互阶段，我们得先拿到客户的授权，并且了解授权范围多少？渗透目标是谁？期望目标是什么？</p>
<p>这些都是前期交互阶段要沟通好的。</p>
<p><strong>② 情报搜集</strong></p>
<p>情报搜集阶段，即根据上面的授权、范围、目标等信息，开始进行一些情报搜集工作。</p>
<p>无论是主动搜集还是被动搜集，我们得知道对方开了哪个端口、提供了什么服务、这些服务的软件版本是什么、这些软件是否曾经出现过漏洞？</p>
<p><strong>③ 威胁建模</strong></p>
<p>哪些信息是真正有价值的？哪个口子用什么攻击方法？哪条攻击路径是最大可能的？</p>
<p>根据情报搜集的汇总，我们得制定出接下来的「作战计划」。</p>
<p>这些就是在威胁建模阶段要分析出来的。</p>
<p><strong>④ 漏洞分析</strong></p>
<p>结合以上情报搜集和威胁建模阶段，此阶段我们要判断出哪些漏洞是最有可能拿到对方权限，打通攻击路径的。</p>
<p>哪些漏洞的攻击效果最佳？</p>
<p>哪些漏洞有最新的工具？</p>
<p>哪些漏洞需要自研渗透代码？</p>
<p><strong>⑤ 渗透利用</strong></p>
<p>前面 4 个阶段都不算真正 Hack 进目标系统，而这个阶段则是真正对目标进行渗透攻击，通过漏洞对应的利用工具等，获取目标控制权。</p>
<p><strong>⑥ 后渗透</strong></p>
<p>在拿到控制权限之后，为了避免对方发现，还需要进行后渗透，实现更持久地控制，更深层次地执行任务。</p>
<p>比如进程迁移、隧道建立、数据获取、擦除痕迹等。</p>
<p><strong>⑦ 报告输出</strong></p>
<p>最后阶段就是输出一份安全报告，即写明渗透测试工作中，企业 IT 基础系统所存在的漏洞和风险点。</p>
<p>以上便是 PTES 渗透测试执行标准。</p>
<h5 id="1-3-2网络杀伤链Cyber-Kill-Chain"><a href="#1-3-2网络杀伤链Cyber-Kill-Chain" class="headerlink" title="1.3.2网络杀伤链Cyber Kill Chain"></a>1.3.2网络杀伤链Cyber Kill Chain</h5><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F6.jpg" class>

<p>网络杀伤链的英文全名是 Cyber Kill Chain，这是 2011 年洛克希德马丁公司提出的网络攻击模型。</p>
<p>跟真实世界的入侵者，对一个目标系统进行攻击的每个阶段都是一一映射的。</p>
<p>这里也分为 7 个步骤 =&gt;</p>
<p><strong>第 1 步，目标侦察，</strong>跟前面 PTES 情报收集阶段是差不多的；</p>
<p><strong>第 2 步，武器研制，</strong>编写各种工具/后门/病毒 Exp / Weapon / Malware；</p>
<p><strong>第 3 步，载荷投递，</strong>通过水坑鱼叉等攻击方式将武器散播出去（<strong>投毒</strong>）；</p>
<p><strong>第 4 步，渗透利用，</strong>通过<strong>漏洞利用</strong>获取对方控制器；</p>
<p><strong>第 5 步，安装执行</strong>，在目标系统将<strong>后门木马</strong>跑起来；</p>
<p><strong>第 6 步，命令控制，</strong>对目标来进行<strong>持久化控制</strong>；</p>
<p><strong>第 7 步，任务执行，</strong>即开始执行<strong>窃取数据、破坏系统</strong>等。</p>
<p>以上便是网络杀伤链，相比 PTES 更加贴合实战阶段。</p>
<h5 id="1-3-3MITRE-ATT-amp-CK框架"><a href="#1-3-3MITRE-ATT-amp-CK框架" class="headerlink" title="1.3.3MITRE ATT&amp;CK框架"></a>1.3.3MITRE ATT&amp;CK框架</h5><img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F7.jpg" class>

<p>「<strong>ATT&amp;CK 框架</strong>」，由 MITRE 公司于 2013 年提出来的一个通用知识框架，中文名叫做「<strong>对抗战术、技术、常识</strong> 」 。</p>
<p>ATT&amp;CK 框架是基于真实网络空间攻防案例及数据，采用军事战争中的 <strong>TTPs （Tactics, Techniques &amp; Procedures）</strong>方法论，重新编排的网络安全知识体系，目的是建立一套网络安全的通用语言。</p>
<p>举例，大家经常听到的什么 APT 攻击、威胁情报、态势感知等等，无论个人还是企业，理解上不尽相同，总会有一些偏差的。</p>
<p>有了 ATT&amp;CK 框架，大家不会存在太大的偏差，红队具体怎么去攻击的，蓝队具体到怎么去防御的，使用 ATT&amp;CK 矩阵可以将每个细节标记出来，攻击路线和防御过程都可以图形展现出来，攻防双方就有了一套通用语言了。</p>
<p>网络安全行业的组织、机构、厂家，每年都会造各种 ”新词“，但 MITRE 这个组织推的这套框架，兼具实战和学术价值，具备广泛的应用场景，对安全行业的发展推动是实实在在的。</p>
<p>我认为，在未来 5 年也好 10 年也好 ，它可能会成为一个事实上的标准。</p>
<p>这里看一下左上角图片，它整体有三个部分，一个是 PRE ATT&amp;CK，一个是 ATT&amp;CK for Enterprise，一个是 ATT&amp;CK for Mobile，我们学习和研究时，核心放在 ATT&amp;CK forEnterprise 即可。</p>
<p>大家可以看到，其实左边这里面，也有侦查、武器化、载荷传递、利用、控制、执行、维持等等阶段，是不是跟前面介绍的网络杀伤链是一样的呢？</p>
<p>是的，你可以这么简单理解，其实 ATT&amp;CK 这个框架，刚开始就是在杀伤链的基础上，提供了更加具体的、更细颗粒度的战术、技术、文档、工具、描述等等。</p>
<p>因此，如果要深入学习红队，平常可以多逛逛去 ATT&amp;CK 框架官网。</p>
<img data-src="/2021/02/06/%E7%BA%A2%E9%98%9F%E6%94%BB%E9%98%B2%E5%85%A5%E9%97%A81/%E7%BA%A2%E9%98%9F8.jpg" class>

<p>接下来，我们来重点看一下 ATT&amp;CK for Enterprise。</p>
<p>这张图里面，横轴代表是战术（Tactics），最新版本里横轴包括的战术有 12 个（原来是 10 个），纵轴代表的是技术（Techniques）有 156 个技术 272 个子技术。</p>
<p>前面我们提到了，它是基于 TTPs 方法来描述的，所以非常标准和通用。</p>
<p>在实际的红蓝对抗、威胁情报分析、安全差距评估等工作场景中，都可以用得上。</p>
<p>另外补充一点，这 12 个战术从左到右，也是按照网络杀伤链的路径来编排的，包括初始访问、执行、持久化、权限提升、防御绕过、凭证访问、发现、横向移动、收集、命令控制、数据获取、影响。</p>
<p>每一个战术下面包括很多技术，每个技术有详细的过程，包括独立的编号、描述、工具等。</p>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>红队攻防</tag>
      </tags>
  </entry>
  <entry>
    <title>编程范式</title>
    <url>/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<p>相信绝大部分开发人员、DBA都听过范式这个词，在MySQL中有第一范式、第二范式、第三范式、BCNF范式等，在开发中也有相应的范式，专业词汇叫编程范式(ProgrammingParadigm)。由于笔者能力、精力都有限，本篇主要通过针对同一业务场景，基于编程范式的概念，核心原理以及用例实现来对比不同范式及其实现业务功能的差异。</p>
<p>范式分类</p>
<p>如图1所示，范式可以简单分为三类:</p>
<p>图1: 范式的简单分类</p>
 <img data-src="/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/01.jpg" class>

<p>范式和语言的关系</p>
<p>图2: 范式和语言的关系</p>
 <img data-src="/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/02.jpg" class>

<p>与成百种编程语言相比，编程范式要少得多，如图2所示，共有27种范式。多数范式之间仅相差一个或几个概念，比如图中的函数编程范式，在加入了状态（state）之后就变成了面向对象编程范式。</p>
<p>| 编程范式</p>
<p>图3: 华山派剑气之争</p>
 <img data-src="/2021/03/02/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F/03.jpg" class>

<blockquote>
<p>过程式编程的核心在于模块化，在实现过程中使用了状态，依赖了外部变量，导致很容易影响附近的代码，可读性较少，后期的维护成本也较高。</p>
</blockquote>
<blockquote>
<p>函数式编程的核心在于“避免副作用”，不改变也不依赖当前函数外的数据。结合不可变数据、函数是第一等公民等特性，使函数带有自描述性，可读性较高。</p>
</blockquote>
<blockquote>
<p>面向对象编程的核心在于抽象，提供清晰的对象边界。结合封装、集成、多态特性，降低了代码的耦合度，提升了系统的可维护性。</p>
</blockquote>
<p>不同的范式的出现，目的就是为了应对不同的场景，但最终的目标都是提高生产力。就如华山派的剑宗、气宗之别，剑宗认为“剑为主，气为辅”，而气宗则反之。每个范式都会有自己的”心法”，但最终殊途同归，达到至高境界后则是剑气双修。</p>
<p>| 小结</p>
<p>阅读完之前内容后，相信各位读者对编程范式有了初步的理解，那么接下来就和笔者一起来实现业务的真实需求。</p>
<p>| 需求</p>
<pre><code> 1.解析并收集shannon, fio 两种 flash卡的温度、寿命等信息。

 2.对实现代码进行单元测试</code></pre>
<p>在用过程式实现之前，笔者先给大家介绍下什么叫过程式编程。</p>
<p>| 过程式编程(Procedural)</p>
<p>过程式编程和面向对象编程的区别并不在于是否使用函数或者类，也就是说用到类或对象的可能是过程式编程，只用函数而没有类的也可能是面向对象编程。那么他们的区别又在哪儿呢？</p>
<p>面向过程其实是最为实际的一种思考方式，可以说面向过程是一种基础的方法，它考虑的是实际地实现。一般的面向过程是从上往下步步求精，所以面向过程最重要的是模块化的思想方法。当程序规模不是很大时，面向过程的方法还会体现出一种优势。因为程序的流程很清楚，按着模块与函数的方法可以很好的组织。</p>
<p>关键部分实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shannon_info</span>(<span class="params">output</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;获取shannon类型flash卡信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_health</span>():</span></span><br><span class="line">        time_left = <span class="built_in">float</span>(sub_info[<span class="string">&quot;life_left&quot;</span>])</span><br><span class="line">        <span class="keyword">if</span> time_left &lt; DISK_ALARM_LIFETIME:</span><br><span class="line">            message = <span class="string">&quot;time left is less than &#123;&#125;%&quot;</span>.<span class="built_in">format</span>(DISK_ALARM_LIFETIME)</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        temperature = <span class="built_in">float</span>(sub_info[<span class="string">&quot;temperature&quot;</span>].split()[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> temperature &gt; DISK_ALARM_TEMPERATURE:</span><br><span class="line">            message = <span class="string">&quot;temperature is over than &#123;&#125; C&quot;</span>.<span class="built_in">format</span>(DISK_ALARM_TEMPERATURE)</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;healthy&quot;</span></span><br><span class="line"> </span><br><span class="line">    result = &#123;&#125;</span><br><span class="line">    all_info = _get_shannon_info(output)</span><br><span class="line">    <span class="keyword">for</span> info <span class="keyword">in</span> all_info:</span><br><span class="line">        sub_info = &#123;&#125;</span><br><span class="line">        sub_info[<span class="string">&quot;available_capacity&quot;</span>] = info.get(<span class="string">&quot;disk_capacity&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;device_name&quot;</span>] = info.get(<span class="string">&quot;block_device_node&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;firmware_version&quot;</span>] = info.get(<span class="string">&quot;firmware_version&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;interface&quot;</span>] = <span class="string">&quot;PCIe&quot;</span></span><br><span class="line">        sub_info[<span class="string">&quot;life_left&quot;</span>] = <span class="built_in">str</span>(info.get(<span class="string">&quot;estimated_life_left&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;%&quot;</span>, <span class="string">&quot;&quot;</span>))</span><br><span class="line">        sub_info[<span class="string">&quot;pcie_id&quot;</span>] = info.get(<span class="string">&quot;pci_deviceid&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;pcie_length&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">        sub_info[<span class="string">&quot;pcie_type&quot;</span>] = <span class="string">&quot;&quot;</span></span><br><span class="line">        sub_info[<span class="string">&quot;physical_read&quot;</span>] = info.get(<span class="string">&quot;host_read_data&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;physical_write&quot;</span>] = info.get(<span class="string">&quot;total_write_data&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;serial_number&quot;</span>] = info.get(<span class="string">&quot;serial_number&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;temperature&quot;</span>] = info.get(<span class="string">&quot;controller_temperature&quot;</span>)</span><br><span class="line">        sub_info[<span class="string">&quot;type&quot;</span>] = info[<span class="string">&quot;type&quot;</span>]</span><br><span class="line">        sub_info[<span class="string">&quot;error_msg&quot;</span>] = check_health()</span><br><span class="line">        sub_info[<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;ok&quot;</span> <span class="keyword">if</span> sub_info[<span class="string">&quot;error_msg&quot;</span>] == <span class="string">&quot;healthy&quot;</span> <span class="keyword">else</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">        <span class="keyword">if</span> sub_info[<span class="string">&quot;serial_number&quot;</span>]:</span><br><span class="line">            result[sub_info[<span class="string">&quot;serial_number&quot;</span>]] = sub_info</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result[sub_info[<span class="string">&quot;device_name&quot;</span>]] = sub_info</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>代码问题</p>
<pre><code>1.逻辑冗长，局部修改必须阅读整段代码

2.对外部变量有依赖

3.内部存在共享变量

4.函数内部存在临时变量</code></pre>
<p>测试代码</p>
<p>过程式的测试代码效果远不如函数式有效，过程式的实现逻辑过于冗长，导致测试效果并不够好。</p>
<p>| 函数式编程(Functional)</p>
<p>当谈论函数式编程，会提到非常多的“函数式”特性。提到不可变数据，第一类对象以及尾调用优化，这些是帮助函数式编程的语言特征。提到mapping（映射），reducing（归纳），piplining（管道），recursing（递归），currying（科里化），以及高阶函数的使用，这些是用来写函数式代码的编程技术。提到并行，惰性计算以及确定性，这些是有利于函数式编程的属性。</p>
<p>最主要的原则是避免副作用，它不会依赖也不会改变当前函数以外的数据。</p>
<p>声明式的函数，让开发者只需要表达 “想要做什么”，而不需要表达 “怎么去做”，这样就极大地简化了开发者的工作。至于具体 “怎么去做”，让专门的任务协调框架去实现，这个框架可以灵活地分配工作给不同的核、不同的计算机，而开发者不必关心框架背后发生了什么。</p>
<p>关键部分实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_shannon_info</span>(<span class="params">output</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;查询shannon类型flash卡信息</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    lines = checks_string_split_by_function(output, is_shannon_flash_device)</span><br><span class="line">    info = <span class="built_in">map</span>(parser_shannon_info, lines)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># map(lambda x: x.setdefault(&quot;type&quot;, &quot;shannon&quot;), info)</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line">        item[<span class="string">&quot;type&quot;</span>] = <span class="string">&quot;shannon&quot;</span></span><br><span class="line"> </span><br><span class="line">    data = <span class="built_in">map</span>(modify_the_properties, info)</span><br><span class="line">    <span class="keyword">return</span> reduce(combining_data, <span class="built_in">map</span>(convert_data_format, data))</span><br></pre></td></tr></table></figure>
<p>以上代码带有自描述性，通过函数名就可知在做什么，这也是函数式的一个特性: 代码是在描述要干什么，而不是怎么干。</p>
<p>测试代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;line, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash car&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash card a&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash card&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE Flash card.&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_is_shannon_flash_device</span>(<span class="params">line, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.is_shannon_flash_device(line) == result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;line, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;a=1&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;b=2&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;c=2333&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;d x=abcde&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE=1&quot;</span>, <span class="literal">True</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abcdedfew=&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot; =Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;=Found Shannon PCIE&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE=&quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;Found Shannon PCIE= &quot;</span>, <span class="literal">False</span></span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_is_effective_value</span>(<span class="params">line, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.is_effective_value(line) == result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;line, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;a=1&quot;</span>, &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;1&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;b=2&quot;</span>, &#123;<span class="string">&quot;b&quot;</span>: <span class="string">&quot;2&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;a=a&quot;</span>, &#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abc=a&quot;</span>, &#123;<span class="string">&quot;abc&quot;</span>: <span class="string">&quot;a&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abc=abcde&quot;</span>, &#123;<span class="string">&quot;abc&quot;</span>: <span class="string">&quot;abcde&quot;</span>&#125;</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_gets_the_index_name_and_value</span>(<span class="params">line, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.gets_the_index_name_and_value(line) == result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;output, filter_func, result&quot;</span>, [</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="string">&quot;abcd\nbcd\nabcd\nbcd\naa\naa&quot;</span>, <span class="keyword">lambda</span> x: <span class="string">&quot;a&quot;</span> <span class="keyword">in</span> x, [<span class="string">&quot;abcd\nbcd&quot;</span>, <span class="string">&quot;abcd\nbcd&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;aa&quot;</span>]</span>),</span></span></span><br><span class="line"><span class="meta"><span class="params">(<span class="params"><span class="built_in">open</span>(<span class="params">os.path.join(<span class="params">project_path, <span class="string">&quot;fixtures&quot;</span>, <span class="string">&quot;shannon-status.txt&quot;</span></span>)</span>).read(<span class="params"></span>), functional.is_shannon_flash_device, [</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="params">    <span class="built_in">open</span>(<span class="params">os.path.join(<span class="params">project_path, <span class="string">&quot;fixtures&quot;</span>, <span class="string">&quot;shannon-sctb.txt&quot;</span></span>)</span>).read(<span class="params"></span>),</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="params">    <span class="built_in">open</span>(<span class="params">os.path.join(<span class="params">project_path, <span class="string">&quot;fixtures&quot;</span>, <span class="string">&quot;shannon-scta.txt&quot;</span></span>)</span>).read(<span class="params"></span>)</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="params">]</span>)</span></span></span><br><span class="line"><span class="meta"><span class="params">]</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_checks_string_split_by_function</span>(<span class="params">output, filter_func, result</span>):</span></span><br><span class="line">    <span class="keyword">assert</span> functional.checks_string_split_by_function(output, filter_func) == result</span><br></pre></td></tr></table></figure>
<p>| 面向对象编程(Object-Oriented)</p>
<p>并不是使用类才是面向对象编程。如果你专注于状态改变和密封抽象，你就是在用面向对象编程。类只是帮助简化面向对象编程的工具，并不是面向对象编程的要求或指示器。封装是一个过程，它分隔构成抽象的结构和行为的元素。封装的作用是分离抽象的概念接口及其实现。类只是帮助简化面向对象编程的工具，并不是面向对象编程的要求或指示器。</p>
<p>随着系统越来越复杂，系统就会变得越来越容易崩溃，分而治之，解决复杂性的技巧。面对对象思想的产生是为了让你能更方便的理解代码。有了那些封装，多态，继承，能让你专注于部分功能，而不需要了解全局。</p>
<p>关键部分实现代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IFlash</span>(<span class="params">six.with_metaclass(<span class="params">abc.ABCMeta</span>)</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">    @abc.abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;收集flash卡物理信息</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlashShannon</span>(<span class="params">IFlash</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;宝存的Flash卡</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, txt_path, command, printer</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FlashShannon, self).__init__()</span><br><span class="line">        self.txt_path = txt_path</span><br><span class="line"> </span><br><span class="line">        self.command = command</span><br><span class="line">        self.printer = printer</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span>(<span class="params">self</span>):</span></span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> self._get_shannon_info():</span><br><span class="line">            life_left = <span class="built_in">str</span>(info.get(<span class="string">&quot;estimated_life_left&quot;</span>, <span class="string">&quot;&quot;</span>)).replace(<span class="string">&quot;%&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            temperature = info.get(<span class="string">&quot;controller_temperature&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">            error_msg = self._get_health_message(life_left, temperature)</span><br><span class="line">            sub_info = &#123;</span><br><span class="line">                <span class="string">&quot;available_capacity&quot;</span>: info.get(<span class="string">&quot;disk_capacity&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;device_name&quot;</span>: info.get(<span class="string">&quot;block_device_node&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;firmware_version&quot;</span>: info.get(<span class="string">&quot;firmware_version&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;interface&quot;</span>: <span class="string">&quot;PCIe&quot;</span>,</span><br><span class="line">                <span class="string">&quot;life_left&quot;</span>: life_left,</span><br><span class="line">                <span class="string">&quot;pcie_id&quot;</span>: info.get(<span class="string">&quot;pci_deviceid&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;pcie_length&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;pcie_type&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                <span class="string">&quot;physical_read&quot;</span>: info.get(<span class="string">&quot;host_read_data&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;physical_write&quot;</span>: info.get(<span class="string">&quot;total_write_data&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;serial_number&quot;</span>: info.get(<span class="string">&quot;serial_number&quot;</span>, <span class="string">&quot;&quot;</span>),</span><br><span class="line">                <span class="string">&quot;temperature&quot;</span>: temperature,</span><br><span class="line">                <span class="string">&quot;type&quot;</span>: info[<span class="string">&quot;type&quot;</span>],</span><br><span class="line">                <span class="string">&quot;error_msg&quot;</span>: error_msg,</span><br><span class="line">                <span class="string">&quot;status&quot;</span>: <span class="string">&quot;ok&quot;</span> <span class="keyword">if</span> error_msg == <span class="string">&quot;healthy&quot;</span> <span class="keyword">else</span> <span class="string">&quot;error&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> sub_info[<span class="string">&quot;serial_number&quot;</span>]:</span><br><span class="line">                result[sub_info[<span class="string">&quot;serial_number&quot;</span>]] = sub_info</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result[sub_info[<span class="string">&quot;device_name&quot;</span>]] = sub_info</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p>​     </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlashFio</span>(<span class="params">IFlash</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;fio的Flash卡</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, txt_path</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FlashFio, self).__init__()</span><br><span class="line">        self.txt_path = txt_path</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collect</span>(<span class="params">self</span>):</span></span><br><span class="line">        disk_info = &#123;&#125;</span><br><span class="line">        adapter_info = self._get_adapter_info()</span><br><span class="line">        <span class="keyword">for</span> info <span class="keyword">in</span> adapter_info:</span><br><span class="line">            serial_number = info[<span class="string">&quot;fio_serial_number&quot;</span>]</span><br><span class="line">            <span class="keyword">for</span> io <span class="keyword">in</span> info[<span class="string">&quot;iomemory&quot;</span>]:</span><br><span class="line">                data = self._combining_io_memory(io)</span><br><span class="line">                data[<span class="string">&quot;serial_number&quot;</span>] = serial_number</span><br><span class="line">                disk_info[serial_number] = data</span><br><span class="line">        <span class="keyword">return</span> disk_info</span><br></pre></td></tr></table></figure>
<p>| 编程范式带来的好处</p>
<p>范式就像武功心法，可以更快的练成绝世神功，但还是离不开基础功。代码也一样，通过遵循相关范式和良好的设计后，会带来可读性、扩展性和可维护性更好的代码，进而提升软件的质量。</p>
<p>| 总结</p>
<p>命令式编程、面向对象编程、函数式编程，虽然受人追捧的时间点各不相同，但是本质上并没有优劣之分。 面向对象和函数式、过程式编程也不是完成独立和有严格的界限，在抽象出各个独立的对象后，每个对象的具体行为实现还是有函数式和过程式完成。</p>
<p>现代的程序员应该很少有门派之见了，应该集百家之所长，学习其它范式(语言)的优秀设计理念，集成到自己的代码(产品、语言)中，提升工作效率。</p>
]]></content>
      <categories>
        <category>计算机常识</category>
      </categories>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title>网络服务性能指标</title>
    <url>/2021/09/25/%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h1 id="一、QPS，每秒查询"><a href="#一、QPS，每秒查询" class="headerlink" title="一、QPS，每秒查询"></a>一、QPS，每秒查询</h1><p>QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
<p>互联网中，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。</p>
<h1 id="二、TPS，每秒事务"><a href="#二、TPS，每秒事务" class="headerlink" title="二、TPS，每秒事务"></a>二、TPS，每秒事务</h1><p>TPS：是TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p>
<p>QPS vs TPS：QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。</p>
<h1 id="三、RT，响应时间"><a href="#三、RT，响应时间" class="headerlink" title="三、RT，响应时间"></a>三、RT，响应时间</h1><p>响应时间：执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。</p>
<p>响应时间RT(Response-time)，是一个系统最重要的指标之一，它的数值大小直接反应了系统的快慢。</p>
<h1 id="四、并发数"><a href="#四、并发数" class="headerlink" title="四、并发数"></a>四、并发数</h1><p>并发数是指系统同时能处理的请求数量，这个也是反应了系统的负载能力。</p>
<h1 id="五、吞吐量"><a href="#五、吞吐量" class="headerlink" title="五、吞吐量"></a>五、吞吐量</h1><p>系统的吞吐量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个request 对CPU消耗越高，外部系统接口、IO速度越慢，系统吞吐能力越低，反之越高。</p>
<p>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间。</p>
<ol>
<li>QPS（TPS）：（Query Per Second）每秒钟request/事务 数量</li>
<li>并发数： 系统同时处理的request/事务数</li>
<li>响应时间： 一般取平均响应时间</li>
</ol>
<p>理解了上面三个要素的意义之后，就能推算出它们之间的关系：</p>
<ul>
<li><strong>QPS（TPS）= 并发数/平均响应时间</strong></li>
<li><strong>并发数 = QPS*平均响应时间</strong></li>
</ul>
<h1 id="六、实际举例"><a href="#六、实际举例" class="headerlink" title="六、实际举例"></a>六、实际举例</h1><p>我们通过一个实例来把上面几个概念串起来理解。按二八定律来看，如果每天 80% 的访问集中在 20% 的时间里，这 20% 时间就叫做峰值时间。</p>
<ul>
<li>公式：( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数(QPS)</li>
<li>机器：峰值时间每秒QPS / 单台机器的QPS = 需要的机器</li>
</ul>
<p><strong>1、每天300w PV 的在单台机器上，这台机器需要多少QPS？</strong><br>( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</p>
<p><strong>2、如果一台机器的QPS是58，需要几台机器来支持？</strong><br>139 / 58 = 3</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>高并发网络性能指标</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络/应用层</title>
    <url>/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>研发网络应用程序的核心是写出能够运行在**<em>不同的端系统**</em>和通过网络彼此通信的程序。</p>
<img data-src="/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220223121648233.png" alt="image-20220223121648233" style="zoom:50%;">

<h2 id="网络应用体系结构（network-application-architecture）"><a href="#网络应用体系结构（network-application-architecture）" class="headerlink" title="网络应用体系结构（network application architecture）"></a>网络应用体系结构（network application architecture）</h2><h3 id="客户端-服务器体系结构（client-server-architecture）"><a href="#客户端-服务器体系结构（client-server-architecture）" class="headerlink" title="客户端-服务器体系结构（client-server architecture）"></a>客户端-服务器体系结构（client-server architecture）</h3><p>特征：</p>
<blockquote>
<p>有一个总是打开的主机成为服务器，服务于来自许多客户端的请求</p>
</blockquote>
<blockquote>
<p>服务器具有固定的、周知的地址，成为IP地址</p>
</blockquote>
<p><img data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1725642%2F202003%2F1725642-20200329223925870-559284185.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648189567&t=9fa0bc55891c197654d45ebacade79eb" alt="img"></p>
<h3 id="P2P体系结构（P2P-architecture）"><a href="#P2P体系结构（P2P-architecture）" class="headerlink" title="P2P体系结构（P2P architecture）"></a>P2P体系结构（P2P architecture）</h3><p> <img data-src="/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220223143338617.png" alt="image-20220223143338617"></p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/P2P-network.svg/200px-P2P-network.svg.png" alt="img"></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>多数应用程序是由通信进程对组成，每对中的两个进程五相发送报文。进程向另一个进程发送的报文必须通过下面的网络 。进程通过一个称为**<em>套接字 (socket)**</em>的软件接口向网络发送报文和从网络接收报文 </p>
<img data-src="/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/BLOG\source\_posts\计算机网络-应用层\image01.png" style="zoom:200%;">

<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol , HTTP) ，它是 Web</p>
<p>的核心。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP 报文进行会话。 HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p>HTTP 使用 TCP 作为它的支撑运输协议，(而不是在 UDP 上运行)  。HTTP 客户首先发起一个与服务器的 TCP 连接 一旦连接建立，该浏览器和 服务器进程就可以通过套接字接口访问 TCP。</p>
<p><strong><em>HTTP 个无状态协议 (stateless protocol)</em></strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式--之六大原则</title>
    <url>/2021/05/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="六大设计原则其三：依赖倒置原则"><a href="#六大设计原则其三：依赖倒置原则" class="headerlink" title="六大设计原则其三：依赖倒置原则"></a>六大设计原则其三：依赖倒置原则</h1><h2 id="依赖倒置原则的定义"><a href="#依赖倒置原则的定义" class="headerlink" title="依赖倒置原则的定义"></a>依赖倒置原则的定义</h2><p>涉及到三个概念：</p>
<blockquote>
<p>模块（高层模块和底层模块－－原子模块）<br>抽象：接口或者抽象类<br>细节：实现类<br>三者之间的关系：<br>模块依赖于抽象；<br>细节依赖于抽象，抽象不依赖与细节；</p>
</blockquote>
<p><strong>即所谓的面向接口编程（OOD）</strong></p>
<p>优点：减少类之间的耦合性，提高系统稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>
<p>变更之间见真功夫。好的程序就是周围环境在频繁变化时，我自岿然不动。<br>并行开发的风险：风险扩散。不使用依赖倒置原则就会单线程，一个人作为另一个人接着做。要使用并发，就要使用依赖倒置原则来降低类之间的耦合关系，从而减少并发风险。</p>
<p>变更时最好只修改高层模块，使业务可以正常运行，把“变更”带来的风险降到最低。<br>JAVA变量的两种类型：表面类型和实际类型</p>
<p>并行开发实际举例：TDD（Test-Driven Development）—-测试驱动开发<br>定义：先写好单元测试类，再写实现类。</p>
<p>重点：抽象是对实现的约束，对依赖者而言，不仅仅约束自己，同时也约束自己与外部的关系。</p>
<h2 id="依赖的三种写法（对比spring框架的IOC-DI依赖注入功能实现）："><a href="#依赖的三种写法（对比spring框架的IOC-DI依赖注入功能实现）：" class="headerlink" title="依赖的三种写法（对比spring框架的IOC DI依赖注入功能实现）："></a>依赖的三种写法（对比spring框架的IOC DI依赖注入功能实现）：</h2><p>构造函数传递依赖对象。<br>Setter方法传递依赖对象<br>接口声明传入对象（在声明接口时将依赖的对象传入）</p>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>理解依赖正置和倒置的区别。<br>正置：类之间的依赖是实实在在的依赖，面相实现编程<br>倒置：对事物之间的关系进行抽象，根据系统设计要求产生抽象之间的依赖。</p>
<p>依赖倒置原则的核心：<br>面向接口编程！！！！</p>
<p>项目中依赖倒置原则的具体实践:</p>
<ol>
<li>每个类尽量都要有接口或者抽象类。（基本要求）</li>
<li>变量的表面类型尽量是接口或者是抽象类。</li>
<li>任何类都不应该从具体类中派生（有的时候没有必要一定要去继承最高的基类，通过一个继承关系，覆写几个方法就完事了）</li>
<li>尽量不要对基类的抽象方法进行覆写，防止破坏抽象之间的依赖关系。</li>
<li>可以结合里氏替换原则进行使用。</li>
</ol>
<h1 id="六大设计原则之-lt-接口隔离原则-gt-："><a href="#六大设计原则之-lt-接口隔离原则-gt-：" class="headerlink" title="六大设计原则之&lt;接口隔离原则&gt;："></a>六大设计原则之&lt;接口隔离原则&gt;：</h1><p>JAVA中接口分为两种：<br>1.实例接口：从某一种角度来看，JAVA中的类也是一种借口。 Person person = new Person();<br>2.类接口：interface</p>
<h2 id="接口隔离原则的简单理解："><a href="#接口隔离原则的简单理解：" class="headerlink" title="接口隔离原则的简单理解："></a>接口隔离原则的简单理解：</h2><p>类之间的依赖关系应该尽量建立在最小接口上。（建立单一接口，不要建立臃肿的接口；接口尽量细化，接口中的方法尽量细化。）<br>从这个角度来说，要注意和单一职责原则的区别。<br>单一职责原则：注重的是职责，这是业务逻辑上的划分。<br>接口隔离原则：注重的是接口功能实现的细化，方法尽量少。</p>
<p>接口的设计太过于庞大，包含的可变因素就多，对于代码后期的可维护性和可扩展性是不利的，封装过度。<br>通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>重点：设计是有限度的，不能无限的考虑未来的变更情况，这样才不至于陷入设计的泥潭中不能自拔，终极目的还是业务功能的实现。</p>
<h2 id="保证接口的纯洁性"><a href="#保证接口的纯洁性" class="headerlink" title="保证接口的纯洁性"></a>保证接口的纯洁性</h2><p>实现接口隔离原则：</p>
<ol>
<li>接口要尽量小。（根据接口隔离原则对接口进行拆分时，首先必须要满足单一职责原则）－－－－换句话来说，就是不要拆的太狠。</li>
<li>接口要高内聚，提高接口、类、模块的处理能力，减少与外界的交互。即在接口中尽量少用public方法，减少对外的承诺，承诺越少对系统的开发就越为有利，变更的风险也就越小，同时有利于降低开发成本。</li>
<li>定制服务<br>举例说明：IBookSearch接口，拆分为<br>ISimpleBookSearcher         IComplexBookSearcher<br>不同的接口根据权限的不同开放给不同的客户使用。如果写在一起，未免权限划分不开，大家都能干某几件事（比较占用系统资源），这时候就会影响线上程序的整体性能。</li>
</ol>
<p>4.接口的设计是有限度的<br>还是那句话，接口功能粒度划分的不是越细越好，会带来结构复杂化，开发难度增加，可维护性降低</p>
<h2 id="最佳实践-1"><a href="#最佳实践-1" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>1.接口或者类尽量使用原子接口或者原子类来组装。<br>2.一个接口尽量只服务于一个子模块或者业务逻辑。<br>3.压缩接口中的public方法</p>
<h1 id="六大设计原则之-lt-迪米特法则-gt-LoD-Law-of-Demeter"><a href="#六大设计原则之-lt-迪米特法则-gt-LoD-Law-of-Demeter" class="headerlink" title="六大设计原则之&lt;迪米特法则&gt; LoD  Law of Demeter"></a>六大设计原则之&lt;迪米特法则&gt; LoD  Law of Demeter</h1><p>也称为最少知识原则（least knowledge  principle),简单定义就是一个类对自己需要耦合或者调用的类（组合、聚合、依赖等）知道的最少。<br>我只关注与你暴露出来供我使用的public方法，其他内部实现细则不论多复杂我一概不管。</p>
<h2 id="四层含义："><a href="#四层含义：" class="headerlink" title="四层含义："></a>四层含义：</h2><p>1.只和“朋友进行交流”<br>先定义一下朋友类：<br>出现在成员变量、方法的输入输出参数中的类称为朋友类，出现在方法体内部的类不是朋友类。<br>迪米特法则要求我们的类只和自己的朋友类进行交流。（类与类之间的关系是建立在类之间的，而不是方法间，因此尽量不要再方法中引入一个类中不存在的对象。）<br>  方法是类的一个行为，类不允许自己的行为与其他类产生依赖关系是不自知的。<br>这样可以提高系统的健壮性，降低系统之间的耦合性。</p>
<ol start="2">
<li>  “朋友类之间的关系不能太过于紧密”<br>如果两个类的关系太过于紧密（例如：一个类向另一个类暴露了太多的方法），就会造成耦合关系过于牢固。<br>例如，A类向B类暴露了很多的方法，A类修改其中的一个方法时，调用A类方法的B类就要做出相应修改，这样就增加了修改变更的风险。</li>
</ol>
<p>重点：一个类公开的public属性或者方法越多，修改时涉及到的面就越广，变更引起的风险扩散也就越大。<br>在设计时，可以考虑是否可以修改为private、package-private、protected等访问权限，是否可以加上final关键字等。</p>
<p>3.方法的放置问题：<br>如果一个方法放置在本类中也可以，放在其他类中也不错。那么这时候对方法的归属问题遵循一个原则：<br>如果一个方法放置在本类中，既不增加类间关系，也不会对本类产生负面影响，就可以放置在本类中。</p>
<p>4.谨慎使用Serializable</p>
<p>最佳实践：<br>迪米特法则的核心观念就是类之间的解耦、弱耦合。只有弱耦合之后，类的复用率才会提升。这种要求的结果就是会产生大量的中转或者跳转类，导致系统的复杂性提高，同时也为维护带来了难度。规则的应用，既要确保结构清晰，又要最大化的实现类之间的高内聚低耦合。－－－－－－－解耦是有限度的。</p>
<h1 id="设计模式六大原则之“开闭原则”"><a href="#设计模式六大原则之“开闭原则”" class="headerlink" title="设计模式六大原则之“开闭原则”"></a>设计模式六大原则之“开闭原则”</h1><p>开闭原则是JAVA中最基础的设计原则。<br>开闭原则的定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。<br>具体解释来说，就是一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。<br>软件实体包括以下几个部分：<br>项目或者软件产品中按照一定逻辑规则划分的模块。<br>抽象或者类<br>方法<br>软件产品在其生命周期内，都会发生变化，开闭原则正是已在设计时尽量适应这些变化，提高项目的稳定性和灵活性，真正实现“拥抱变化”为目的。</p>
<p>对于已经投产的项目来说，应对需求变化有几种方式：</p>
<ol>
<li>修改接口。<br>在接口上添加方法，所有的实现类都实现该方法。但是这样的方式是不推崇的。一方面，实体类依据接口的变化做出的改变也很多，这是极其不方便的；另一方面，接口本身作为一种契约，应该是稳定和可靠的，经常发生变化就会失去这样的效能。</li>
</ol>
<p>2.修改实体类<br>在项目中经常采用的方法，这种方法在项目有明确的章程或者优良的架构设计时，是一种非常优秀的方法。<br>但是，有的时候也会因为直接修改实体类而出现信息不对称的情况（例如：直接在书籍实体类中加入了打折程序，在调用getprice后，采购人员希望获得的是原价，这个时候因为返回了打折后的价格就会出现信息不对称造成决策失误。）</p>
<p>3.通过扩展来实现变化<br>可以添加新的模块来实现特定的功能。</p>
<p>注意：开闭原则对扩展开放、对修改关闭。这并不意味着对原代码不做任何修改。底层模块的变更，必然会引起高层模块进行耦合，否则就是一个孤立无异议的代码片段。</p>
<p>常见的变化可以分为三种类型：</p>
<ol>
<li>逻辑变化<br>只变化一个逻辑，而不影响其他模块。</li>
</ol>
<p>2.子模块变化<br>一个模块的变化会对其他模块产生影响。<br>特别是低层次的模块变化必然会影起高层次模块的变化。</p>
<p>3.可见视图的变化</p>
<p>重点：保持代码历史的纯洁性，放弃修改历史的想法。<br>一个项目的开发路径：<br>项目开发、重构、测试、投产、运维<br>其中的重构可以对原有的设计和代码进行修改，运维尽量减少对原有代码的修改，保持历史代码的纯洁性，提高系统稳定性。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计消息队列--&gt;2</title>
    <url>/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>持久性是事务的一个特性，然而只满足持久性却不一定能满足事务的特性。还是拿扣钱/加钱的例子讲。满足事务的一致性特征，则必须要么都不进行，要么都能成功。 解决方案从大方向上有两种：</p>
<blockquote>
<p>两阶段提交，分布式事务。</p>
</blockquote>
<blockquote>
<p>本地事务，本地落地，补偿发送。</p>
</blockquote>
<p>分布式事务存在的最大问题是成本太高，两阶段提交协议，对于仲裁down机或者单点故障，几乎是一个无解的黑洞。对于交易密集型或者I/O密集型的应用，没有办法承受这么高的网络延迟，系统复杂性。 并且成熟的分布式事务一定构建与比较靠谱的商用DB和商用中间件上，成本也太高。 那如何使用本地事务解决分布式事务的问题呢？以本地和业务在一个数据库实例中建表为例子，与扣钱的业务操作同一个事务里，将消息插入本地数据库。如果消息入库失败，则业务回滚；如果消息入库成功，事务提交。 然后发送消息（注意这里可以实时发送，不需要等定时任务检出，以提高消息实时性）。以后的问题就是前文的最终一致性问题所提到的了，只要消息没有发送成功，就一直靠定时任务重试。 这里有一个关键的点，本地事务做的，是业务落地和消息落地的事务，而不是业务落地和RPC成功的事务。这里很多人容易混淆，如果是后者，无疑是事务嵌套RPC，是大忌，会有长事务死锁等各种风险。 而消息只要成功落地，很大程度上就没有丢失的风险（磁盘物理损坏除外）。而消息只要投递到服务端确认后本地才做删除，就完成了producer-&gt;broker的可靠投递，并且当消息存储异常时，业务也是可以回滚的。 本地事务存在两个最大的使用障碍：</p>
<blockquote>
<p>配置较为复杂，“绑架”业务方，必须本地数据库实例提供一个库表。</p>
</blockquote>
<blockquote>
<p>对于消息延迟高敏感的业务不适用。</p>
</blockquote>
<p>话说回来，不是每个业务都需要强事务的。扣钱和加钱需要事务保证，但下单和生成短信却不需要事务，不能因为要求发短信的消息存储投递失败而要求下单业务回滚。所以，一个完整的消息队列应该定义清楚自己可以投递的消息类型，如事务型消息，本地非持久型消息，以及服务端不落地的非可靠消息等。对不同的业务场景做不同的选择。另外事务的使用应该尽量低成本、透明化，可以依托于现有的成熟框架，如Spring的声明式事务做扩展。业务方只需要使用@Transactional标签即可。</p>
<h2 id="性能相关"><a href="#性能相关" class="headerlink" title="性能相关"></a>性能相关</h2><h3 id="异步、同步"><a href="#异步、同步" class="headerlink" title="异步、同步"></a>异步、同步</h3><p>首先澄清一个概念，异步，同步和oneway是三件事。异步，归根结底你还是需要关心结果的，但可能不是当时的时间点关心，可以用轮询或者回调等方式处理结果；同步是需要当时关心 的结果的；而oneway是发出去就不管死活的方式，这种对于某些完全对可靠性没有要求的场景还是适用的，但不是我们重点讨论的范畴。 回归来看，任何的RPC都是存在客户端异步与服务端异步的，而且是可以任意组合的：客户端同步对服务端异步，客户端异步对服务端异步，客户端同步对服务端同步，客户端异步对服务端同步。 对于客户端来说，同步与异步主要是拿到一个Result，还是Future(Listenable)的区别。实现方式可以是线程池，NIO或者其他事件机制，这里先不展开讲。 服务端异步可能稍微难理解一点，这个是需要RPC协议支持的。参考servlet 3.0规范，服务端可以吐一个future给客户端，并且在future done的时候通知客户端。 整个过程可以参考下面的代码：</p>
<blockquote>
<p>客户端同步服务端异步</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = request(server);<span class="comment">//server立刻返回future</span></span><br><span class="line"><span class="keyword">synchronized</span>(future)&#123;</span><br><span class="line"><span class="keyword">while</span>(!future.isDone())&#123;</span><br><span class="line">   future.wait();<span class="comment">//server处理结束后会notify这个future，并修改isdone标志</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> future.get();</span><br></pre></td></tr></table></figure>


<blockquote>
<p>客户端同步服务端同步</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result result = request(server);</span><br></pre></td></tr></table></figure>


<blockquote>
<p>客户端异步服务端同步（使用线程池方式）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = executor.submit(<span class="keyword">new</span> Callable()&#123;<span class="keyword">public</span> <span class="keyword">void</span> call&lt;Result&gt;()&#123;</span><br><span class="line">    result = request(server);</span><br><span class="line">&#125;&#125;)</span><br><span class="line"><span class="keyword">return</span> future;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>客户端异步服务端异步</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Future&lt;Result&gt; future = request(server);<span class="comment">//server立刻返回future</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> future</span><br></pre></td></tr></table></figure>
<p>上面说了这么多，其实是想让大家脱离两个误区：</p>
<ul>
<li><p>RPC只有客户端能做异步，服务端不能。</p>
</li>
<li><p>异步只能通过线程池。</p>
</li>
</ul>
<p>那么，服务端使用异步最大的好处是什么呢？说到底，是解放了线程和I/O。试想服务端有一堆I/O等待处理，如果每个请求都需要同步响应，每条消息都需要结果立刻返回，那么就几乎没法做I/O合并 （当然接口可以设计成batch的，但可能batch发过来的仍然数量较少）。而如果用异步的方式返回给客户端future，就可以有机会进行I/O的合并，把几个批次发过来的消息一起落地（这种合并对于MySQL等允许batch insert的数据库效果尤其明显），并且彻底释放了线程。不至于说来多少请求开多少线程，能够支持的并发量直线提高。 来看第二个误区，返回future的方式不一定只有线程池。换句话说，可以在线程池里面进行同步操作，也可以进行异步操作，也可以不使用线程池使用异步操作（NIO、事件）。 回到消息队列的议题上，我们当然不希望消息的发送阻塞主流程（前面提到了，server端如果使用异步模型，则可能因消息合并带来一定程度上的消息延迟），所以可以先使用线程池提交一个发送请求，主流程继续往下走。 但是线程池中的请求关心结果吗？Of course，必须等待服务端消息成功落地，才算是消息发送成功。所以这里的模型，准确地说事客户端半同步半异步（使用线程池不阻塞主流程，但线程池中的任务需要等待server端的返回），server端是纯异步。客户端的线程池wait在server端吐回的future上，直到server端处理完毕，才解除阻塞继续进行。 总结一句，同步能够保证结果，异步能够保证效率，要合理的结合才能做到最好的效率。</p>
<h2 id="批量"><a href="#批量" class="headerlink" title="批量"></a>批量</h2><p>谈到批量就不得不提生产者消费者模型。但生产者消费者模型中最大的痛点是：消费者到底应该何时进行消费。大处着眼来看，消费动作都是事件驱动的。主要事件包括：</p>
<ol>
<li>攒够了一定数量。</li>
<li>到达了一定时间。</li>
<li>队列里有新的数据到来。</li>
</ol>
<p>对于及时性要求高的数据，可用采用方式3来完成，比如客户端向服务端投递数据。只要队列有数据，就把队列中的所有数据刷出，否则将自己挂起，等待新数据的到来。 在第一次把队列数据往外刷的过程中，又积攒了一部分数据，第二次又可以形成一个批量。伪代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">final</span> BlockingQueue&lt;Message&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> Runnable task = <span class="keyword">new</span> Runnable(&#123;<span class="comment">//这里由于共享队列，Runnable可以复用，故做成全局的</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;Message&gt; messages  = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">      queue.drainTo(messages，<span class="number">20</span>);</span><br><span class="line">      doSend(messages);<span class="comment">//阻塞，在这个过程中会有新的消息到来，如果4个线程都占满，队列就有机会囤新的消息</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    queue.offer(message);</span><br><span class="line">    executor.submit(task)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式是消息延迟和批量的一个比较好的平衡，但优先响应低延迟。延迟的最高程度由上一次发送的等待时间决定。但可能造成的问题是发送过快的话批量的大小不够满足性能的极致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Executor executor = Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">final</span> BlockingQueue&lt;Message&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;();</span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">long</span> last = System.currentMills();</span><br><span class="line">Executors.newSingleThreadScheduledExecutor().submit(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">   flush();</span><br><span class="line">&#125;，<span class="number">500</span>，<span class="number">500</span>，TimeUnits.MILLS);</span><br><span class="line"><span class="keyword">private</span> Runnable task = <span class="keyword">new</span> Runnable(&#123;<span class="comment">//这里由于共享队列，Runnable可以复用，顾做成全局的。</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">      List&lt;Message&gt; messages  = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">20</span>);</span><br><span class="line">      queue.drainTo(messages，<span class="number">20</span>);</span><br><span class="line">      doSend(messages);<span class="comment">//阻塞，在这个过程中会有新的消息到来，如果4个线程都占满，队列就有机会屯新的消息。</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">    last = System.currentMills();</span><br><span class="line">    queue.offer(message);</span><br><span class="line">    flush();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(queue.size&gt;<span class="number">200</span>||System.currentMills()-last&gt;<span class="number">200</span>)&#123;</span><br><span class="line">       executor.submit(task)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相反对于可以用适量的延迟来换取高性能的场景来说，用定时/定量二选一的方式可能会更为理想，既到达一定数量才发送，但如果数量一直达不到，也不能干等，有一个时间上限。 具体说来，在上文的submit之前，多判断一个时间和数量，并且Runnable内部维护一个定时器，避免没有新任务到来时旧的任务永远没有机会触发发送条件。对于server端的数据落地，使用这种方式就非常方便。</p>
<p>最后啰嗦几句，曾经有人问我，为什么网络请求小包合并成大包会提高性能？主要原因有两个：</p>
<ul>
<li><p>减少无谓的请求头，如果你每个请求只有几字节，而头却有几十字节，无疑效率非常低下。</p>
</li>
<li><p>减少回复的ack包个数。把请求合并后，ack包数量必然减少，确认和重发的成本就会降低。</p>
</li>
</ul>
<h3 id="push还是pull"><a href="#push还是pull" class="headerlink" title="push还是pull"></a>push还是pull</h3><p>上文提到的消息队列，大多是针对push模型的设计。现在市面上有很多经典的也比较成熟的pull模型的消息队列，如Kafka、MetaQ等。这跟JMS中传统的push方式有很大的区别，可谓另辟蹊径。 我们简要分析下push和pull模型各自存在的利弊。</p>
<h4 id="慢消费"><a href="#慢消费" class="headerlink" title="慢消费"></a>慢消费</h4><p>慢消费无疑是push模型最大的致命伤，穿成流水线来看，如果消费者的速度比发送者的速度慢很多，势必造成消息在broker的堆积。假设这些消息都是有用的无法丢弃的，消息就要一直在broker端保存。当然这还不是最致命的，最致命的是broker给consumer推送一堆consumer无法处理的消息，consumer不是reject就是error，然后来回踢皮球。 反观pull模式，consumer可以按需消费，不用担心自己处理不了的消息来骚扰自己，而broker堆积消息也会相对简单，无需记录每一个要发送消息的状态，只需要维护所有消息的队列和偏移量就可以了。所以对于建立索引等慢消费，消息量有限且到来的速度不均匀的情况，pull模式比较合适。</p>
<h3 id="消息延迟与忙等"><a href="#消息延迟与忙等" class="headerlink" title="消息延迟与忙等"></a>消息延迟与忙等</h3><p>这是pull模式最大的短板。由于主动权在消费方，消费方无法准确地决定何时去拉取最新的消息。如果一次pull取到消息了还可以继续去pull，如果没有pull取到则需要等待一段时间重新pull。 但等待多久就很难判定了。你可能会说，我可以有xx动态pull取时间调整算法，但问题的本质在于，有没有消息到来这件事情决定权不在消费方。也许1分钟内连续来了1000条消息，然后半个小时没有新消息产生， 可能你的算法算出下次最有可能到来的时间点是31分钟之后，或者60分钟之后，结果下条消息10分钟后到了，是不是很让人沮丧？ 当然也不是说延迟就没有解决方案了，业界较成熟的做法是从短时间开始（不会对broker有太大负担），然后指数级增长等待。比如开始等5ms，然后10ms，然后20ms，然后40ms……直到有消息到来，然后再回到5ms。 即使这样，依然存在延迟问题：假设40ms到80ms之间的50ms消息到来，消息就延迟了30ms，而且对于半个小时来一次的消息，这些开销就是白白浪费的。 在阿里的RocketMq里，有一种优化的做法-长轮询，来平衡推拉模型各自的缺点。基本思路是:消费者如果尝试拉取失败，不是直接return,而是把连接挂在那里wait,服务端如果有新的消息到来，把连接notify起来，这也是不错的思路。但海量的长连接block对系统的开销还是不容小觑的，还是要合理的评估时间间隔，给wait加一个时间上限比较好~</p>
<h3 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h3><p>如果push模式的消息队列，支持分区，单分区只支持一个消费者消费，并且消费者只有确认一个消息消费后才能push送另外一个消息，还要发送者保证全局顺序唯一，听起来也能做顺序消息，但成本太高了，尤其是必须每个消息消费确认后才能发下一条消息，这对于本身堆积能力和慢消费就是瓶颈的push模式的消息队列，简直是一场灾难。 反观pull模式，如果想做到全局顺序消息，就相对容易很多：</p>
<ol>
<li>producer对应partition，并且单线程。</li>
<li>consumer对应partition，消费确认（或批量确认），继续消费即可。</li>
</ol>
<p>所以对于日志push送这种最好全局有序，但允许出现小误差的场景，pull模式非常合适。如果你不想看到通篇乱套的日志~~ Anyway，需要顺序消息的场景还是比较有限的而且成本太高，请慎重考虑。</p>
<p>本文从为何使用消息队列开始讲起，然后主要介绍了如何从零开始设计一个消息队列，包括RPC、事务、最终一致性、广播、消息确认等关键问题。并对消息队列的push、pull模型做了简要分析，最后从批量和异步角度，分析了消息队列性能优化的思路。 </p>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘计算与云网融合</title>
    <url>/2021/10/07/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%91%E7%BD%91%E8%9E%8D%E5%90%88/</url>
    <content><![CDATA[<h1 id="边缘计算基础概念"><a href="#边缘计算基础概念" class="headerlink" title="边缘计算基础概念"></a>边缘计算基础概念</h1><blockquote>
<p>维基百科的解释</p>
</blockquote>
<p><strong>边缘运算</strong>（英语：Edge computing），又译为<strong>边缘计算</strong>，是一种分布式运算的架构，将应用程序、数据资料与服务的运算，由网络中心节点，移往网络逻辑上的<strong>边缘节点</strong>来处理  。边缘运算将原本完全由中心节点处理大型服务加以分解，切割成更小与更容易管理的部分，分散到边缘节点去处理。边缘节点更接近于用户终端设备，可以加快资料的处理与发送速度，减少延迟。在这种架构下，资料的分析与知识的产生，更接近于数据资料的来源，因此更适合处理大数据。</p>
<h2 id="边缘计算核心：在源头处理数据"><a href="#边缘计算核心：在源头处理数据" class="headerlink" title="边缘计算核心：在源头处理数据"></a>边缘计算核心：在源头处理数据</h2><p>边缘计算是一种分布式计算框架，使企业应用程序更接近物联网设备或本地边缘服务器等数据源。这种在源头上接近数据可以带来强大的业务优势，包括更快的洞察力、更快的响应时间和更好的带宽可用性。</p>
<p><strong><em>Gartner 估计，到 2025 年，75% 的数据将在传统数据中心或云之外处理。</em></strong></p>
<h2 id="为什们选择边缘计算"><a href="#为什们选择边缘计算" class="headerlink" title="为什们选择边缘计算"></a>为什们选择边缘计算</h2><p>物联网设备的爆炸性增长和不断增强的计算能力导致了前所未有的数据量。随着 5G 网络增加连接移动设备的数量，数据量将继续增长。</p>
<p> 过去，云和人工智能的承诺是通过从数据中获得可操作的洞察力来实现自动化和加速创新。但是，由连接设备创建的前所未有的数据规模和复杂性已经超过了网络和基础设施的能力。</p>
<p>将所有设备生成的数据发送到集中式数据中心或云会导致带宽和延迟问题。边缘计算提供了更有效的替代方案；数据在更接近其创建点的位置进行处理和分析。由于数据不会通过网络传输到云或数据中心进行处理，因此显着减少了延迟。边缘计算——以及 5G 网络上的移动边缘计算——能够实现更快、更全面的数据分析，为获得更深入的洞察、更快的响应时间和改进的客户体验创造机会</p>
<p>从联网汽车到工厂车间的智能机器人，我们世界中生成的设备数据量比以往任何时候都多，但这些物联网数据中的大部分都没有被开发或使用。例如，麦肯锡公司的一项研究发现，海上石油钻井平台从 30,000 个传感器生成数据——但目前用于决策的数据不到 1%。²</p>
<p>边缘计算利用不断增长的设备内计算能力，近乎实时地提供深入洞察和预测分析。边缘设备中这种增强的分析能力可以推动创新，以提高质量和增加价值。它还提出了重要的战略问题：在计算容量增加的情况下，如何管理执行这些类型操作的工作负载的部署？如何使用设备中的嵌入式智能来更快速地影响员工、客户和企业的运营流程？为了从所有这些设备中获取最大价值，大量计算必须转移到边缘。</p>
<h2 id="知乎的一篇文章，很全面"><a href="#知乎的一篇文章，很全面" class="headerlink" title="知乎的一篇文章，很全面"></a>知乎的一篇文章，很全面</h2><p><a href="https://zhuanlan.zhihu.com/p/59899560">详情点击链接</a></p>
<h2 id="自己总结的图片一张"><a href="#自己总结的图片一张" class="headerlink" title="自己总结的图片一张"></a>自己总结的图片一张</h2><img data-src="/2021/10/07/%E8%BE%B9%E7%BC%98%E8%AE%A1%E7%AE%97%E4%B8%8E%E4%BA%91%E7%BD%91%E8%9E%8D%E5%90%88/Users\flower\Pictures\微信图片_20211006194229.jpg" style="zoom:50%;">



<h2 id="开发接入云网研究及实践"><a href="#开发接入云网研究及实践" class="headerlink" title="开发接入云网研究及实践"></a>开发接入云网研究及实践</h2><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><ul>
<li>虚拟专网</li>
<li>混合专网</li>
<li>独立专网</li>
</ul>
<h2 id="联想应用举例："><a href="#联想应用举例：" class="headerlink" title="联想应用举例："></a>联想应用举例：</h2><h3 id="5G云网融合-5G医疗边缘云"><a href="#5G云网融合-5G医疗边缘云" class="headerlink" title="5G云网融合-5G医疗边缘云"></a>5G云网融合-5G医疗边缘云</h3><h3 id="IT和CT结合"><a href="#IT和CT结合" class="headerlink" title="IT和CT结合"></a>IT和CT结合</h3><h4 id="网络云化，中心集约，解耦"><a href="#网络云化，中心集约，解耦" class="headerlink" title="网络云化，中心集约，解耦"></a>网络云化，中心集约，解耦</h4><ul>
<li><h2 id="云网一体，多云协同"><a href="#云网一体，多云协同" class="headerlink" title="云网一体，多云协同"></a>云网一体，多云协同</h2></li>
</ul>
]]></content>
      <categories>
        <category>互联网领先概念</category>
      </categories>
      <tags>
        <tag>Intel边缘与云计算网融合专题峰会参会记录与扩展</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/2022/02/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/01/13/%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表中的每个结点不仅包含值，还包含链接到下一个结点的引用字段。通过这种方式，单链表将所有结点按顺序组织起来。习惯于用头节点来代表整个单链表。</p>
<p>下面是一个单链表的例子：</p>
<p> <img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\Desktop\screen-shot-2018-04-12-at-152754.png" alt="screen-shot-2018-04-12-at-152754"></p>
<p>蓝色箭头显示单个链接列表中的结点是如何组合在一起的。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SinglyListNode</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    SinglyListNode next;    <span class="comment">//定义对象，下一个节点</span></span><br><span class="line">    SinglyListNode(<span class="keyword">int</span> x)&#123;val=x;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="单列表的操作"><a href="#单列表的操作" class="headerlink" title="单列表的操作"></a>单列表的操作</h3><p>与数组不同，我们无法在常量时间内访问单链表中的随机元素。 如果我们想要获得第 i 个元素，我们必须从头结点逐个遍历。 我们按索引来访问元素平均要花费 O(N) 时间，其中 N 是链表的长度。</p>
<p>例如，在上面的示例中，头结点是 23。访问第 3 个结点的唯一方法是使用头结点中的“next”字段到达第 2 个结点（结点 6）; 然后使用结点 6 的“next”字段，我们能够访问第 3 个结点。</p>
<p>你可能想知道为什么链表很有用，尽管它在通过索引访问数据时（与数组相比）具有如此糟糕的性能。 在 插入和删除中，链表具有良好的性能。</p>
<h4 id="操作一：添加元素cur在prev之后"><a href="#操作一：添加元素cur在prev之后" class="headerlink" title="操作一：添加元素cur在prev之后"></a>操作一：添加元素cur在prev之后</h4><p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113091359911.png" alt="image-20210113091359911"></p>
<p>与数组对比，插入新元素不需要将插入节点后的所有元素都后移，因此，时间复杂度为O(1),</p>
<p><strong><em>特殊情况</em></strong></p>
<p>在开头添加结点：在列表开头添加新节点时更新头节点head至关重要。</p>
<ol>
<li>初始化一个新结点 <code>cur</code> ；</li>
<li>将新结点链接到我们的原始头结点 <code>head</code>。</li>
<li>将 <code>cur</code> 指定为 <code>head</code> 。</li>
</ol>
<p>在结尾添加节点</p>
<h4 id="操作二：从单链表中删除现有结点cur"><a href="#操作二：从单链表中删除现有结点cur" class="headerlink" title="操作二：从单链表中删除现有结点cur"></a>操作二：从单链表中删除现有结点cur</h4><p>删除操作 - 单链表<br>如果我们想从单链表中删除现有结点 cur，可以分两步完成：</p>
<p>找到 cur 的上一个结点 prev 及其下一个结点 next ；</p>
<p>接下来链接 prev 到 cur 的下一个节点 next 。</p>
<p>在我们的第一步中，我们需要找出 prev 和 next。使用 cur 的参考字段很容易找出 next，但是，我们必须<strong>从头结点遍历链表，以找出 prev</strong>，它的平均时间是 O(N)，其中 N 是链表的长度。因此，删除结点的时间复杂度将是 <u>O(N)</u>。</p>
<p>空间复杂度为 O(1)，因为我们只需要常量空间来存储指针。</p>
<p>示例</p>
<p>让我们尝试把结点 6从上面的单链表中删除。</p>
<ol>
<li><p>从头遍历链表，直到我们找到前一个结点 prev，即结点 23</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092734343.png" alt="image-20210113092734343"></p>
</li>
<li><p>将 prev（结点 23）与 next（结点 15）链接</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092712828.png" alt="image-20210113092712828"></p>
</li>
</ol>
<p>结点 6 现在不在我们的单链表中。</p>
<p><strong>特殊情况</strong></p>
<p>删除第一个结点<br>如果我们想删除第一个结点，策略会有所不同。</p>
<p>正如之前所提到的，我们使用头结点 head 来表示链表。我们的头是下面示例中的黑色结点 23。</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092928077.png" alt="image-20210113092928077"></p>
<p>如果想要删除第一个结点，我们可以简单地将下一个结点分配给 head。也就是说，删除之后我们的头将会是结点 6。</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113092949088.png" alt="image-20210113092949088"></p>
<p>链表从头结点开始，因此结点 23 不再在我们的链表中。</p>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>与单链表的区别在于：双链表除了有数据域和指向其后继的指针外，还有指向其前驱的指针。</p>
<p><strong>所以，根据链接数的不同，可以将链表分为单链表、双链表、多重链表</strong></p>
<h3 id="LC设计链表"><a href="#LC设计链表" class="headerlink" title="LC设计链表"></a>LC设计链表</h3><p>链表时一个包含零个或多个元素的数据结构。每个元素都包含一个值和到另一个元素的链接。根据链接数的不同，可以分为单链表，双链表和多重链表。</p>
<p>单链表是最简单的一种，它提供了在常数时间内的 addAtHead 操作和在线性时间内的 addAtTail 的操作。双链表是最常用的一种，因为它提供了在常数时间内的 addAtHead 和 addAtTail 操作，并且优化的插入和删除。</p>
<p>双链表在 Java 中的实现为 LinkedList，在 Python 中为 list。这些结构都比较常用，有两个要点：</p>
<p>1、<strong>哨兵节点</strong>：<br>哨兵节点在树和链表中被广泛用作<u>伪头、伪尾</u>等，通常不保存任何数据。</p>
<p>我们将使用伪头来简化我们简化插入和删除。在接下来的两种方法中应用此方法。</p>
<p>2、双链表的<u>双向搜索</u>：我们可以从头部或尾部进行搜索。</p>
<p>####在链表类中实现这些功能：</p>
<p>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<h4 id="方式一：单链表实现"><a href="#方式一：单链表实现" class="headerlink" title="方式一：单链表实现"></a>方式一：单链表实现</h4><p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113095508745.png" alt="image-20210113095508745"> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;      <span class="comment">//声明结点</span></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    ListNode head;  <span class="comment">//sentinel node as pseudo-head</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   <span class="comment">//声明链表，用哨兵做伪头，这样确保链表中节点永远不为空</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;</span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size;</span><br><span class="line">  ListNode head;  <span class="comment">// sentinel node as pseudo-head</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="comment">// index steps needed </span></span><br><span class="line">    <span class="comment">// to move from sentinel node to wanted index</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;   <span class="comment">//与删除不同，如果要获取指定索引处的节点，必须前进index+1步</span></span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(<span class="number">0</span>, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    addAtIndex(size, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>)  index = <span class="number">0</span>;</span><br><span class="line">		++size;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be added</span></span><br><span class="line">    ListNode pred = head;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;   <span class="comment">//从头开始找给定索引处的前一个元素pred，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// node to be added</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);    <span class="comment">//新建一个节点</span></span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    toAdd.next = pred.next;  </span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// find predecessor of the node to be deleted</span></span><br><span class="line">    ListNode pred = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;  <span class="comment">//找到的是要删除节点的前一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    pred.next = pred.next.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">作者：LeetCode</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/design-linked-list/solution/she-ji-lian-biao-by-leetcode/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>
<p>#####复杂度分析</p>
<p>时间复杂度：<br>addAtHead： \mathcal{O}(1)O(1)<br>addAtInder，get，deleteAtIndex: \mathcal{O}(k)O(k)，其中 kk 指的是元素的索引。<br>addAtTail：\mathcal{O}(N)O(N)，其中 NN 指的是链表的元素个数。<br>空间复杂度：所有的操作都是 O(1)O(1)。</p>
<p>####方式二：双链表实现</p>
<p>双链表比单链表快得多，测试用例花费的时间比单链表快了两倍。但是它更加复杂，它包含了 <code>size</code>，记录链表元素个数，和伪头伪尾。</p>
<p><img data-src="/2021/01/13/%E9%93%BE%E8%A1%A8/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210113105525613.png" alt="image-20210113105525613"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  ListNode next;   <span class="comment">//后继结点</span></span><br><span class="line">  ListNode prev;   <span class="comment">//前驱节点</span></span><br><span class="line">  ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLinkedList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> size=<span class="number">0</span>;</span><br><span class="line">  <span class="comment">// sentinel nodes as pseudo-head and pseudo-tail  --伪元素充当头结点和尾节点</span></span><br><span class="line">  ListNode head, tail;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    tail = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the value of the index-th node in the linked list. If the index is invalid, return -1. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if index is invalid</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// choose the fastest way: to move from the head</span></span><br><span class="line">    <span class="comment">// or to move from the tail    ----从后或者从前遍历，选择一个比较快速的遍历方向</span></span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    <span class="keyword">if</span> (index + <span class="number">1</span> &lt; size - index)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index + <span class="number">1</span>; ++i) curr = curr.next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      curr = tail;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) curr = curr.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curr.val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtHead</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode pred = head, succ = head.next;</span><br><span class="line"></span><br><span class="line">    ++size;      <span class="comment">//记得把链表长度更新一下</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Append a node of value val to the last element of the linked list. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtTail</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    ListNode succ = tail, pred = tail.prev;</span><br><span class="line"></span><br><span class="line">    ++size;</span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If index is greater than the length, </span></span><br><span class="line">    <span class="comment">// the node will not be inserted.</span></span><br><span class="line">    <span class="keyword">if</span> (index &gt; size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [so weird] If index is negative, </span></span><br><span class="line">    <span class="comment">// the node will be inserted at the head of the list.</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be added   找到节点的前驱和后继</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) </span><br><span class="line">          pred = pred.next;</span><br><span class="line">      succ = pred.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//先找到待插入元素的前驱与后继，然后在进行节点指向的变更</span></span><br><span class="line">    <span class="comment">// insertion itself</span></span><br><span class="line">    ++size;        <span class="comment">//注意长度的更新</span></span><br><span class="line">    ListNode toAdd = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">    toAdd.prev = pred;</span><br><span class="line">    toAdd.next = succ;</span><br><span class="line">    pred.next = toAdd;</span><br><span class="line">    succ.prev = toAdd;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Delete the index-th node in the linked list, if the index is valid. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// if the index is invalid, do nothing</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find predecessor and successor of the node to be deleted</span></span><br><span class="line">    ListNode pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; size - index) &#123;</span><br><span class="line">      pred = head;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; ++i) pred = pred.next;</span><br><span class="line">      succ = pred.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      succ = tail;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index - <span class="number">1</span>; ++i) succ = succ.prev;</span><br><span class="line">      pred = succ.prev.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete pred.next </span></span><br><span class="line">    --size;</span><br><span class="line">    pred.next = succ;</span><br><span class="line">    succ.prev = pred;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>伪头和伪尾总是存在，MyLinkedList 中所有节点都包含：值 + 指向前一个节点的指针 + 指向后一个节点的指针。</p>
<p>#####复杂度分析</p>
<p>时间复杂度：<br>addAtHead，addAtTail： \mathcal{O}(1)O(1)<br>get，addAtIndex，delete：\mathcal{O}(\min(k, N - k))O(min(k,N−k))，其中 kk 指的是元素的索引。<br>空间复杂度：所有的操作都是 \mathcal{O}(1)O(1)。</p>
<p> <strong>说明</strong>:不论是单链表还是双链表，在进行遍历时，如果想要通过index来get某一结点元素，for循环中的终止条件是<strong>i&lt;index+1</strong></p>
<p>如果是删除或者添加，for循环中的终止条件是**i&lt;index</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>链表刷题总结（easy篇）</title>
    <url>/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="链表知识刷题总结（easy篇）"><a href="#链表知识刷题总结（easy篇）" class="headerlink" title="链表知识刷题总结（easy篇）"></a>链表知识刷题总结（easy篇）</h1><p>###1.返回链表的倒数第k个结点</p>
<p>###题目描述：</p>
<p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p>
<p>注意：本题相对原题稍作改动</p>
<p>示例：</p>
<p>输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k = 2<br>输出： 4<br>说明：</p>
<p>给定的 k 保证是有效的。</p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><h4 id="题解一-双指针"><a href="#题解一-双指针" class="headerlink" title="题解一:双指针"></a>题解一:双指针</h4><p> 这题要求链表的倒数第k个节点，最简单的方式就是使用两个指针，第一个指针先移动k步，然后第二个指针再从头开始，这个时候这两个指针同时移动，当第一个指针到链表的末尾的时候，返回第二个指针即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthToLast</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode first = head;</span><br><span class="line">    	ListNode second = head;</span><br><span class="line">    </span><br><span class="line">    	<span class="keyword">while</span>(k-- &gt;<span class="number">0</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first =  first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">return</span> second.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>####题解二：使用栈求解(一看到倒数某某元素，要先想到栈)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthTolast</span><span class="params">(ListNode head , <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//链表结点压栈处理</span></span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//出栈串成新的链表</span></span><br><span class="line">        ListNode firstnode = stack.pop();</span><br><span class="line">        <span class="keyword">while</span>(--k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            ListNode temp = stack.pop();</span><br><span class="line">            temp.next = firstNode;     <span class="comment">//这一步是不必要的，除非要求返回最后一个到倒数第k个结点链表，需要从新连接构建</span></span><br><span class="line">            firstNode = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> firstnode.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="2-删除中间结点"><a href="#2-删除中间结点" class="headerlink" title="2.删除中间结点"></a>2.删除中间结点</h3><h4 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h4><h4 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="3-合并两个有序列表"><a href="#3-合并两个有序列表" class="headerlink" title="3.合并两个有序列表"></a>3.合并两个有序列表</h3><h4 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a>题目描述：</h4><p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p>
<p>示例 1：</p>
<p><img data-src="/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210120112941925.png" alt="image-20210120112941925"></p>
<p>输入：l1 = [1,2,4], l2 = [1,3,4]<br>输出：[1,1,2,3,4,4]<br>示例 2：</p>
<p>输入：l1 = [], l2 = []<br>输出：[]<br>示例 3：</p>
<p>输入：l1 = [], l2 = [0]<br>输出：[0]</p>
<h4 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h4><h5 id="题解一：递归"><a href="#题解一：递归" class="headerlink" title="题解一：递归"></a>题解一：递归</h5><p>思路</p>
<p>我们可以如下递归地定义两个链表里的 merge 操作（忽略边界情况，比如空链表等）：<br>    <img data-src="/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210120113648210.png" alt="image-20210120113648210"></p>
<p>也就是说，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</p>
<p>算法</p>
<p>我们直接将以上递归过程建模，同时需要考虑边界情况。</p>
<p>如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><h3 id="4-回文链表"><a href="#4-回文链表" class="headerlink" title="4.回文链表"></a>4.回文链表</h3><p>####题目描述</p>
<h4 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h4><p>#####题解一：将链表中的值复制到数组中在用双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        List&lt;Interger&gt; vals = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表中的值赋值到数组中</span></span><br><span class="line">        ListNode currentNode = head;</span><br><span class="line">        <span class="keyword">while</span>(currentNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            vals.add(currentNode.val);        <span class="comment">//复制的是currentNode的值，而不是其本身</span></span><br><span class="line">            currentNode = currentNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//使用双指针判断回文</span></span><br><span class="line">        <span class="keyword">int</span> front=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> back = vals.size()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(front&lt;back)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vals.get(front).equals(vals.get(back)))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            front++;</span><br><span class="line">            back--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h5><p><img data-src="/2021/01/20/%E9%93%BE%E8%A1%A8%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210120205633023.png" alt="image-20210120205633023"></p>
<h5 id="题解二：递归"><a href="#题解二：递归" class="headerlink" title="题解二：递归"></a>题解二：递归</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>








]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云ECS部署服务器</title>
    <url>/2021/01/22/%E9%98%BF%E9%87%8C%E4%BA%91ECS%E9%83%A8%E7%BD%B2%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h2 id="阿里云ECS部署Tomcat、Nginx服务器"><a href="#阿里云ECS部署Tomcat、Nginx服务器" class="headerlink" title="阿里云ECS部署Tomcat、Nginx服务器"></a>阿里云ECS部署Tomcat、Nginx服务器</h2><h3 id="Nginx服务器"><a href="#Nginx服务器" class="headerlink" title="Nginx服务器"></a>Nginx服务器</h3><p>####一、简介</p>
<p>Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。它最常的用途是提供反向代理服务。</p>
<h4 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h4><h2 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h2><p>Nginx的安装依赖于以下三个包，意思就是在安装Nginx之前首先必须安装一下的三个包，注意安装顺序如下：</p>
<p>　　1 SSL功能需要openssl库，直接通过yum安装: #yum install openssl</p>
<p>　　2 gzip模块需要zlib库，直接通过yum安装: #yum install zlib</p>
<p>　　3 rewrite模块需要pcre库，直接通过yum安装: #yum install pcre</p>
<h2 id="2、安装Nginx依赖项和Nginx"><a href="#2、安装Nginx依赖项和Nginx" class="headerlink" title="2、安装Nginx依赖项和Nginx"></a>2、安装Nginx依赖项和Nginx</h2><p>1 、使用yum安装nginx需要包括Nginx的库，安装Nginx的库</p>
<p>rpm -Uvh <a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm">http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm</a></p>
<p>2 、使用下面命令安装nginx</p>
<p> yum install nginx</p>
<p>3、 启动Nginx</p>
<p>service nginx start（Centos 6.0）,如果是Centos7.0以上，使用systemctl start nginx启动。</p>
<p>4、直接浏览器访问localhost就会出现Nginx的欢迎界面表示你安装成功了，否则就是安装失败了</p>
<p>　　默认80端口加入防火墙访问白名单中：firewall-cmd –permanent –zone=public –add-port=80/tcp</p>
<p>　　使用firewall-cmd –reload命令使其生效</p>
<p>5、配置Nginx</p>
<p>CentOS安装Nginx后，安装在了 /etc/nginx/目录下，你可以打开/etc/nginx/conf.d/default/conf查看里面的配置，包括监听端口，域名和nginx访问的根目录</p>
<p><strong>如果出现nginx启动之后，通过自己服务器的公网IP地址无法访问，是服务器端口没有开放访问权限的缘故，可以参考博客：<a href="https://blog.csdn.net/inite/article/details/73658214">https://blog.csdn.net/inite/article/details/73658214</a></strong></p>
<p>####三、配置</p>
<p>以上安装方法nginx的配置文件位于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<p>Nginx配置文件常见结构的从外到内依次是「http」「server」「location」等等，缺省的继承关系是从外到内，也就是说内层块会自动获取外层块的值作为缺省值。</p>
<h5 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h5><p>接收请求的服务器需要将不同的请求按规则转发到不同的后端服务器上，在 nginx 中我们可以通过构建虚拟主机（server）的概念来将这些不同的服务配置隔离。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  localhost;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如我们笔戈玩下的两个子项目 passport 和 wan 就可以通过在 nginx 的配置文件中配置两个 server，servername 分别为 passport.bigertech.com 和 wan.bigertech.com。这样的话不同的 url 请求就会对应到 nginx 相应的设置，转发到不同的后端服务器上。</p>
<p>这里的 listen 指监听端口，server_name 用来指定IP或域名，多个域名对应统一规则可以空格分开，index 用于设定访问的默认首页地址，root 指令用于指定虚拟主机的网页跟目录，这个地方可以是相对地址也可以是绝对地址。</p>
<p>通常情况下我们可以在 nginx.conf 中配置多个server，对不同的请求进行设置。就像这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  host1;</span><br><span class="line">root   html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">listen       80;</span><br><span class="line">server_name  host2;</span><br><span class="line">root   &#x2F;data&#x2F;www&#x2F;html;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是当 server 超过2个时，建议将不同对虚拟主机的配置放在另一个文件中，然后通过在主配置文件 nginx.conf 加上 include 指令包含进来。更便于管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include vhosts&#x2F;*.conf;</span><br></pre></td></tr></table></figure>
<p>就可以把vhosts的文件都包含进去啦。</p>
<p>#####Localtion</p>
<p>每个 url 请求都会对应的一个服务，nginx 进行处理转发或者是本地的一个文件路径，或者是其他服务器的一个服务路径。而这个路径的匹配是通过 location 来进行的。我们可以将 server 当做对应一个域名进行的配置，而 location 是在一个域名下对更精细的路径进行配置。</p>
<p>以上面的例子，可以将root和index指令放到一个location中，那么只有在匹配到这个location时才会访问root后的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;data&#x2F;www&#x2F;host2;</span><br><span class="line">      index  index.html index.htm;</span><br><span class="line">  &#125;</span><br><span class="line">location 匹配规则</span><br><span class="line"></span><br><span class="line">~      波浪线表示执行一个正则匹配，区分大小写</span><br><span class="line">~*    表示执行一个正则匹配，不区分大小写</span><br><span class="line">^~    ^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</span><br><span class="line">&#x3D;      进行普通字符精确匹配</span><br><span class="line">匹配例子：</span><br><span class="line"></span><br><span class="line">  location  &#x3D; &#x2F; &#123;</span><br><span class="line"># 只匹配&quot;&#x2F;&quot;.</span><br><span class="line">[ configuration A ] </span><br><span class="line">  &#125;</span><br><span class="line">location  &#x2F; &#123;</span><br><span class="line"># 匹配任何请求，因为所有请求都是以&quot;&#x2F;&quot;开始</span><br><span class="line"># 但是更长字符匹配或者正则表达式匹配会优先匹配</span><br><span class="line">[ configuration B ] </span><br><span class="line">&#125;</span><br><span class="line">location ^~ &#x2F;images&#x2F; &#123;</span><br><span class="line"> #匹配任何以 &#x2F;images&#x2F; 开始的请求，并停止匹配 其它location</span><br><span class="line">[ configuration C ] </span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line"># 匹配以 gif, jpg, or jpeg结尾的请求. </span><br><span class="line"># 但是所有 &#x2F;images&#x2F; 目录的请求将由 [Configuration C]处理.   </span><br><span class="line">[ configuration D ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">请求:</span><br><span class="line">&#x2F; -&gt; 符合configuration A</span><br><span class="line">&#x2F;documents&#x2F;document.html -&gt; 符合configuration B</span><br><span class="line">&#x2F;images&#x2F;1.gif -&gt; 符合configuration C</span><br><span class="line">&#x2F;documents&#x2F;1.jpg -&gt;符合 configuration D</span><br></pre></td></tr></table></figure>
<p>#####静态文件映射</p>
<p>访问文件的配置主要有 root 和 aliasp’s 两个指令。这两个指令的区别容易弄混：</p>
<p>alias<br>alias后跟的指定目录是准确的，并且末尾必须加 /。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;c&#x2F; &#123;</span><br><span class="line">    alias &#x2F;a&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果访问站点<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://location/c">http://location/c</a>访问的就是/a/目录下的站点信息。</p>
<p>#####root</p>
<p>root后跟的指定目录是上级目录，并且该上级目录下要含有和location后指定名称的同名目录才行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;c&#x2F; &#123;</span><br><span class="line">    root &#x2F;a&#x2F;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时访问站点<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://location/c">http://location/c</a>访问的就是/a/c目录下的站点信息。</p>
<p>如果你需要将这个目录展开，在这个location的末尾加上「autoindex on; 」就可以了</p>
<p>#####转发</p>
<p>配置起来很简单比如我要将所有的请求到转移到真正提供服务的一台机器的 8001 端口，只要这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass 172.16.1.1:8001;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样访问host时，就都被转发到 172.16.1.1的8001端口去了。</p>
<p>#####负载均衡</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upstream myserver; &#123;</span><br><span class="line">ip_hash;    </span><br><span class="line">server 172.16.1.1:8001;</span><br><span class="line">server 172.16.1.2:8002;</span><br><span class="line">server 172.16.1.3;</span><br><span class="line">server 172.16.1.4;</span><br><span class="line">&#125;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">proxy_pass http:&#x2F;&#x2F;myserver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 upstream 中指定了一组机器，并将这个组命名为 myserver，这样在 proxypass 中只要将请求转移到 myserver 这个 upstream 中我们就实现了在四台机器的反向代理加负载均衡。其中的 ip_hash 指明了我们均衡的方式是按照用户的 ip 地址进行分配。另外还有轮询、指定权重轮询、fair、url_hash几种调度算法。</p>
<p>###Tomcat服务器</p>
<h4 id="一、下载Tomcat"><a href="#一、下载Tomcat" class="headerlink" title="一、下载Tomcat"></a>一、下载Tomcat</h4>]]></content>
      <categories>
        <category>阿里云ECS</category>
      </categories>
      <tags>
        <tag>阿里云ECS部署</tag>
      </tags>
  </entry>
  <entry>
    <title>CDN</title>
    <url>/2021/03/14/CDN/</url>
    <content><![CDATA[<h2 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h2><p><code>CDN（内容分发网络）</code>全称是 <code>Content Delivery Network</code>，建立并覆盖在承载网之上、由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以 <code>WEB Server</code> 为中心的数据传输模式。</p>
<p>作用是将源内容发布到边缘节点，配合精准的<strong>调度系统</strong>；将用户的请求分配至最适合他的节点，使用户可以以最快的速度取得他所需的内容，有效解决Internet网络拥塞状况，提高用户访问的响应速度。</p>
<h3 id="CDN的基本工作过程"><a href="#CDN的基本工作过程" class="headerlink" title="CDN的基本工作过程"></a>CDN的基本工作过程</h3><p>用户通过浏览器等方式访问网站的过程如图所示：</p>
<img data-src="/2021/03/14/CDN/01.png" class>

<ol>
<li>用户在自己的浏览器中输入要访问的网站域名。</li>
<li>浏览器向 <strong>本地DNS服务器</strong> 请求对该域名的解析。</li>
<li>本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。</li>
<li>本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。</li>
<li>浏览器得到域名解析结果，就是该域名相应的服务设备的 <strong>IP地址</strong> 。</li>
<li>浏览器向服务器请求内容。</li>
<li>服务器将用户请求内容传送给浏览器。</li>
</ol>
<p>在网站和用户之间加入 CDN 以后，用户不会有任何与原来不同的感觉。最简单的 CDN 网络有一个 DNS 服务器和几台缓存服务器就可以运行了。一个典型的 CDN 用户访问<strong>调度流程</strong>如图所示:</p>
<img data-src="/2021/03/14/CDN/02.png" class>

<ol>
<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS 系统会最终将域名的解析权交给 <a href="https://en.wikipedia.org/wiki/CNAME_record">CNAME</a> 指向的 <strong>CDN 专用 DNS 服务器</strong>。</li>
<li>CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。</li>
<li>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</li>
<li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li>
<li>基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址：<ul>
<li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li>
<li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li>
<li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li>
</ul>
</li>
<li>全局负载均衡设备把<strong>服务器的 IP 地址</strong>返回给用户。</li>
<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>
</ol>
<p><strong>DNS 服务器根据用户 IP 地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。</strong>使用 CDN 服务的网站，只需将其域名解析权交给 CDN 的全局负载均衡（GSLB）设备，将需要分发的内容注入 CDN，就可以实现内容加速了。</p>
<p>使用CDN后的<strong>http请求处理流程</strong>如下图，其中左边为<strong>DNS解析过程</strong>，右边为<strong>内容访问过程</strong>：</p>
<img data-src="/2021/03/14/CDN/03.png" class>

<h3 id="CDN的功能架构"><a href="#CDN的功能架构" class="headerlink" title="CDN的功能架构"></a>CDN的功能架构</h3><p>CDN基于这样的原理：</p>
<ol>
<li>挑选最优设备为用户提供服务；</li>
<li>如果某个内容被很多用户所需要，它就被缓存到距离用户最近的节点中。</li>
</ol>
<p>CDN 公司在整个互联网上部署数以百计的CDN服务器（Cache），这些服务器通常在运营商的 <code>IDC (互联网数据中心Internet Data Center）</code>中，尽量靠近接入网络和用户。CDN在Cache中复制内容，当内容的提供者更新内容时，CDN 向Cache重新分发这些被刷新的内容。CDN提供一种机制，当用户请求内容时，该内容能够由以最快速度交付的Cache 来向用户提供，这个挑选”最优”的过程就叫做<strong>负载均衡</strong>。被选中的最优 Cache 可能最靠近用户，或者有一条与用户之间条件最好的路径。</p>
<p>从功能上划分，典型的 CDN 系统架构由<code>分发服务系统</code>、<code>负载均衡系统</code>和<code>运营管理系统</code>三大部分组成，如图所示：</p>
<img data-src="/2021/03/14/CDN/04.png" class>

<h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><p>该系统的主要作用是实现将内容从内容源中心向边缘的推送和存储，承担实际的内容数据流的全网分发工作和面向最终用户的数据请求服务。分发服务系统最基本的工作单元就是许许多多的 Cache设备（缓存服务器），Cache 负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 Cache 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。</p>
<p>一般来说，根据承载内容类型和服务种类的不同，分发服务系统会分为多个子服务系统，如<code>网页加速子系统</code>、<code>流媒体加速子系统</code>、<code>应用加速子系统</code>等。每个子服务系统都是一个分布式服务集群，由一群功能近似的、在地理位置上分布部署的 Cache 或 Cache 集群组成，彼此间相互独立。每个子服务系统设备集群的数量根据业务发展和市场需要的不同，少则几十台，多则可达上万台，对外形成一个整体，共同承担分发服务工作。<strong>Cache 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。</strong></p>
<p>分发服务系统在承担内容的更新、同步和响应用户需求的同时，还需要向上层的调度控制系统提供每个Cache设备的<strong>健康状况信息、响应情况</strong>，有时还需要提供内容分布信息，以便调度控制系统根据设定的策略决定由哪个Cache（组）来响应用户的请求最优。</p>
<h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><p>负载均衡系统是一个 CDN 系统的神经中枢，主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。大多数 CDN 系统的负载均衡系统是分级实现的，这里以最基本的两级调度体系进行简要说明。一般而言，两级调度体系分为<code>全局负载均衡（GSLB）</code>和<code>本地负载均衡（SLB）</code>。</p>
<p>其中，全局负载均衡（GSLB）主要根据 <strong>用户就近性原则</strong>，通过对每个服务节点进行”最优”判断，确定向用户提供服务的 Cache 的物理位置。最通用的 GSLB 实现方法是基于<code>DNS解析</code>的方式实现，也有一些系统采用了<code>应用层重定向</code>等方式来解决。本地负载均衡（SLB）主要负责节点内部的设备负载均衡，当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各 Cache 设备的实际能力或内容分布等因素对用户进行重定向，常用的本地负载均衡方法有<code>基于4层调度</code>、<code>基于7层调度</code>、<code>链路负载调度</code>等。</p>
<h4 id="运营管理系统"><a href="#运营管理系统" class="headerlink" title="运营管理系统"></a>运营管理系统</h4><p>CDN的运营管理系统与一般的电信运营管理系统类似，分为运营管理和网络管理两个子系统。</p>
<p>运营管理子系统是CDN系统的业务管理功能实体，负责处理业务层面的与外界系统交互所必需的一些收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>
<p>网络管理子系统实现对CDN系统的<strong>网络设备管理、拓扑管理、链路监控和故障管理</strong>，为管理员提供对全网资源进行集中化管理操作的界面，通常是基于Web方式实现的。</p>
<h3 id="CDN的部署架构"><a href="#CDN的部署架构" class="headerlink" title="CDN的部署架构"></a>CDN的部署架构</h3><p>CDN 系统设计的首要目标是尽量减少用户的访问响应时间，为达到这一目标，CDN 系统应该尽量将用户所需要的内容存放在距离用户最近的位置。也就是说，负责为用户提供内容服务的 Cache 设备应部署在物理上的网络边缘位置，我们称这一层为<code>CDN边缘层</code>。CDN 系统中负责全局性管理和控制的设备组成 <code>中心层</code>，中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</p>
<p>不同CDN系统设计之间存在差异，中心层可能具备用户服务能力，也可能不直接提供服务，只向下级节点提供内容。如果CDN网络规模较大，边缘层设备直接向中心层请求内容或服务会造成中心层设备压力过大，就要考虑在边缘层和中心层之间部署一个<code>区域层</code>，负责一个区域的管理和控制，也保存部分内容副本供边缘层访问。</p>
<p>如图是一个典型的CDN系统三级部署示意图:</p>
<img data-src="/2021/03/14/CDN/05.png" class>

<p>节点是 CDN 系统中最基本的部署单元，一个CDN系统由大量的、地理位置上分散的 POP（point-of-presence）节点组成，为用户提供就近的内容访问服务。</p>
<p>CDN 节点网络主要包含 <code>CDN 骨干点</code>和 <code>POP 点</code>。<code>CDN 骨干点</code>和 <code>CDN POP 点</code>在功能上不同。</p>
<ul>
<li>中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；</li>
<li>边缘节点又被称为<code>POP（point-of-presence）节点</code>，CDN POP点主要作为直接向用户提供服务的节点。</li>
</ul>
<p>但是，从节点构成上来说，无论是CDN骨干点还是CDN POP点，都由Cache设备和本地负载均衡设备构成。</p>
<p>在一个节点中，Cache设备和本地负载均衡设备的连接方式有两种：一种是旁路方式，一种是穿越方式。</p>
<p>如图所示：</p>
<img data-src="/2021/03/14/CDN/06.png" class>

<p>在穿越方式下，<code>SLB（Server Load Balancer，负载均衡</code> 一般由 L4-7 交换机实现，SLB 向外提供可访问的 <code>公网IP地址（VIP</code>，每台Cache仅分配私网IP地址，该台SLB下挂的所有Cache构成一个服务组。所有用户请求和媒体流都经过该SLB设备，再由SLB设备进行向上向下转发。SLB实际上承担了 <code>NAT（Network Address Translation，网络地址转换）</code>功能，向用户屏蔽了Cache设备的IP地址。这种方式是CDN系统中应用较多的方式，优点是具有较高的安全性和可靠性，缺点是L4-7交换机通常较为昂贵。另外，当节点容量大时，L4-7交换机容易形成性能瓶颈。不过近年来，随着 <code>LVS (Linux Virtual Server，即Linux虚拟服务器)</code> 等技术的兴起，SLB设备价格有了大幅下降。</p>
<p>在旁路方式下，有两种 SLB 实现方式：</p>
<ul>
<li>在早期，这种 SLB 一般由软件实现。SLB 和 Cache 设备都具有公共的IP地址，SLB 和 Cache 构成并联关系。用户需要先访问 SLB 设备，然后再以重定向的方式访问特定的 Cache。这种实现方式简单灵活，扩展性好，缺点是安全性较差，而且需要依赖于应用层重定向。</li>
<li>随着技术的发展，L4-7 交换机也可采用旁路部署（负载均衡硬件设备的部署）方式，旁挂在路由交换设备上，数据流量通过三角传输方式进行。</li>
</ul>
<p>在CDN系统中，不仅分发服务系统和调度控制系统是分布式部署的，运营管理系统也是分级分布式部署的，每个节点都是运营管理数据的生成点和采集点，通过日志和网管代理等方式上报数据。<strong>可以说，CDN本身就是一个大型的具有中央控制能力的分布式服务系统。</strong></p>
<h2 id="为什么需要CDN"><a href="#为什么需要CDN" class="headerlink" title="为什么需要CDN"></a>为什么需要CDN</h2><p>当下的互联网应用都包含大量的静态内容，但静态内容以及一些准动态内容又是最耗费带宽的，特别是针对全国甚至全世界的大型网站，如果这些请求都指向主站的服务器的话，不仅是主站服务器受不了，单端口500M左右的带宽也扛不住，所以大多数网站都需要CDN服务。</p>
<p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。</p>
<p>这就是你使用CDN的第一个也是最重要的原因：<strong>为了加速网站的访问。</strong></p>
<p>除了加速网站的访问之外，CDN还有一些作用：</p>
<ul>
<li>为了实现跨运营商、跨地域的全网覆盖</li>
</ul>
<p>互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速。</p>
<ul>
<li>为了保障你的网站安全</li>
</ul>
<p>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</p>
<ul>
<li>为了异地备援</li>
</ul>
<p>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。</p>
<ul>
<li>为了节约成本</li>
</ul>
<p>投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</p>
<ul>
<li>为了让你更专注业务本身</li>
</ul>
<p>CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="网站站点-应用加速"><a href="#网站站点-应用加速" class="headerlink" title="网站站点/应用加速"></a>网站站点/应用加速</h3><p>站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，建议结合 对象存储OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p>
<img data-src="/2021/03/14/CDN/07.png" class>

<h3 id="视音频点播-大文件下载分发加速"><a href="#视音频点播-大文件下载分发加速" class="headerlink" title="视音频点播/大文件下载分发加速"></a>视音频点播/大文件下载分发加速</h3><p>支持各类文件的下载、分发，支持在线点播加速业务，如mp4、flv视频文件或者平均单个文件大小在20M以上，主要的业务场景是视音频点播、大文件下载（如安装包下载）等，建议搭配对象存储OSS使用，可提升回源速度，节约近2/3回源带宽成本。</p>
<img data-src="/2021/03/14/CDN/08.png" class>

<h3 id="视频直播加速"><a href="#视频直播加速" class="headerlink" title="视频直播加速"></a>视频直播加速</h3><p>视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。</p>
<img data-src="/2021/03/14/CDN/09.png" class>

<h3 id="移动应用加速"><a href="#移动应用加速" class="headerlink" title="移动应用加速"></a>移动应用加速</h3><p>移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。</p>
<img data-src="/2021/03/14/CDN/10.png" class>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h3><p>其实，CDN本身就是一种DNS劫持，只不过是良性的。 不同于黑客强制DNS把域名解析到自己的钓鱼IP上，CDN则是让DNS主动配合，把域名解析到临近的服务器上。</p>
<p>劫持通常分为两类：</p>
<ol>
<li>域名劫持，又称<code>DNS劫持</code>，通常是指域名指向到非正常IP（恶意IP），该恶意IP通过反向代理的方式，在能返回网页正常内容的情况，可能插入恶意代码、监听网民访问、劫持敏感信息等操作。通常验证一个域名是否被劫持的方法是PING一个域名，如果发现PING出来的IP不是您的服务器真实IP，则可以确定被劫持了（当然如果使用了知道创宇云安全等安全加速平台，得到的IP为平台IP，并非劫持）</li>
<li>数据劫持，通常由电信运营商中某些员工等勾结犯罪分子，在公网中进行数据支持，插入，此类情况极隐蔽，不会改变用户域名解析IP，而是直接数据流经运营商宽带时在网页中挺入内容，此类情况，建议网页启用<code>HTTPS加密</code>，可以解决这一问题（通信是加密的，运营商无法插入恶意内容）</li>
</ol>
<p>某运营商对新浪首页的广告强制插入：</p>
<img data-src="/2021/03/14/CDN/11.png" class>

<p>如果使用CDN服务时，当源站向CDN返回被劫持的内容时，此时CDN将获取到的并不是正确的网页内容（而是经运营商篡改强制植入广告的页面），此时可能导致该内容在CDN中长时间缓存，发现这种问题，可以清理CDN缓存后，一般即可恢复正常。</p>
<p>遇到劫持现象，可以向工信部投诉：<a href="http://www.chinatcc.gov.cn:8080/cms/shensus/">http://www.chinatcc.gov.cn:80…</a></p>
<p>可参考：</p>
<ul>
<li><a href="http://paper.seebug.org/181/">互联网黑势力之流量劫持</a></li>
<li><a href="http://blog.sae.sina.com.cn/archives/3464">流量劫持是如何产生的？</a></li>
</ul>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的 <code>Cache-control: max-age</code>的字段来设置CDN边缘节点数据缓存时间。</p>
<p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出<code>回源请求（back to the source request）</code>，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p>
<p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
<p>CDN缓存时间会对<code>回源率</code>产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p>
<p>CDN边缘节点对开发者是透明的，相比于浏览器 <code>Ctrl+F5</code> 的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用 <code>刷新缓存</code> 功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。</p>
<p>可参考：</p>
<ul>
<li><a href="https://xuexb.com/post/qing-chu-jing-tai-cdnhuan-cun-de-yan-jiu.html">清除静态cdn缓存的研究</a></li>
</ul>
<h2 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h2><ul>
<li>阿里基于Nginx开发的高性能HTTP服务器，已经开源，详细请了解 <a href="https://link.zhihu.com/?target=http://tengine.taobao.org/">The Tengine Web Server</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker的镜像引擎AUFS</title>
    <url>/2021/04/22/Docker%E7%9A%84%E9%95%9C%E5%83%8F%E5%BC%95%E6%93%8EAUFS/</url>
    <content><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Linux-的-rootfs-和-bootfs"><a href="#Linux-的-rootfs-和-bootfs" class="headerlink" title="Linux 的 rootfs 和 bootfs"></a>Linux 的 rootfs 和 bootfs</h3><p>一个典型的 Linux 系统要能运行的话，它至少需要两个文件系统：</p>
<ul>
<li>boot file system （bootfs）：包含 boot loader 和 kernel。用户不会修改这个文件系统。实际上，在启动（boot）过程完成后，整个内核都会被<code>加载进内存</code>，此时 bootfs 会<code>被卸载掉</code>从而释放出所占用的内存。同时也可以看出，对于同样内核版本的不同的 Linux 发行版的 bootfs 都是<code>一致的</code>。</li>
<li>root file system （rootfs）：包含典型的目录结构，包括 /dev, /proc, /bin, /etc, /lib, /usr, and /tmp 等再加上要运行用户应用所需要的所有配置文件，二进制文件和库文件。这个文件系统在不同的 Linux 发行版中是<code>不同的</code>；</li>
</ul>
<p>其实相同内核的不同的 Linux 发行版就是<code>rootfs 不同，bootfs 相同</code>，如下图所示，<br> </p>
<h3 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h3><p>最开始的思想是，在一些不可写的媒介上，比如 CD/DVD 上面 mount 一个便携式硬盘（可写磁盘），将 CD/DVD 的文件 mount 一份镜像到该磁盘上，已达到变相的对该媒介进行更改；既是在保证原有镜像不变的前提下，copy 一份镜像到磁盘，然后将变更保存在该磁盘上；这就是 AUFS 的核心思想；AUFS 正好被 Docker 拿来构建其<code>多层镜像</code><br>参考，<a href="http://coolshell.cn/articles/17061.html">Docker基础技术：AUFS</a></p>
<h2 id="Docker-的文件系统"><a href="#Docker-的文件系统" class="headerlink" title="Docker 的文件系统"></a>Docker 的文件系统</h2><h3 id="Docker-镜像的-rootfs"><a href="#Docker-镜像的-rootfs" class="headerlink" title="Docker 镜像的 rootfs"></a>Docker 镜像的 rootfs</h3> 

<ul>
<li>所有 Docker 容器都共享主机系统的 bootfs 即 Linux 内核</li>
<li>每个容器有自己的 rootfs，它来自不同的 Linux 发行版的基础镜像，包括 Ubuntu，Debian 和 SUSE 等</li>
<li>所有基于一种基础镜像的容器都共享这种 rootfs</li>
</ul>
<p>下面我们来看下 Docker 中的<code>多层镜像</code>，</p>
<ul>
<li><p>创建一个容器<code>web31</code>，并在该容器中执行<code>python app.py</code>启动一个 webapp 应用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个名为 web31 的容器，会从 docker hub 上下载相关 tranning 镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker create --name web31 training/webapp python app.py</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo docker ps -ls <span class="comment">#查看当前正在运行的 docker 容器</span></span></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">2210b152b308        training/webapp     &quot;python app.py&quot;     58 minutes ago      Created                              web31</span><br></pre></td></tr></table></figure></li>
<li><p>查看<code>traning/webapp</code>镜像由哪些镜像构成</p>
<ul>
<li><p>history 查找指定镜像的构成历史记录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先切换到 root 账户</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> su - root</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">history</span> training/webapp</span></span><br><span class="line">IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT</span><br><span class="line">6fae60ef3446        19 months ago       /bin/sh -c #(nop) CMD [&quot;python&quot; &quot;app.py&quot;]       0 B                 </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c #(nop) EXPOSE 5000/tcp               0 B                 </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c #(nop) WORKDIR /opt/webapp           0 B                 </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c #(nop) ADD dir:9b2a69f6f30d18b02b5   703 B               </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c pip install -qr /tmp/requirements.   4.363 MB            </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c #(nop) ADD file:c59059439864153904   41 B                </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c DEBIAN_FRONTEND=noninteractive apt   135.3 MB            </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c apt-get update                       20.8 MB             </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c #(nop) MAINTAINER Docker Education   0 B                 </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c #(nop) CMD [&quot;/bin/bash&quot;]             0 B                 </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c sed -i &#x27;s/^#\s*\(deb.*universe\)$/   1.895 kB            </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c echo &#x27;#!/bin/sh&#x27; &gt; /usr/sbin/polic   194.5 kB            </span><br><span class="line">&lt;missing&gt;           19 months ago       /bin/sh -c #(nop) ADD file:f4d7b4b3402b5c53f2   188.1 MB</span><br></pre></td></tr></table></figure></li>
<li><p><code>/var/lib/docker/aufs/diff/</code> 镜像存放的位置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# ls -lt</span><br><span class="line">drwxr-xr-x  4 root root 4096 Dec 19 16:25 5420c2ad6952b5597042f7e3ca75e61333e8bda52eb4b9b0a197c4e4c5547c9e</span><br><span class="line">drwxr-xr-x  6 root root 4096 Dec 19 16:25 5420c2ad6952b5597042f7e3ca75e61333e8bda52eb4b9b0a197c4e4c5547c9e-init</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:25 828a1c91a6fb1928559b7b9813c0917affd84fcfa7a4e79476d20623b2c29c2d</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:25 8d8fd100b49edd233212e17c64c8b5061c2b79eb7f7f2fd5fae36c9bf59a502f</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:25 9b79d3f46e7826defa1c283d8282f3169c876bde8b6084cdbe60672acacb9274</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:25 864df82537caf88937c58efbf158f9185ebb872cfb54b15d8888f33561ddaa56</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:25 a3c07d88c61c220d3cc2e2b317b317dec0be11fd629eab7bd3def680a25686cb</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:25 e31f34199774f4446ddde561a3e1a3dbbc254e483f1bd7193571b93f776becc4</span><br><span class="line">drwxr-xr-x  6 root root 4096 Dec 19 16:25 1640c122bc62e1fa893cdeae766952951a934864dacbef3e87d2d9eae68c78d1</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:24 258cfd490a2345067156a2f43d9425e7d12907ce3df64072e37a17ab18b55248</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:24 67614ba4f62bb6f949acff511a18447a620d5b0a2c4c293bdeb7cd9e97a6cdbc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:24 654940ca942ba450e2c5dd38e10bc462333a0307b8531e3193b9f9cbcb119d16</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:24 37edd74902c396df578b8fcfd233457fe27efd3e0f871e677ada43a92f0bad79</span><br><span class="line">drwxr-xr-x  6 root root 4096 Dec 19 16:24 9c0b2e0c1996496f8031c7bf148940e55b34bf7efa067725453430c8db3a27ea</span><br><span class="line">drwxr-xr-x 21 root root 4096 Dec 19 16:24 5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949</span><br></pre></td></tr></table></figure>
<p>这里，或许会有疑问，<code>training/webapp</code> 不是总共只有 13 层镜像吗？这里怎么显示有 15 层？那是因为容器<code>web31</code>本身包含两层（一层只读、一层可读写镜像），后续会详细描述。</p>
</li>
<li><p>定位<code>training/webapp</code>的基础镜像的目录位置<br>由于基础镜像中的 bin 目录会被直接使用，所以，我们可以试着查找 bin 目录中的一个文件来定位基础镜像的目录位置；<br>由此可知，目录<code>5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949</code>是基础镜像的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# find -iname mountpoint</span><br><span class="line">./5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949/bin/mountpoint</span><br></pre></td></tr></table></figure></li>
<li><p>查看基础镜像内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# ls -l 5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949</span><br><span class="line">total 76</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 27  2015 bin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 boot</span><br><span class="line">drwxr-xr-x  3 root root 4096 Apr 27  2015 dev</span><br><span class="line">drwxr-xr-x 61 root root 4096 Apr 27  2015 etc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 home</span><br><span class="line">drwxr-xr-x 12 root root 4096 Apr 27  2015 lib</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 27  2015 lib64</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 27  2015 media</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 mnt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 27  2015 opt</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 11  2014 proc</span><br><span class="line">drwx------  2 root root 4096 Apr 27  2015 root</span><br><span class="line">drwxr-xr-x  7 root root 4096 Apr 27  2015 run</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 27  2015 sbin</span><br><span class="line">drwxr-xr-x  2 root root 4096 Apr 27  2015 srv</span><br><span class="line">drwxr-xr-x  2 root root 4096 Mar 13  2014 sys</span><br><span class="line">drwxrwxrwt  2 root root 4096 Apr 27  2015 tmp</span><br><span class="line">drwxr-xr-x 10 root root 4096 Apr 27  2015 usr</span><br><span class="line">drwxr-xr-x 11 root root 4096 Apr 27  2015 var</span><br></pre></td></tr></table></figure>
<p>可见，基础镜像目录中包含了当前虚拟机操作系统所必须的所有<code>rootfs</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="Docker-的-AUFS-文件系统"><a href="#Docker-的-AUFS-文件系统" class="headerlink" title="Docker 的 AUFS 文件系统"></a>Docker 的 AUFS 文件系统</h3><p>关于 Docker的分层镜像，除了 aufs，docker 还支持 btrfs, devicemapper 和 vfs，你可以使用 -s 或 –storage-driver= 选项来指定相关的镜像存储方式；Ubuntu 默认使用的是 AUFS.</p>
<ul>
<li><p><code>docker info</code>查看所使用的文件驱动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# docker info</span><br><span class="line">Containers: 1</span><br><span class="line"> Running: 0</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 1</span><br><span class="line">Images: 1</span><br><span class="line">Server Version: 1.12.1</span><br><span class="line">Storage Driver: aufs</span><br><span class="line"> Root Dir: /var/lib/docker/aufs</span><br><span class="line"> Backing Filesystem: extfs</span><br><span class="line"> Dirs: 15</span><br><span class="line"> Dirperm1 Supported: true</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br></pre></td></tr></table></figure></li>
<li><p>从<code>training/webapp</code>镜像的角度，总共有 13 层镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker images</span></span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">training/webapp     latest              6fae60ef3446        19 months ago       348.8 MB</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect 6fae60ef3446</span></span><br><span class="line">        &quot;RootFS&quot;: &#123;</span><br><span class="line">            &quot;Type&quot;: &quot;layers&quot;,</span><br><span class="line">            &quot;Layers&quot;: [</span><br><span class="line">                &quot;sha256:1154ba695078d29ea6c4e1adb55c463959cd77509adf09710e2315827d66271a&quot;,</span><br><span class="line">                &quot;sha256:528c8710fd95f61d40b8bb8a549fa8dfa737d9b9c7c7b2ae55f745c972dddacd&quot;,</span><br><span class="line">                &quot;sha256:37ee47034d9b78f10f0c5ce3a25e6b6e58997fcadaf5f896c603a10c5f35fb31&quot;,</span><br><span class="line">                &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</span><br><span class="line">                &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</span><br><span class="line">                &quot;sha256:b75c0703b86b8ccbdc1f1b28b4982774768861ac250f83bdb940b1e90291f302&quot;,</span><br><span class="line">                &quot;sha256:5c121779bb29172c628a21087ea8ced766959da2f223c8b6bd4ffe943ace43d8&quot;,</span><br><span class="line">                &quot;sha256:3ee91c5cb95b01496b4afdc721ba7fd3c22e0e5e2f3e9e70d3f8579b5082d4f3&quot;,</span><br><span class="line">                &quot;sha256:6bbb1d0f845289217e20b66697fa7d651394d89983b0f5a89b88f037194476fe&quot;,</span><br><span class="line">                &quot;sha256:b44b0832d4c6bf33122ce3aa896b133df88275e6d20663a9bf2d941f764ac1fd&quot;,</span><br><span class="line">                &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</span><br><span class="line">                &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;,</span><br><span class="line">                &quot;sha256:5f70bf18a086007016e948b04aed3b82103a36bea41755b6cddfaf10ace3c6ef&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>可见<code>training/webapp</code>镜像总共由 13 层只读层镜像构成，这个和 <code>$ docker history training/webapp</code> 输出的结果是吻合</p>
</li>
<li><p>那么从当前容器<code>web31</code>的角度，AUFS 的结构情况是怎样的呢？</p>
<ul>
<li><p>查看宿主机 AUFS 的文件结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# ls -lt</span><br><span class="line">total 60</span><br><span class="line">drwxr-xr-x  4 root root 4096 Dec 19 16:25 5420c2ad6952b5597042f7e3ca75e61333e8bda52eb4b9b0a197c4e4c5547c9e</span><br><span class="line">drwxr-xr-x  6 root root 4096 Dec 19 16:25 5420c2ad6952b5597042f7e3ca75e61333e8bda52eb4b9b0a197c4e4c5547c9e-init</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:25 828a1c91a6fb1928559b7b9813c0917affd84fcfa7a4e79476d20623b2c29c2d</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:25 8d8fd100b49edd233212e17c64c8b5061c2b79eb7f7f2fd5fae36c9bf59a502f</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:25 9b79d3f46e7826defa1c283d8282f3169c876bde8b6084cdbe60672acacb9274</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:25 864df82537caf88937c58efbf158f9185ebb872cfb54b15d8888f33561ddaa56</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:25 a3c07d88c61c220d3cc2e2b317b317dec0be11fd629eab7bd3def680a25686cb</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:25 e31f34199774f4446ddde561a3e1a3dbbc254e483f1bd7193571b93f776becc4</span><br><span class="line">drwxr-xr-x  6 root root 4096 Dec 19 16:25 1640c122bc62e1fa893cdeae766952951a934864dacbef3e87d2d9eae68c78d1</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:24 258cfd490a2345067156a2f43d9425e7d12907ce3df64072e37a17ab18b55248</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:24 67614ba4f62bb6f949acff511a18447a620d5b0a2c4c293bdeb7cd9e97a6cdbc</span><br><span class="line">drwxr-xr-x  2 root root 4096 Dec 19 16:24 654940ca942ba450e2c5dd38e10bc462333a0307b8531e3193b9f9cbcb119d16</span><br><span class="line">drwxr-xr-x  3 root root 4096 Dec 19 16:24 37edd74902c396df578b8fcfd233457fe27efd3e0f871e677ada43a92f0bad79</span><br><span class="line">drwxr-xr-x  6 root root 4096 Dec 19 16:24 9c0b2e0c1996496f8031c7bf148940e55b34bf7efa067725453430c8db3a27ea</span><br><span class="line">drwxr-xr-x 21 root root 4096 Dec 19 16:24 5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949</span><br></pre></td></tr></table></figure>
<p>可以看到，容器需要使用的镜像总共有 15 层，当前容器使用的镜像比<code>training/webapp</code>的初始镜像多了两层，那么这 15 层镜像(目录)在当前容器中是如何对应的呢？</p>
</li>
<li><p>查看 Docker 容器中针对 AUFS 文件系统的使用情况<br>进入 docker 的命令行，在 /sys/fs/aufs/si_<CONTAINERID> 中查看各级镜像权限对应情况；</CONTAINERID></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu: docker run -it training/webapp /bin/bash</span><br><span class="line">root@762be790cc1f:/opt/webapp# cd /sys/fs/aufs/si_d37f4010e9a078ff/</span><br><span class="line">root@762be790cc1f:/sys/fs/aufs/si_d37f4010e9a078ff# ls</span><br><span class="line">br0  br10  br12  br14  br3  br5  br7  br9    brid1   brid11  brid13  brid2  brid4  brid6  brid8  xi_path</span><br><span class="line">br1  br11  br13  br2   br4  br6  br8  brid0  brid10  brid12  brid14  brid3  brid5  brid7  brid9</span><br><span class="line">root@762be790cc1f:/sys/fs/aufs/si_d37f4010e9a078ff# cat *</span><br><span class="line">/var/lib/docker/aufs/diff/8a94a9d1a72928628004cb344f92a54b5325f44a10a54eeb83bc0d79bfed3d2f=rw</span><br><span class="line">/var/lib/docker/aufs/diff/8a94a9d1a72928628004cb344f92a54b5325f44a10a54eeb83bc0d79bfed3d2f-init=ro+wh # 该层以及以下的13层都是只读镜像</span><br><span class="line">/var/lib/docker/aufs/diff/67614ba4f62bb6f949acff511a18447a620d5b0a2c4c293bdeb7cd9e97a6cdbc=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/654940ca942ba450e2c5dd38e10bc462333a0307b8531e3193b9f9cbcb119d16=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/37edd74902c396df578b8fcfd233457fe27efd3e0f871e677ada43a92f0bad79=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/9c0b2e0c1996496f8031c7bf148940e55b34bf7efa067725453430c8db3a27ea=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/828a1c91a6fb1928559b7b9813c0917affd84fcfa7a4e79476d20623b2c29c2d=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/8d8fd100b49edd233212e17c64c8b5061c2b79eb7f7f2fd5fae36c9bf59a502f=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/9b79d3f46e7826defa1c283d8282f3169c876bde8b6084cdbe60672acacb9274=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/864df82537caf88937c58efbf158f9185ebb872cfb54b15d8888f33561ddaa56=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/a3c07d88c61c220d3cc2e2b317b317dec0be11fd629eab7bd3def680a25686cb=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/e31f34199774f4446ddde561a3e1a3dbbc254e483f1bd7193571b93f776becc4=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/1640c122bc62e1fa893cdeae766952951a934864dacbef3e87d2d9eae68c78d1=ro+wh</span><br><span class="line">/var/lib/docker/aufs/diff/258cfd490a2345067156a2f43d9425e7d12907ce3df64072e37a17ab18b55248=ro+wh</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">/dev/shm/aufs.xino</span><br></pre></td></tr></table></figure>
<p>可见，比起该容器的初始镜像，容器多了两层镜像，<br>/var/lib/docker/aufs/diff/8a94a9d1a72928628004cb344f92a54b5325f44a10a54eeb83bc0d79bfed3d2f=rw<br>/var/lib/docker/aufs/diff/8a94a9d1a72928628004cb344f92a54b5325f44a10a54eeb83bc0d79bfed3d2f-init=ro+wh<br>根据已有的13层镜像创建一层新的只读镜像 8a94a9d1a72928628004cb344f92a54b5325f44a10a54eeb83bc0d79bfed3d2f-<code>init</code>，然后再创建一层可读写镜像层 8a94a9d1a72928628004cb344f92a54b5325f44a10a54eeb83bc0d79bfed3d2f，然后所有在容器内发生的改动，均保存到该层中。</p>
<p>如上，反映了 Docker 的镜像和容器的镜像层次结构，容器的镜像层次结构主要是多了一层可读写的镜像层，使 Docker 容器可以进行读写操作；<code>但要注意的是，Docker 容器对改动的保存是临时的，当 Docker 关闭以后，所有的修改也会随之删除</code>。要能够永久的保留这些修改，有两种选择，1、使用<code>docker commit</code>命令将当前容器中发生的变更生成一个新的只读镜像；2、使用 Data Volume。</p>
 

</li>
</ul>
</li>
</ul>
<h3 id="做一些试验"><a href="#做一些试验" class="headerlink" title="做一些试验"></a>做一些试验</h3><ul>
<li><p>在容器中创建一个文件，该文件会被创建在可写的容器层中</p>
<ul>
<li><p>进入 Docker command，创建一个文件 helloworld</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# docker run -it training/webapp /bin/bash</span><br><span class="line">root@832f3494ce20:/opt# cd ~</span><br><span class="line">root@832f3494ce20:~# touch helloworld</span><br><span class="line">root@832f3494ce20:~# echo &quot;hello world&quot; &gt; helloworld</span><br></pre></td></tr></table></figure></li>
<li><p>在宿主机上查看 AUFS 文件系统的变化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:~# cd /var/lib/docker/aufs/diff</span><br><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# find -iname helloworld</span><br><span class="line">./a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c/root/helloworld</span><br><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# ls -lt</span><br><span class="line">total 84</span><br><span class="line">drwxr-xr-x  5 root root 4096 Dec 20 08:14 a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c</span><br><span class="line">drwxr-xr-x  6 root root 4096 Dec 20 08:13 a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c-init</span><br><span class="line">drwxr-xr-x  4 root root 4096 Dec 20 08:12 693983a5a21e6225d3dcfc1976b9a97a8e73e66f44e9e8c143b492f393eb040d</span><br></pre></td></tr></table></figure>
<p>可见，在 docker 中生成的 helloworld 文件，保存在 <code>a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c</code> 目录中，这正是 Docker 容器的可写层。</p>
</li>
</ul>
</li>
<li><p>修改一个镜像层中的文件</p>
<ul>
<li><p>在 Docker 中，对 source.list 进行修改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@832f3494ce20:/sys/fs/aufs/si_1dcd197dfd656845# vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>这里，这是简单的将某一行进行注释，下面我们来看看宿主机上 AUFS 的文件的变化情况</p>
</li>
<li><p>在宿主机上，我们来看看变化情况<br>修改之前</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# find -iname sources.list</span><br><span class="line">./37edd74902c396df578b8fcfd233457fe27efd3e0f871e677ada43a92f0bad79/etc/apt/sources.list</span><br><span class="line">./5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949/usr/share/doc/apt/examples/sources.list</span><br><span class="line">./5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949/etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>修改之后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# find -iname sources.list</span><br><span class="line">./37edd74902c396df578b8fcfd233457fe27efd3e0f871e677ada43a92f0bad79/etc/apt/sources.list</span><br><span class="line">./a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c/etc/apt/sources.list</span><br><span class="line">./5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949/usr/share/doc/apt/examples/sources.list</span><br><span class="line">./5ae0f9c8801e4493a1b5c6a2ba07bf4502e63193603f50681aa07fa5cf992949/etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>我们可以清楚的看到，发生变化的 source.list 被添加到了科写层<code>a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c</code></p>
</li>
</ul>
</li>
<li><p>删除容器层中的文件<br>我们来试图在容器中删除 itsdangerous.py，看看 AUFS 文件系统发生了什么变化</p>
<ul>
<li><p>在容器中删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@832f3494ce20:/sys/fs/aufs/si_1dcd197dfd656845# cd /</span><br><span class="line">root@832f3494ce20:/# find -iname itsdangerous.py</span><br><span class="line">./usr/local/lib/python2.7/dist-packages/itsdangerous.py</span><br><span class="line">root@832f3494ce20:/# rm ./usr/local/lib/python2.7/dist-packages/itsdangerous.py</span><br><span class="line">root@832f3494ce20:/# find -iname itsdangerous.py</span><br><span class="line">root@832f3494ce20:/#</span><br></pre></td></tr></table></figure></li>
<li><p>在宿主机上查看 AUFS 文件系统的变化情况</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# find -iname *itsdangerous.py</span><br><span class="line">./a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c/usr/local/lib/python2.7/dist-packages/.wh.itsdangerous.py</span><br><span class="line">./a3c07d88c61c220d3cc2e2b317b317dec0be11fd629eab7bd3def680a25686cb/usr/local/lib/python2.7/dist-packages/itsdangerous.py</span><br></pre></td></tr></table></figure>
<p>可见，容器层(既 AUFS 可写层) <code>a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c</code>只是相应的生成了一个<code>Whiteout 文件</code>既是<code>.wh.+文件名</code>，让其在容器中不可见，而镜像层的文件不会发生任何变化。</p>
</li>
<li><p>在宿主机上直接将 .wh 文件删除，itsdangerous.py 又出现在了容器中<br>在宿主机上删除 .wh 文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/var/lib/docker/aufs/diff# rm ./a24e1296a1ecce3e8c2a6f2bc5bee83512b05cea70939d536f91b7ba089f7d1c/usr/local/lib/python2.7/dist-packages/.wh.itsdangerous.py</span><br></pre></td></tr></table></figure>
<p>检查容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@832f3494ce20:/# find -iname itsdangerous.py</span><br><span class="line">./usr/local/lib/python2.7/dist-packages/itsdangerous.py</span><br></pre></td></tr></table></figure>
<p>有意思，itsdangerous.py 在容器中又恢复了.. 这就是 AUFS 的特性，被删除的文件只是在容器层中通过 .wh 文件加上了一个不可见的标识。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode树刷题总结</title>
    <url>/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="最小高度树"><a href="#最小高度树" class="headerlink" title="最小高度树"></a>最小高度树</h2><h3 id="题目说明："><a href="#题目说明：" class="headerlink" title="题目说明："></a>题目说明：</h3><p>给定一个有序整数数组，元素各不相同且按升序排列，编写一个算法，创建一棵高度最小的二叉搜索树。</p>
<p>示例:<br>给定有序数组: [-10,-3,0,5,9],</p>
<p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p>
<pre><code>      0 
     / \ 
   -3   9 
   /   / 
 -10  5 </code></pre>
<h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">在这道题中，left和right并不代表左右结点的值，而是相应节点在数组nums中的位置，这个在编写递归开始前的判断是很重要的。</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">         <span class="comment">//最小高度树的实现，在于找到中间节点来作为整棵树的根节点，这样构建的二叉树高度差是最小的。</span></span><br><span class="line">         <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;   </span><br><span class="line">         <span class="keyword">return</span> CreateMinitree(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">CreateMinitree</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="comment">//需要在递归的开始处增加必要的判断，防止数组越界和外节点</span></span><br><span class="line">        <span class="keyword">if</span>(left&gt;=right||right&gt;nums.length||left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入中间值作为父节点，随后插入左右子树</span></span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">       TreeNode n = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        n.left = CreateMinitree(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        n.right = CreateMinitree(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h2><h3 id="题目说明：-1"><a href="#题目说明：-1" class="headerlink" title="题目说明："></a>题目说明：</h3><p>输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。</p>
<p>例如：</p>
<p>给定二叉树 [3,9,20,null,null,15,7]， </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure>
<h3 id="解法一：递归-1"><a href="#解法一：递归-1" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> maxLeftHeight = maxDepth(root.left);</span><br><span class="line">            <span class="keyword">int</span> maxRightHeight = maxDepth(root.right);</span><br><span class="line">            <span class="keyword">return</span> Math.max(maxLeftHeight,maxRightHeight)+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="剑指offer27-二叉树的镜像-翻转二叉树"><a href="#剑指offer27-二叉树的镜像-翻转二叉树" class="headerlink" title="剑指offer27.二叉树的镜像/翻转二叉树"></a>剑指offer27.二叉树的镜像/翻转二叉树</h2><h3 id="题目说明：-2"><a href="#题目说明：-2" class="headerlink" title="题目说明："></a>题目说明：</h3><p>请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<p>例如输入：</p>
 <img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/01.png" class>

<img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/02.png" class>



<h3 id="解法一：DFS递归"><a href="#解法一：DFS递归" class="headerlink" title="解法一：DFS递归"></a>解法一：DFS递归</h3><ul>
<li>根据二叉树镜像的定义，考虑递归遍历（dfs）二叉树，交换每个节点的左 / 右子节点，即可生成二叉树的镜像。</li>
</ul>
<h4 id="递归解析："><a href="#递归解析：" class="headerlink" title="递归解析："></a>递归解析：</h4><ul>
<li>**终止条件 **:当节点 root 为空时（即越过叶节点），则返回 null ；</li>
<li><strong>递推工作</strong>：<ul>
<li>初始化节点 tmp ，用于暂存 root 的左子节点；</li>
<li>开启递归右子节点mirrorTree(root,right)，并将返回值作为root的左子节点。</li>
<li>开启递归右子节点mirrorTree(root,left)，并将返回值作为root的右子节点。</li>
</ul>
</li>
<li><strong>返回值</strong>: 返回新构建的树的root结点。</li>
</ul>
<blockquote>
<p>Q：为何需要暂存root的左子节点？</p>
<p>A：在递归完成root的右子节点后，此时root.left的值已经发生改变，此时再进行递归左子树就会出现问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在暂时存储左子树的时候，一定要注意传入的是root.left，即左子树的第一个节点。不要再new TreeNode了；</span></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right  = mirrorTree(temp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//或者是这样</span></span><br><span class="line">          TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="解法二：辅助栈"><a href="#解法二：辅助栈" class="headerlink" title="解法二：辅助栈"></a>解法二：辅助栈</h3><blockquote>
<ul>
<li>利用栈（或队列）遍历树的所有节点 node<em>n<strong>o</strong>d**e</em> ，并交换每个 node的左 / 右子节点。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="合并两棵二叉树"><a href="#合并两棵二叉树" class="headerlink" title="合并两棵二叉树"></a>合并两棵二叉树</h2><h3 id="题目概述："><a href="#题目概述：" class="headerlink" title="题目概述："></a>题目概述：</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p>
<p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">输出: </span><br><span class="line">合并后的树:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="解法一：DFS深度优先搜索"><a href="#解法一：DFS深度优先搜索" class="headerlink" title="解法一：DFS深度优先搜索"></a>解法一：DFS深度优先搜索</h3><p>可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。</p>
<p>两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。</p>
<p>如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空；</p>
<p>如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点；</p>
<p>如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。</p>
<p>对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对两棵树先进行判空</span></span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将合并二叉树的根节点构造出来,并且开始递归，每合并完一个节点，还要递归的合并其左右子树。</span></span><br><span class="line">        TreeNode merged = <span class="keyword">new</span> TreeNode(root1.val+root2.val);</span><br><span class="line">        merged.left = mergeTrees(root1.left,root2.left);</span><br><span class="line">        merged.right = mergeTrees(root2.right ,root1.right );</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/03.png" class>



<h3 id="解法二：广度优先搜索BFS"><a href="#解法二：广度优先搜索BFS" class="headerlink" title="解法二：广度优先搜索BFS"></a>解法二：广度优先搜索BFS</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。</span><br><span class="line"></span><br><span class="line">如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。</span><br><span class="line"></span><br><span class="line">使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。</span><br><span class="line"></span><br><span class="line">如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况：</span><br><span class="line"></span><br><span class="line">如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列；</span><br><span class="line"></span><br><span class="line">如果两个原始二叉树的左子节点有一个为空，即有一个原始二叉树的左子树为空，则合并后的二叉树的左子树即为另一个原始二叉树的左子树，此时也不需要对非空左子树继续遍历，因此不需要将左子节点加入队列。</span><br><span class="line"></span><br><span class="line">对于右子节点和右子树，处理方法与左子节点和左子树相同。</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode merged = <span class="keyword">new</span> TreeNode(root1.val+root2.val);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向队列中添加元素</span></span><br><span class="line">        queue.offer(merged);</span><br><span class="line">        queue1.offer(root1);</span><br><span class="line">        queue2.offer(root2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue1.isEmpty()&amp;&amp;!queue2.isEmpty())&#123;</span><br><span class="line">            TreeNode node1 = queue1.poll();</span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            TreeNode node2 = queue2.poll();</span><br><span class="line"></span><br><span class="line">            TreeNode left1 = node1.left,left2 = node2.left,right1 = node1.right,right2 = node2.right;</span><br><span class="line">            <span class="keyword">if</span>(left1!=<span class="keyword">null</span> || left2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(left1!=<span class="keyword">null</span>&amp;&amp;left2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    TreeNode left = <span class="keyword">new</span> TreeNode(left1.val+left2.val);</span><br><span class="line">                    node.left = left;</span><br><span class="line">                    queue.offer(left);</span><br><span class="line">                    queue1.offer(left1);</span><br><span class="line">                    queue2.offer(left2);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.left = left1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.left = left2;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         </span><br><span class="line">            <span class="keyword">if</span>(right1!=<span class="keyword">null</span> || right2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right1!=<span class="keyword">null</span>&amp;&amp;right2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    TreeNode right = <span class="keyword">new</span> TreeNode(right1.val+right2.val);</span><br><span class="line">                    node.right = right;</span><br><span class="line">                    queue.offer(right);</span><br><span class="line">                    queue1.offer(right1);</span><br><span class="line">                    queue2.offer(right2);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right1!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.right = right1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(right2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    node.right = right2;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/04.png" class>



<h2 id="二叉搜索树的范围和"><a href="#二叉搜索树的范围和" class="headerlink" title="二叉搜索树的范围和"></a>二叉搜索树的范围和</h2><h2 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h2><h2 id="二叉树的层平均值"><a href="#二叉树的层平均值" class="headerlink" title="二叉树的层平均值"></a>二叉树的层平均值</h2><h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><p>给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。</p>
<p>示例 1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7</span><br><span class="line">输出：[3, 14.5, 11]</span><br><span class="line">解释：</span><br><span class="line">第 0 层的平均值是 3 ,  第1层是 14.5 , 第2层是 11 。因此返回 [3, 14.5, 11] 。</span><br></pre></td></tr></table></figure>
<p><strong>提示：</strong></p>
<ul>
<li>节点值的范围在32位有符号整数范围内。</li>
</ul>
<h3 id="解法一-深度优先搜索"><a href="#解法一-深度优先搜索" class="headerlink" title="解法一: 深度优先搜索"></a>解法一: 深度优先搜索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Double&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建两个集合，counts用来存放二叉树每一层的节点数， sums用来存放每一层的节点总和。</span></span><br><span class="line">        List&lt;Integer&gt; counts = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        List&lt;Double&gt; sums = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        dfs(root,<span class="number">0</span>,counts,sums);</span><br><span class="line">        List&lt;Double&gt; averages = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">        <span class="keyword">int</span> size = sums.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;size; i++)&#123;</span><br><span class="line">            averages.add(sums.get(i)/counts.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> averages;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> level,List&lt;Integer&gt; counts,List&lt;Double&gt; sums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(level&lt;sums.size())&#123;       <span class="comment">//这个就是用来判断当前层节点个数是否&gt;2,因为最初传入Level的值为0；</span></span><br><span class="line">            sums.set(level,sums.get(level)+root.val);</span><br><span class="line">            counts.set(level,counts.get(level)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sums.add(<span class="number">1.0</span>*root.val);</span><br><span class="line">            counts.add(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="comment">//这个else的情况就是当前同层结点只有一个。sums直接添加值，而counts将当前层数节点个数设置为一个。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//开始递归</span></span><br><span class="line">        dfs(root.left,level+<span class="number">1</span>,counts,sums);</span><br><span class="line">        dfs(root.right,level+<span class="number">1</span>,counts,sums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p><img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210325152848238.png" alt="image-20210325152848238"></p>
<h3 id="解法二：广度优先搜索"><a href="#解法二：广度优先搜索" class="headerlink" title="解法二：广度优先搜索"></a>解法二：广度优先搜索</h3><h3 id="复杂度分析：-3"><a href="#复杂度分析：-3" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><h2 id="剑指offer68-二叉树的最近公共祖先"><a href="#剑指offer68-二叉树的最近公共祖先" class="headerlink" title="剑指offer68 二叉树的最近公共祖先"></a>剑指offer68 二叉树的最近公共祖先</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TreeNode ans;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ans = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        thist.dfs(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为从最底层子树开始递归，所以找出来的一定是最近公共子树</span></span><br><span class="line">        <span class="keyword">boolean</span> flson = dfs(root.left,p,q);</span><br><span class="line">        <span class="keyword">boolean</span> frson = dfs(root.right,p,q);</span><br><span class="line">        <span class="comment">//判断是否已经找到最近公共祖先的条件</span></span><br><span class="line">        <span class="comment">//1.左右子树均包含要找的值,满足条件，返回ans</span></span><br><span class="line">        <span class="comment">//2.左右子树其中一个包含p或者q，另一个则是自身</span></span><br><span class="line">        <span class="keyword">if</span>((flson&amp;&amp;frson) || ((root.val==p.val||root.val==q.val)&amp;&amp;(flson||frson)))&#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归返回值，注意给出的返回条件</span></span><br><span class="line">        <span class="keyword">return</span> flson || frson || (root.val==p.val || root.val ==q.val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="复杂度分析：-4"><a href="#复杂度分析：-4" class="headerlink" title="复杂度分析："></a>复杂度分析：</h3><p><img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210326170817422.png" alt="image-20210326170817422"></p>
<h3 id="解法二：存储父节点"><a href="#解法二：存储父节点" class="headerlink" title="解法二：存储父节点"></a>解法二：存储父节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer,TreeNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Set&lt;Integer&gt; set  = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//这是记录p的所有祖先的过程，这是通过节点值来标识的</span></span><br><span class="line">            set.add(p.val);</span><br><span class="line">            p = map.get(p.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//开始将q的祖先与所有p的祖先匹配，然后找出第一个一样的祖先。</span></span><br><span class="line">            <span class="comment">//注意：都是从底层子树开始的</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(q.val))&#123;</span><br><span class="line">                <span class="keyword">return</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有找到的话，继续向上找q的祖先</span></span><br><span class="line">            q = map.get(q.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root.left !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(root.left.val,root);</span><br><span class="line">            dfs(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root.right !=<span class="keyword">null</span>)&#123;</span><br><span class="line">            map.put(root.right.val,root);</span><br><span class="line">            dfs(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p><img data-src="/2021/03/23/Leetcode%E6%A0%91%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20210326174012955.png" alt="image-20210326174012955"></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Process</title>
    <url>/2022/02/16/Process/</url>
    <content><![CDATA[<h1 id="Unix-Process"><a href="#Unix-Process" class="headerlink" title="Unix Process"></a>Unix Process</h1><img data-src="/2022/02/16/Process/image16.png" class>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>进程就是处于执行期的程序(目标码存放在某种存储介质上)。但进程并不仅仅局限于一段可执行程序代码(Unix称其为代码段，text section)，通常<strong>进程还要包含其他资源</strong>，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程(thread of execution),当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明地管理所有细节。</p>
<blockquote>
<p>所以说，程序本身并不是进程，<strong>进程是处于执行期的程序以及相关资源的总称</strong></p>
</blockquote>
<h3 id="进程的两种虚拟机制"><a href="#进程的两种虚拟机制" class="headerlink" title="进程的两种虚拟机制"></a>进程的两种虚拟机制</h3><ul>
<li><p>虚拟处理器</p>
<p>虽然实际上可能是 许多进程正在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器</p>
</li>
<li><p>虚拟内存</p>
<p>虚拟内存让进程在分配和管理内存时觉得自己拥有整个 系统的所有内存资源。</p>
</li>
</ul>
<h2 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h2><p>内核把<strong>进程的列表</strong>存放在叫做<strong>任务队列(task list©)的双向循环链表</strong>中。链表中的每一 项都是类型为task_struct、称为<strong>进程描述符</strong>(process descriptor)的结构，该结构定义在＜linux/ sched.h＞文件中。<strong>进程描述符中包含一个具体进程的所有信息</strong>。</p>
<p>进程描述符中包含的数据能完整 地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有其他更多信息</p>
 <img data-src="/2022/02/16/Process/image01.png" class>

<h3 id="分配进程描述符-slab-thread-info"><a href="#分配进程描述符-slab-thread-info" class="headerlink" title="分配进程描述符(slab+thread_info)"></a>分配进程描述符(slab+thread_info)</h3><p>Linux通过<strong>slab分配器</strong>分配task_struct结构，这样能达到<strong>对象复用</strong>和<strong>缓存着色</strong>（cache coloring）</p>
<p>在2.6以前的内核中，各个进程的task_struct存放在它们 内核栈的尾端。这样做是为了让那些像x86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，而避免使用额外的寄存器专门记录。由于现在用slab分配器动态生成task_ struct,所以只需在栈底（对于向下增长的栈来说）或栈顶（对于向上增长的栈来说）创建一个 新的结构 struct thread_info 。</p>
  <img data-src="/2022/02/16/Process/image02.png" class>



 <img data-src="/2022/02/16/Process/image03.png" class>

<p>每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任 务实际task_struct的指针。</p>
<h3 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h3><p>内核通过一个唯一的进程标识值（process identification value）或<strong>PID</strong>来标识每个进程。PID是 一个数，表示为pid_t隐含类型,实际上就是一个int类型。为了与老版本的Unix和Linux兼容， PID的最大值默认设置为32768 （short int短整型的最大值,），这个最大值很重要，因为它实际上就是系统中允许同时存在的进程的最大数目。尽管这个值也可以增加到高达400万 （这受&lt;linux/threads.h＞中所定义PID最大值的限制）。内核把每个进程的PID存放在它们各自的进程描述符中。 </p>
<p>在内核中，<strong>访问任务通常需要获得指向其task_struct的指针</strong>。实际上，内核中大部分处理进程的代码都是直接通过task_struct进行的。因此，通过<strong>current宏査找到当前正在运行进程</strong>的进程描述符的速度就显得尤为重要。硬件体系结构不同，该宏的实现也不同，它必须针对专门的硬件体系结构做处理。</p>
<ul>
<li>有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程task_struct 的指针，用于加快访问速度。</li>
<li>像x86这样的体系结构（其寄存器并不富余），就只能在内 核栈的尾端创建thread_info结构，通过计算偏移间接地查找task_struct结构。 </li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程描述符中的state域描述了进程的当前状态，系统中的每个进程都必然处于五种进程状态中的一种。该域的值也必为下列五种状态标志之一:</p>
<ul>
<li><p><strong>TASK_RUNNING</strong> （运行）— 进程是可执行的；它或者正在执行，或者在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态； 这种状态也可以应用到内核空间中正在执行的进程。</p>
</li>
<li><p>**TASK_INTERRUPTIBLE **（可中断）— 进程正在睡眠（也就是说它被阻塞），等待某些条 件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会 因为接收到信号而提前被唤醒并随时准备投入运行</p>
</li>
<li><p>**TASK_UNINTERRUPTIBLE **（不可中断）— 除了就算是接收到信号也不会被唤醒或准备 投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须在等待时不受干扰或 等待事件很快就会发生时出现。由于处于此状态的任务对信号不做响应，所以较之可中断 状态e,使用得较少。</p>
</li>
<li><p><strong>_TASK_TRACED</strong>—被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。</p>
</li>
<li><p>**_TASK_STOPPED **（停止）— 进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP, SIGTTIN, SIGTTOU等信号的时候。此外, 在调试期间接收到任何信号，都会使进程进入这种状态。</p>
<img data-src="/2022/02/16/Process/image04.png" class>

</li>
</ul>
<h3 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h3> <img data-src="/2022/02/16/Process/image05.png" class>



<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间 执行。一般程序在用户空间执行。当一个程序调执行了系统调用或者触发了某个 异常，它就<strong>陷入了内核空间</strong>。此时，我们称内核“代表进程执行”并<strong>处于进程上下文</strong>中。在此上下文中current宏是有效的°。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间会继续执行。 系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核 执行— 对内核的所有访问都必须通过这些接口。</p>
<p>​    </p>
<h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>Unix系统的进程之间存在一个明显的继承关系，在Linux系统中也是如此。所有的进程都 是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初 始化脚本(initscript)并执行其他的相关程序，最终完成系统启动的整个过程</p>
<p>系统中的每个进程必有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。拥 有同一个父进程的所有进程被称为兄弟。<strong>进程间的关系存放在进程描述符中</strong>。每个task_struct都 包含一个指向其<strong>父进程tast_struct</strong>、叫做<strong>parent</strong>的指针，还包含一个称为<strong>children的子进程链表</strong>。 所以。</p>
<ul>
<li>对于当前进程，通过下面的代码获得其父进程的进程描述符：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span>  current-&gt;parent;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过以下方式访问子进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>,&amp;current-&gt;children)&#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>,struct task_struct,sibling); <span class="comment">//task指向当前的某个子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
 <img data-src="/2022/02/16/Process/image06.png" class>

<h2 id="进程创建（fork-exec）"><a href="#进程创建（fork-exec）" class="headerlink" title="进程创建（fork+exec）"></a>进程创建（fork+exec）</h2><p>在新的地址空间创建线程，读入可执行文件，最后开始执行。</p>
<blockquote>
<p>fork</p>
</blockquote>
<p><strong>拷贝当前进程创建一个子进程</strong>。子进程与父进程的区别仅仅在于PID (每个进程唯一)、PPID (父进程的进程号，子进程将其设置为被拷贝进程的PID)和某些资源和统计量(例如，挂起的信号，它没有必要被继承)。</p>
<blockquote>
<p>exec</p>
</blockquote>
<p><strong>exec()函数负责读取可执行文件并将其载入地址空间开始运行</strong>。把这两个函数组合起来使用的效果跟其他系统使用的单一函数的效果相似。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>传统的fork()系统调用<strong>直接把所有的资源复制给新创建的进程</strong></p>
<p>Linux的fbrk()使用写时拷贝(copy-on-write)页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。</p>
<p><strong>只有在需要写入的时候</strong>，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资 源的复制只有在需要写入的时候才进行，在此之前，<strong>只是以只读方式共享</strong>。这种技术使地址空间 上的页的拷贝被推迟到实际发生写入的时候才进行。在页根本不会被写入的情况下(举例来说， fork。后立即调用exec())它们就无须复制了</p>
<p><strong>fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符</strong>。在一般情况 下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据(地址空间里常常包含数十兆的数据)。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。</p>
<h3 id="frok-函数"><a href="#frok-函数" class="headerlink" title="frok()函数"></a>frok()函数</h3><p>Linux通过<strong>clone()系统调用</strong>实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源</p>
<blockquote>
<p>fbrk()、▼fork和_clone () 库函数都<strong>根据各自需要的参数</strong>标志去调用clone(),然后由clone()去调用do_fork().</p>
</blockquote>
<p>do_fork完成了创建中的大部分工作，它的定义在kernel/fork.c文件中。该函数调用copy_ process()函数，然后让进程开始运行。</p>
<p>**copy_process()**函数流程如下：</p>
 <img data-src="/2022/02/16/Process/image07.png" class>

 <img data-src="/2022/02/16/Process/image08.png" class>

<p>再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其 投入运行。<strong>内核有意选择子进程首先执行</strong>°。因为一般子进程都会马上调用exec()函数，这样可 以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<h3 id="vfork-函数"><a href="#vfork-函数" class="headerlink" title="vfork()函数"></a>vfork()函数</h3> <img data-src="/2022/02/16/Process/image09.png" class>

<h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>线程机制是现代编程技术中常用的一种抽象概念。该机制提供了在同一程序内共享内存地址 空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。线程机制<strong>支持并发</strong>程序设计 技术(concurrentprogramming),在多处理器系统上，它也能<strong>保证真正的并行处理</strong>(parallelism)。</p>
<p>Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。<strong>Linux把所有的线程都当做进程来实现</strong>。<strong>内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程</strong>。相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自 己的task_struct,所以在内核中，它看起来就像是一个普通的进程(只是线程和其他一些进程共 享某些资源，如地址空间)。</p>
<p>上述线程机制的实现与Microsoft Windows或是Sun Solaris等操作系统的实现差异非常 大。这些系统都在内核中提供了专门支持线程的机制(这些系统常常把线程称作轻量级进程 (lightweight processes))o “轻量级进程”这种叫法本身就概括了 Linux在此处与其他系统的差 异。在其他的系统中，相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于**<em>Linux来说，它只是一种进程间共享资源的手段(**</em>Linux的进程本身就够轻量级了)°。 举个例子来说，假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有 一个包含指向四个不同线程的指针的进程描述符。该描述符负责描述像地址空间、打开的文件这 样的共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅<strong>创建四个进程并分配四个普通的task_sturct结构</strong>。建立这四个进程时指定他们共享某些资源，这是相当高雅的做法。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS |CLONE_FILES |CLONE_SIGHAND,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>传递给clone()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。</p>
 <img data-src="/2022/02/16/Process/image10.png" class>

 <img data-src="/2022/02/16/Process/image11.png" class>



<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程(kernel thread)完成— 独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程**<em>没有独立的地址空间**</em>(实际上指向地址空间的mm指针被设置为NULL).它们<strong>只在内核空间运行</strong>，<strong>从来不切到用户空间</strong>去。内核进程和普通进程一样，可以被调度，也可以被抢占。</p>
<p>在装有Linux系统的机子上运行<strong>ps -ef</strong>命令，你可以看到内核线程，有很多！这些线程在系统启 动时由另外一些内核线程创建。实际上，内核线程也只能由其他内核线程创建。<strong>内核是通过从 kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的</strong>。创建的进程处于不可运行状态，如果不通过调用<strong>wake_up_process()</strong> 明确地唤醒它，它不会主动运行。创建一个进程并让它运行起来，可以通过调用<strong>kthread_run()</strong> 来达到</p>
 <img data-src="/2022/02/16/Process/image12.png" class>

<p><strong>kthread_run()</strong> 宏实现</p>
 <img data-src="/2022/02/16/Process/image13.png" class>

<p>内核线程启动后就一直运行直到调用do_exit()退出，或者内核的其他部分调用kthread_ stop()退出，传递给kthread_stop()的参数为kthread_create()函数返回的task struct结构的地址：</p>
<blockquote>
<p>int kthread_stop(struct task_struct *k)</p>
</blockquote>
<h2 id="进程的终结"><a href="#进程的终结" class="headerlink" title="进程的终结"></a>进程的终结</h2><blockquote>
<p>当一个进程终结时，内核必须释放它所占有的资源 并把这一不幸告知其父进程。</p>
</blockquote>
<p>进程的析构是自身引起的。它发生在进程<strong>调用exit()系统调用</strong>时，</p>
<ul>
<li><p>既可能显式地调用这个系统调用</p>
</li>
<li><p>也可能隐式地从某个程序的主函数返回(其实C语言编译器会在main() 函数的返回点后面放置调用exit()的代码)。</p>
</li>
<li><p>当进程接受到它既不能处理也不能忽略的信号或异 常时，它还可能被动地终结。</p>
<p>不管进程是怎么终结的，该任务大部分都要靠<strong>do_exit()</strong>(定义于 kemel/exitx)来完成，</p>
</li>
</ul>
<p>do_exit完成的工作</p>
 <img data-src="/2022/02/16/Process/image14.png" class>

<p>的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。</p>
<p>与进程相关联的<strong>所有资源都被释放掉了</strong>(假设该进程是这些资源的唯一使用者)。进程<strong>不可运行</strong>(实际上也没有地址空间让它运行)并处于<strong>EXIT_ZOMBIE</strong>退出状态。它占用的所 有内存就是内核栈、thread_infb结构和tast_struct结构。此时<strong>进程存在的唯一目的就是向它的父进程提供信息</strong>。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内 存被释放，归还给系统使用。</p>
<h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p>在调用了 do_exit()之后，尽管线程已经僵死不能再运行了，但是系统还<strong>保留了它的进程描述符</strong>。这样做可以让系统有办法在子进程终结后仍能获得它的信息。因此，**<em>进程终结时所需的清理工作和进程描述符的删除被分开执行**</em>。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。 </p>
 <img data-src="/2022/02/16/Process/image15.png" class>

<h3 id="孤儿进程（父进程在子进程之前推出）"><a href="#孤儿进程（父进程在子进程之前推出）" class="headerlink" title="孤儿进程（父进程在子进程之前推出）"></a>孤儿进程（父进程在子进程之前推出）</h3><p>如果<strong>父进程在子进程之前退出</strong>，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。</p>
<p><strong>解决方法</strong>给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。在do_exit()中会调用exit_notify(),该函数会调用fbrget_original_parent(),而后者会调用find_new_reaper()来执行寻父过程：</p>
<p>一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。 init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。</p>
<p>父进程通过wait()系统调用族来收集其后代信息</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker部署开发环境</title>
    <url>/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="在Linux上安装Docker"><a href="#在Linux上安装Docker" class="headerlink" title="在Linux上安装Docker"></a>在Linux上安装Docker</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> # 系统内核是3.10以上的</span><br><span class="line">root@theSun:&#x2F;# uname -r</span><br><span class="line">4.4.0-185-generic</span><br><span class="line"></span><br><span class="line"># 系统版本</span><br><span class="line">root@theSun:&#x2F;# cat &#x2F;etc&#x2F;os-release </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> step 1: 安装必要的一些系统工具</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"><span class="meta">#</span><span class="bash"> step 2: 安装GPG证书</span></span><br><span class="line">curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"><span class="meta">#</span><span class="bash"> Step 3: 写入软件源信息</span></span><br><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> Step 4: 更新并安装 Docker-CE</span></span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get -y install docker-ce</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像</span></span><br><span class="line">docker image</span><br><span class="line"></span><br><span class="line">卸载：</span><br><span class="line">1、卸载依赖</span><br><span class="line">sudo apt-get purge docker-ce docker-ce-cli containerd.io</span><br><span class="line">2、删除资源</span><br><span class="line">sudo rm -rf /var/lib/docker</span><br></pre></td></tr></table></figure>
<h2 id="Docker安装部署RabbitMQ"><a href="#Docker安装部署RabbitMQ" class="headerlink" title="Docker安装部署RabbitMQ"></a>Docker安装部署RabbitMQ</h2><p>这里注意获取镜像的时候要获取management版本的，不要获取last版本的，management版本的才带有管理界面。</p>
<h3 id="查询镜像"><a href="#查询镜像" class="headerlink" title="查询镜像"></a>查询镜像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">search</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br></pre></td></tr></table></figure>
<p>可以看到如下结果：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># docker search rabbitmq:management</span></span><br><span class="line">INDEX       NAME                                          DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">docker.io   docker.io/macintoshplus/rabbitmq-management   Based <span class="keyword">on</span> rabbitmq:management whit python a...   <span class="number">1</span>                    [OK]</span><br><span class="line">docker.io   docker.io/transmitsms/rabbitmq-sharded        Fork of rabbitmq:management <span class="keyword">with</span> sharded_e...   <span class="number">0</span></span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta">#</span></span><br></pre></td></tr></table></figure>


<h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br></pre></td></tr></table></figure>
<p>可以看到如下结果</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta"># docker pull rabbitmq:management</span></span><br><span class="line">Trying to pull repository docker.io/library/rabbitmq ...</span><br><span class="line">management: Pulling <span class="keyword">from</span> docker.io/library/rabbitmq</span><br><span class="line">e7bb522d92ff: Pull complete</span><br><span class="line">ad90649c4d84: Pull complete</span><br><span class="line"><span class="number">5</span>a318b914d6c: Pull complete</span><br><span class="line">cedd60f70052: Pull complete</span><br><span class="line">f4ec28761801: Pull complete</span><br><span class="line">b8fa44aa9074: Pull complete</span><br><span class="line">e8002a209c24: Pull complete</span><br><span class="line">cd1206edcd43: Pull complete</span><br><span class="line"><span class="number">769b</span>e0727074: Pull complete</span><br><span class="line"><span class="number">7308b</span>93d35af: Pull complete</span><br><span class="line">c4102ef22c29: Pull complete</span><br><span class="line">fefc8e1aa4b5: Pull complete</span><br><span class="line">a271d400045b: Pull complete</span><br><span class="line">b0d4c40c62de: Pull complete</span><br><span class="line">Digest: sha256:<span class="number">8761</span>de2c22badfc86dfe89791dc9dbf122f67ff0f8981966573d267af421b97f</span><br><span class="line">[<span class="meta">root@localhost ~</span>]<span class="meta">#</span></span><br></pre></td></tr></table></figure>
<h3 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-d</span> <span class="selector-tag">-p</span> 5672<span class="selector-pseudo">:5672</span> <span class="selector-tag">-p</span> 15672<span class="selector-pseudo">:15672</span> <span class="selector-tag">--name</span> <span class="selector-tag">rabbitmq</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br></pre></td></tr></table></figure>
<p>看到如下结果，变成功了：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-attr">[root@localhost ~]</span># <span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">-d</span> <span class="selector-tag">-p</span> 5672<span class="selector-pseudo">:5672</span> <span class="selector-tag">-p</span> 15672<span class="selector-pseudo">:15672</span> <span class="selector-tag">--name</span> <span class="selector-tag">rabbitmq</span> <span class="selector-tag">rabbitmq</span><span class="selector-pseudo">:management</span></span><br><span class="line"><span class="selector-tag">e194a2dbeb52f2296dfb6d1c527cf052d82be5ed9a4c974d70dcd6af3da3eb7e</span></span><br><span class="line"><span class="selector-attr">[root@localhost ~]</span>#</span><br></pre></td></tr></table></figure>


<h3 id="访问管理页面"><a href="#访问管理页面" class="headerlink" title="访问管理页面"></a>访问管理页面</h3><p>访问管理界面的地址就是 http://[宿主机IP]:15672，可以使用默认的账户登录，用户名和密码都guest，如：</p>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/01.png" class>

<blockquote>
<p><strong>需要注意的是</strong>：</p>
<ul>
<li>在云服务器上，默认情况下，RabbitMQ的端口号15672是不开放的，需要自己登陆控制台添加安全组规则，放开对15672端口号的访问限制。</li>
<li>Linux系统上，宿主IP地址直接就是该系统的公网地址。</li>
</ul>
</blockquote>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/02.png" class>

<h2 id="Docker安装Redis"><a href="#Docker安装Redis" class="headerlink" title="Docker安装Redis"></a>Docker安装Redis</h2><h3 id="找到一个合适的docker的redis的版本"><a href="#找到一个合适的docker的redis的版本" class="headerlink" title="找到一个合适的docker的redis的版本"></a>找到一个合适的docker的redis的版本</h3><p>可以去docker hub中去找一下</p>
<p><a href="https://hub.docker.com/_/redis?tab=tags">https://hub.docker.com/_/redis?tab=tags</a></p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/03.png" class>

<h3 id="使用docker安装redis"><a href="#使用docker安装redis" class="headerlink" title="使用docker安装redis"></a>使用docker安装redis</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">sudo docker pull redis</span><br></pre></td></tr></table></figure>
<p>安装好之后使用<code>docker images即可查看</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ </span><br><span class="line">truedei@truedei:~$ sudo docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">redis               latest              987b78fc9e38        <span class="number">10</span> days ago         104MB</span><br><span class="line">httpd               latest              a8a9cbaadb0c        <span class="number">2</span> weeks ago         166MB</span><br><span class="line">fjudith/draw.io     latest              7b136fc80d31        <span class="number">3</span> weeks ago         683MB</span><br><span class="line">mysql               <span class="number">5.7</span><span class="number">.29</span>              f5829c0eee9e        <span class="number">5</span> weeks ago         455MB</span><br><span class="line">truedei@truedei:~$ </span><br><span class="line">truedei@truedei:~$ </span><br></pre></td></tr></table></figure>
<h3 id="准备redis"><a href="#准备redis" class="headerlink" title="准备redis"></a>准备redis</h3><p>因为需要<a href="https://cloud.tencent.com/product/crs?from=10680">redis</a>的配置文件，这里最好还是去redis的官方去下载一个redis使用里面的配置文件即可</p>
<p>redis中文官方网站：<a href="http://www.redis.cn/download.html">http://www.redis.cn/download.html</a></p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/04.png" class>

<p>下载后解压出来： </p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/05.png" class>

<p>这个<code>redis.conf</code>文件就是咱们需要的，为了保险，还是拷贝一下，做个备份。</p>
<h3 id="配置redis"><a href="#配置redis" class="headerlink" title="配置redis"></a>配置redis</h3><p><strong>修改<code>redis.conf</code>配置文件：</strong> 主要配置的如下：</p>
<blockquote>
<p> <code>bind 127.0.0.1</code> #注释掉这部分，使redis可以外部访问 <code>daemonize no</code>#用守护线程的方式启动 <code>requirepass 你的密码</code>#给redis设置密码 <code>appendonly yes</code>#redis持久化　　默认是no <code>tcp-keepalive 300</code> #防止出现远程主机强迫关闭了一个现有的连接的错误 默认是300 </p>
</blockquote>
<h3 id="创建本地与docker映射的目录，即本地存放的位置"><a href="#创建本地与docker映射的目录，即本地存放的位置" class="headerlink" title="创建本地与docker映射的目录，即本地存放的位置"></a>创建本地与docker映射的目录，即本地存放的位置</h3><p>创建本地存放redis的位置;</p>
<blockquote>
<p> 可以自定义，因为我的docker的一些配置文件都是存放在<code>/data</code>目录下面的，所以我依然在<code>/data</code>目录下创建一个<code>redis</code>目录，这样是为了方便后期管理 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ sudo mkdir /data/redis</span><br><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ sudo mkdir /data/redis/data</span><br></pre></td></tr></table></figure>
<p>把<code>配置文件</code>拷贝到刚才创建好的文件里</p>
<blockquote>
<p> 因为我本身就是Linux操作系统，所以我可以直接拷贝过去，如果你是windows的话，可能需要使用ftp拷贝过去，或者直接复制内容，然后粘贴过去。 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ sudo cp -p redis.conf /data/redis/</span><br><span class="line">truedei@truedei:redis-<span class="number">5.0</span><span class="number">.5</span>$ </span><br></pre></td></tr></table></figure>
<h3 id="启动docker-redis"><a href="#启动docker-redis" class="headerlink" title="启动docker redis"></a>启动docker redis</h3><p>启动：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ sudo docker run -p <span class="number">6379</span>:<span class="number">6379</span> --name redis -v /data/redis/redis.conf:<span class="regexp">/etc/</span>redis/redis.conf  -v /data/redis/data:<span class="regexp">/data -d redis redis-server /</span>etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<blockquote>
<p> <code>-p 6379:6379</code>:把容器内的6379端口映射到<a href="https://cloud.tencent.com/product/cdh?from=10680">宿主机</a>6379端口 <code>-v /data/redis/redis.conf:/etc/redis/redis.conf</code>：把宿主机配置好的redis.conf放到容器内的这个位置中 <code>-v /data/redis/data:/data</code>：把redis持久化的数据在宿主机内显示，做数据备份 <code>redis-server /etc/redis/redis.conf</code>：这个是关键配置，让redis不是无配置启动，而是按照这个redis.conf的配置启动 <code>–appendonly yes</code>：redis启动后数据持久化 </p>
</blockquote>
<h3 id="查看是否启动成功"><a href="#查看是否启动成功" class="headerlink" title="查看是否启动成功"></a>查看是否启动成功</h3><p>查看是否成功启动：<code>sudo docker ps</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ sudo docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class="line">85cb7d83a2ff        redis               <span class="string">&quot;docker-entrypoint.s…&quot;</span>   <span class="number">7</span> minutes ago       Up <span class="number">7</span> minutes        <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">6379</span>-&gt;<span class="number">6379</span>/tcp              redis</span><br><span class="line">0a122a08125f        mysql:<span class="number">5.7</span><span class="number">.29</span>        <span class="string">&quot;docker-entrypoint.s…&quot;</span>   <span class="number">5</span> weeks ago         Up About an hour    <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">3306</span>-&gt;<span class="number">3306</span>/tcp, <span class="number">33060</span>/tcp   mysql57</span><br><span class="line">truedei@truedei:~$ </span><br></pre></td></tr></table></figure>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/06.png" class>

<p>可以查看一下日志：<code>sudo docker logs redis</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">truedei@truedei:~$ sudo docker logs redis</span><br><span class="line">1:C 29 May 2020 01:16:22.107 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">1:C 29 May 2020 01:16:22.107 # Redis version=6.0.3, bits=64, commit=00000000, modified=0, pid=1, just started</span><br><span class="line">1:C 29 May 2020 01:16:22.107 # Configuration loaded</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-<span class="string">``</span>__ <span class="string">&#x27;&#x27;</span>-._                                             </span><br><span class="line">      _.-<span class="string">``</span>    <span class="string">`.  `</span>_.  <span class="string">&#x27;&#x27;</span>-._           Redis <span class="number">6.0</span><span class="number">.3</span> (<span class="number">00000000</span>/<span class="number">0</span>) <span class="number">64</span> bit</span><br><span class="line">  .-<span class="string">``</span> .-<span class="string">``</span><span class="string">`.  `</span><span class="string">``</span>\/    _.,_ <span class="string">&#x27;&#x27;</span>-._                                   </span><br><span class="line"> (    <span class="string">&#x27;      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|&#x27;</span><span class="string">` _.-&#x27;|     Port: 6379</span></span><br><span class="line"><span class="string"> |    `</span>-._   <span class="string">`._    /     _.-&#x27;    |     PID: 1</span></span><br><span class="line"><span class="string">  `</span>-._    <span class="string">`-._  `</span>-./  _.-<span class="string">&#x27;    _.-&#x27;</span>                                   </span><br><span class="line"> |<span class="string">`-._`</span>-._    <span class="string">`-.__.-&#x27;    _.-&#x27;_.-&#x27;|                                  </span></span><br><span class="line"><span class="string"> |    `</span>-._<span class="string">`-._        _.-&#x27;_.-&#x27;    |           http://redis.io        </span></span><br><span class="line"><span class="string">  `</span>-._    <span class="string">`-._`</span>-.__.-<span class="string">&#x27;_.-&#x27;</span>    _.-<span class="string">&#x27;                                   </span></span><br><span class="line"><span class="string"> |`-._`-._    `-.__.-&#x27;</span>    _.-<span class="string">&#x27;_.-&#x27;</span>|                                  </span><br><span class="line"> |    <span class="string">`-._`</span>-._        _.-<span class="string">&#x27;_.-&#x27;</span>    |                                  </span><br><span class="line">  <span class="string">`-._    `</span>-._<span class="string">`-.__.-&#x27;_.-&#x27;    _.-&#x27;                                   </span></span><br><span class="line"><span class="string">      `</span>-._    <span class="string">`-.__.-&#x27;    _.-&#x27;                                       </span></span><br><span class="line"><span class="string">          `</span>-._        _.-<span class="string">&#x27;                                           </span></span><br><span class="line"><span class="string">              `-.__.-&#x27;</span>                                               </span><br><span class="line"></span><br><span class="line">1:M 29 May 2020 01:16:22.108 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">1:M 29 May 2020 01:16:22.108 # Server initialized</span><br><span class="line">1:M 29 May 2020 01:16:22.108 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#x27;vm.overcommit_memory = 1&#x27; to /etc/sysctl.conf and then reboot or run the command &#x27;sysctl vm.overcommit_memory=1&#x27; for this to take effect.</span><br><span class="line">1:M 29 May 2020 01:16:22.108 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#x27;echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled&#x27; as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line"><span class="number">1</span>:M <span class="number">29</span> May <span class="number">2020</span> <span class="number">01</span>:<span class="number">16</span>:<span class="number">22.108</span> * Ready to accept connections</span><br><span class="line">truedei@truedei:~$ </span><br></pre></td></tr></table></figure>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/07.png" class>

<h2 id="Docker安装MongoDB"><a href="#Docker安装MongoDB" class="headerlink" title="Docker安装MongoDB"></a>Docker安装MongoDB</h2><p>MongoDB 是一个免费的开源跨平台面向文档的 NoSQL 数据库程序。</p>
<h3 id="1、查看可用的-MongoDB-版本"><a href="#1、查看可用的-MongoDB-版本" class="headerlink" title="1、查看可用的 MongoDB 版本"></a>1、查看可用的 MongoDB 版本</h3><p>访问 MongoDB 镜像库地址： <a href="https://hub.docker.com/_/mongo?tab=tags&amp;page=1%E3%80%82">https://hub.docker.com/_/mongo?tab=tags&amp;page=1。</a></p>
<p>可以通过 Sort by 查看其他版本的 MongoDB，默认是最新版本 <strong>mongo:latest</strong>。</p>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/08.png" class>

<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/09.png" class>

<p>此外，我们还可以用  docker search mongo 命令来查看可用版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker search mongo</span></span><br><span class="line">NAME                              DESCRIPTION                      STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mongo                             MongoDB document databases ...   1989      [OK]       </span><br><span class="line">mongo-express                     Web-based MongoDB admin int...   22        [OK]       </span><br><span class="line">mvertes/alpine-mongo              light MongoDB container          19                   [OK]</span><br><span class="line">mongooseim/mongooseim-docker      MongooseIM server the lates...   9                    [OK]</span><br><span class="line">torusware/speedus-mongo           Always updated official Mon...   9                    [OK]</span><br><span class="line">jacksoncage/mongo                 Instant MongoDB sharded cluster  6                    [OK]</span><br><span class="line">mongoclient/mongoclient           Official docker image for M...   4                    [OK]</span><br><span class="line">jadsonlourenco/mongo-rocks        Percona Mongodb with Rocksd...   4                    [OK]</span><br><span class="line">asteris/apache-php-mongo          Apache2.4 + PHP + Mongo + m...   2                    [OK]</span><br><span class="line">19hz/mongo-container              Mongodb replicaset for coreos    1                    [OK]</span><br><span class="line">nitra/mongo                       Mongo3 centos7                   1                    [OK]</span><br><span class="line">ackee/mongo                       MongoDB with fixed Bluemix p...  1                    [OK]</span><br><span class="line">kobotoolbox/mongo                 https://github.com/kobotoolb...  1                    [OK]</span><br><span class="line">valtlfelipe/mongo                 Docker Image based on the la...  1                    [OK]</span><br></pre></td></tr></table></figure>
<h3 id="2、取最新版的-MongoDB-镜像"><a href="#2、取最新版的-MongoDB-镜像" class="headerlink" title="2、取最新版的 MongoDB 镜像"></a>2、取最新版的 MongoDB 镜像</h3><p>这里我们拉取官方的最新版本的镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker pull mongo:latest</span><br></pre></td></tr></table></figure>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/12.png" class>

<h3 id="3、查看本地镜像"><a href="#3、查看本地镜像" class="headerlink" title="3、查看本地镜像"></a>3、查看本地镜像</h3><p>使用以下命令来查看是否已安装了 mongo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/13.png" class>

<h3 id="4、运行容器"><a href="#4、运行容器" class="headerlink" title="4、运行容器"></a>4、运行容器</h3><p>安装完成后，我们可以使用以下命令来运行 mongo 容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -itd --name mongo -p 27017:27017 mongo --auth</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><strong>-p 27017:27017</strong> ：映射容器服务的 27017 端口到宿主机的 27017 端口。外部可以直接通过 宿主机 ip:27017 访问到 mongo 的服务。</li>
<li><strong>–auth</strong>：需要密码才能访问容器服务。</li>
</ul>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/10.png" class>

<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/11.png" class>



<h2 id="Docker安装ElasticSearch"><a href="#Docker安装ElasticSearch" class="headerlink" title="Docker安装ElasticSearch"></a>Docker安装ElasticSearch</h2><h3 id="下载ElasticSearch"><a href="#下载ElasticSearch" class="headerlink" title="下载ElasticSearch"></a>下载ElasticSearch</h3><blockquote>
<p>docker pull elasticsearch:6.8.6</p>
</blockquote>
<h3 id="运行ElasticSearch"><a href="#运行ElasticSearch" class="headerlink" title="运行ElasticSearch"></a>运行ElasticSearch</h3><blockquote>
<p>docker run -d –name elasticsearch -p 9200:9200 -p 9300:9300 -e “discovery.type=single-node”  -e “ES_JAVA_OPTS=-Xms512m -Xmx512m” elasticsearch:6.8.6</p>
</blockquote>
<h3 id="查看正在运行的容器"><a href="#查看正在运行的容器" class="headerlink" title="查看正在运行的容器"></a>查看正在运行的容器</h3><blockquote>
<p>docker ps</p>
</blockquote>
<h3 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h3><p>网页输入：“主机地址:9200”，出现如下json数据，即成功！<strong>同样需要放开端口</strong></p>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/14.png" class>

<h2 id="Docker安装MySQL"><a href="#Docker安装MySQL" class="headerlink" title="Docker安装MySQL"></a>Docker安装MySQL</h2><h3 id="拉取MySQL镜像"><a href="#拉取MySQL镜像" class="headerlink" title="拉取MySQL镜像"></a>拉取MySQL镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql </span><br></pre></td></tr></table></figure>
<h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images </span><br></pre></td></tr></table></figure>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;docker&#x2F;mysql&#x2F;conf.d </span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;home&#x2F;docker&#x2F;mysql&#x2F;data </span><br></pre></td></tr></table></figure>
<p>这两个用于保存配置和数据</p>
<h3 id="创建MySQL容器"><a href="#创建MySQL容器" class="headerlink" title="创建MySQL容器"></a>创建MySQL容器</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">docker run -di -p 3307:3306 -v /home/docker/mysql/conf.d:/etc/mysql/conf.d -v /home/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql mysql</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>-v 映射目录，将容器内的配置与数据文件夹，映射到宿主机目录</p>
<p>-p 代表端口映射，格式为 宿主机映射端口:容器运行端口</p>
<p>-e 代表添加环境变量 MYSQL_ROOT_PASSWORD是root用户的登陆密码</p>
<h3 id="进入MySQL容器"><a href="#进入MySQL容器" class="headerlink" title="进入MySQL容器,"></a>进入MySQL容器,</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mysql &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h3 id="登陆mysql"><a href="#登陆mysql" class="headerlink" title="登陆mysql"></a>登陆mysql</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>输入密码，即可进入mysql，证明安装成功。</p>
<h3 id="打开远程连接"><a href="#打开远程连接" class="headerlink" title="打开远程连接"></a><strong>打开远程连接</strong></h3><p>此时，当使用Navicat远程连接docker容器中的mysql时，会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1251 - Client does not support authentication protocol </span><br></pre></td></tr></table></figure>
<p>这是因为mysql并没有打开远程连接，打开方法如下：</p>
<p>1,容器中登录mysql,查看mysql的版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; status; </span><br></pre></td></tr></table></figure>
<p>mysql Ver 8.0.11 for Linux on x86_64 (MySQL Community Server - GPL) </p>
<p>2,进行授权远程连接(注意mysql 8.0跟之前的授权方式不同)授权</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL ON *.* TO &#39;root&#39;@&#39;%&#39;;  </span><br></pre></td></tr></table></figure>
<p>刷新权限 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges;  </span><br></pre></td></tr></table></figure>
<p>此时,还不能远程访问,因为Navicat只支持旧版本的加密,需要更改mysql的加密规则</p>
<p>更改加密规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;password&#39; PASSWORD EXPIRE NEVER;  </span><br></pre></td></tr></table></figure>
<p>更新root用户密码 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER USER &#39;root&#39;@&#39;%&#39; IDENTIFIED WITH mysql_native_password BY &#39;123456&#39;;  </span><br></pre></td></tr></table></figure>
<p>刷新权限 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; flush privileges;  </span><br></pre></td></tr></table></figure>
<p>OK，设置完成，再次使用 Navicat 连接数据库  </p>
<p>退出mysql数据库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; exit; </span><br></pre></td></tr></table></figure>
<p>退出当前mysql容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit; </span><br></pre></td></tr></table></figure>


<h3 id="优化mysql所用内存"><a href="#优化mysql所用内存" class="headerlink" title="优化mysql所用内存"></a><strong>优化mysql所用内存</strong></h3><p>通过docker查看容器使用内存情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stats </span><br></pre></td></tr></table></figure>
<p>一般情况下，默认装的Mysql是8.0以上，占用内存在350M以上，这个对于小机器来说，占比还是比较大的，可以优化。</p>
<p>进入文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;docker&#x2F;mysql&#x2F;conf.d&#x2F; </span><br></pre></td></tr></table></figure>
<p>查看 .cnf 文件，如果没有，随便新建个，例如 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim my.cnf</span><br></pre></td></tr></table></figure>
<p>输入内容，并保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">performance_schema &#x3D; OFF  </span><br></pre></td></tr></table></figure>
<p>重启mysql 容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart mysql容器的id </span><br></pre></td></tr></table></figure>
<p>再查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker stats </span><br></pre></td></tr></table></figure>


<h3 id="清理linux中buff-cache过大的方法"><a href="#清理linux中buff-cache过大的方法" class="headerlink" title="清理linux中buff/cache过大的方法"></a><strong>清理linux中buff/cache过大的方法</strong></h3><p>第一步：sync先同步一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sync </span><br></pre></td></tr></table></figure>
<p>第二步：清cache</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 3 &gt; &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;drop_caches</span><br></pre></td></tr></table></figure>
<h2 id="Docker安装Nginx和Tomcat"><a href="#Docker安装Nginx和Tomcat" class="headerlink" title="Docker安装Nginx和Tomcat"></a>Docker安装Nginx和Tomcat</h2><h3 id="Docker-pull拉取相关的镜像"><a href="#Docker-pull拉取相关的镜像" class="headerlink" title="Docker pull拉取相关的镜像"></a>Docker pull拉取相关的镜像</h3><img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/15.png" class>

<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/16.png" class>



<h3 id="Docker-run-启动服务器"><a href="#Docker-run-启动服务器" class="headerlink" title="Docker run 启动服务器"></a>Docker run 启动服务器</h3><blockquote>
<p>Docker run -d -p 9090:80 nginx</p>
</blockquote>
<p>后台-d运行一个nginx，并把本地的9090端口映射到nginx的80端口。也可以用<code>docker run -d -P xx</code>用-P来随机映射一个端口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用lsof -i:9090查看端口</span><br></pre></td></tr></table></figure>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/17.png" class>



<blockquote>
<p>Docker run -d -p 8080:80 tomcat</p>
</blockquote>
<p>与docker运行nginx同理。</p>
<blockquote>
<p>对Tomcat编写Dockerfile</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM tomcat  # 启动镜像的名字</span><br><span class="line">MAINTAINER xudong xxd0225@gmail.com # 维护信息</span><br><span class="line">COPY jpress-v3.3.0.war &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps  # 把当前目录的war包copy到tocat的目录下</span><br></pre></td></tr></table></figure>
<img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/18.png" class>

<p>开始制作一个imagesdocker build .这个之多的名字是none， 可以用tag来指定一个名字，注意名字要全部小写。</p>
<blockquote>
<p>docker build -t chasaystest:1.0 .</p>
</blockquote>
<p>然后运行docker run -d -P 80:8080 chasaystest。 这样就可以把tomcat 8080的映射到1234端口。本机用1234就可以访问tomcat端口。<a href="http://localhost:1234/">http://localhost:1234</a></p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/19.png" class>



<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><h4 id="Docker中安装Tomcat外部访问报错404资源未找到"><a href="#Docker中安装Tomcat外部访问报错404资源未找到" class="headerlink" title="Docker中安装Tomcat外部访问报错404资源未找到"></a>Docker中安装Tomcat外部访问报错404资源未找到</h4><p>1.将webapps.dist更名为webapps</p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/20.png" class>



<p>2.将webapps.dist中的内容复制到webapps</p>
 <img data-src="/2021/03/25/%E4%BD%BF%E7%94%A8Docker%E9%83%A8%E7%BD%B2%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/21.png" class>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网刷题-操作系统1</title>
    <url>/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/</url>
    <content><![CDATA[<ul>
<li><p>Windows 操作系统具有较强的存储管理功能，当主存容量不够时系统可以自动地扩充，为应用程序提供一个容量比实际物理主存大得多的存储空间。这种存储管理技术称为**<em>虚拟缓存器技术**</em></p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image01.png" class>

<ul>
<li><p>详细解释</p>
<ul>
<li><p>缓冲区技术，是为了协调吞吐速度相差很大的设置之间数据传送而采用的技术；</p>
</li>
<li><p>虚拟存储器技术，是为应用程序提供一个容量比实际物理主存大得多的存储空间，使当主存容量不够时系统可以自动地扩充的技术；</p>
</li>
<li><p>SPOOLing技术，是低速输入输出设备与主机交换的一种技术，也称为“假脱机真联机”技术</p>
</li>
<li><p>进程调度技术，是负责决定哪个进程投入运行，何时运行以及运行多长时间的技术</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>一个多道批处理系统中仅有 P1 和 P2 两个作业， P2 比 P1 晚 5ms 到达，它们的计算和 I/O 操作顺序如下：</p>
<p>P1 ：计算 60ms ， I/O 80ms ，计算 20ms</p>
<p>P2 ：计算 120ms ， I/O 40ms ，计算 40ms</p>
<p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是 。**<em>（260ms）**</em></p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image02.png" class>



</li>
</ul>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image03.png" class>



<ul>
<li><p>​    在下列文件的物理结构中，不便于增删文件内容的是 <strong><em>连续文件</em></strong></p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image04.png" class>

<ul>
<li><p>详细解释</p>
<ul>
<li><p><strong>连续文件</strong>类似于<strong>数组</strong>，顺序访问速度快，但是增删数据时要移动其他数据块，所以速度很慢；</p>
</li>
<li><p><strong>链接文件</strong>类似于<strong>链表</strong>，随机访问速度慢，增删数据很快，不需要移动数据块，只需要改变指针指向即可；</p>
</li>
<li><p><strong>索引文件</strong>糅合了连续文件和链接文件，但更适合大文件；</p>
</li>
<li><p><strong>Windows使用显式链接文件</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>为提高操作系统自身的可适应性和可扩展性，现代操作系统通过引入和实现( <strong><em>逻辑设备</em></strong>) 的概念而实现了设备独立性。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image05.png" class>
</li>
<li><p>在操作系统中，用户程序申请使用 I/O 设备时，通常采用（ ）。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image06.png" class>

</li>
</ul>
<p>现代操作系统为了提高系统的可适应性和可扩展性，都实现了设备独立性或设备无关性。基本含义是**<em>应用程序独立于具体使用的物理设备，应用程序以逻辑设备名请求使用某类设备**</em>。实现了设备独立性功能可带来两方面的好处：</p>
<p>（1）设备分配时的灵活性；</p>
<p>（2）易于实现I/O 重定向。为了实现设备的独立性，应引入逻辑设备和物理设备概念。在应用程序中，使用逻辑设备名请求使用某类设备；系统执行时是使用物理设备名。鉴于驱动程序是与硬件或设备紧密相关的软件，必须在驱动程序之上设置一层设备独立性软件，<strong>执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换</strong>（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。</p>
<blockquote>
<p>虚拟设备名</p>
</blockquote>
<p>通过<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/4968684">虚拟技术</a>将一台独占设备虚拟成多台逻辑设备，供多个进程同时使用的设备的名字。</p>
<p>虚拟设备技术的作用是提高慢速独占设备的利用率，采用了假脱机技术后—个程序对慢速独占设备的占用时间短了(因为连续了)。</p>
<blockquote>
<p>独占设备名</p>
</blockquote>
<p>独占设备：进程应互斥地访问这类设备，即系统一旦把这类设备分配给了某进程后，便由该进程独占，直到用完释放。典型的独占设备有打印机、磁带机等。系统在分配时，还应考虑到安全性</p>
<ul>
<li><p>现代OS具有并发性和共享性，是由（**<em>多道程序**</em>）的引入而导致的。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image07.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image44.png" class>



</li>
</ul>
<ul>
<li><p>下面的叙述中，（ <strong>节省系统内存</strong>）不是设备管理中引入缓冲机制的主要原因。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image08.png" class>



</li>
</ul>
<ul>
<li><p>若有 4 个进程共享同一程序段，而且每次最多允许 3 个进程进入该程序段，则信号量的变化范围是？</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image09.png" class>

</li>
</ul>
<p>最多允许3个进程进入，所以信号量初值为3，当程序段进入了三个进程后信号量变为0，第四个进程进入时，信号量减为-1。</p>
<ul>
<li><p>下列选项中，不属于进程关键要素的是________。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image10.png" class>

</li>
</ul>
<p>一般来说Linux系统中的进程都具备下列诸要素：</p>
<p>（1）有一段程序供其执行。（程序）</p>
<p>（2）有进程专用的系统堆栈空间。（数据和栈）</p>
<p>（3）在内核有task_struct数据结构。（进程控制块）</p>
<p>（4）有独立的存储空间，拥有专有的用户空间。</p>
<p>如果只具备前面三条而缺第四条，那就称为“线程”。如果完全没有用户空间，就称为“内核线程”；而如果共享用户空间则就称为“用户线程”。</p>
<ul>
<li>临界区是（） </li>
</ul>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image11.png" class>

<p>临界区：每个进程中访问临界资源的那段<strong>程序</strong>叫做临界区。进程对临界区的访问必须互斥，每次只允许一个进程进去临界区，其他进程等待</p>
<ul>
<li><p>在一单处理机系统中，若有4 个用户进程，在某一时刻，处于阻塞状态的用户进程最多有</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image12.png" class>

</li>
</ul>
<p>处于死锁的情况下。</p>
<ul>
<li><p>关于多线程和多线程编程，以下哪些说法正确的（）</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image13.png" class>





</li>
</ul>
<ul>
<li><p>计算机操作系统出现死锁的原因是什么?</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image14.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image15.png" class>





</li>
</ul>
<ul>
<li>同一文件系统中不允许文件同名 , 否则会引起混乱，这种说法正确吗？[<strong><em>错误</em></strong>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件目录结构一般有一级目录结构、二级目录结构和多级目录结构。 一级目录结构的优点是简单，缺点是文件不能重名，限制了用户对文件的命名。 二级目录结构实现了文件从名字空间到外存地址空间的映射：用户名—&gt;文件名à文件内容。其优点是有利于文件的管理、共享和保护；适用于　 多用户系统；不同的用户可以命名相同文件名的文件，不会产生混淆，解决了命名冲突问题。缺点是不能对文件分类；当用文件较多时查找速度慢。</span><br><span class="line">多级目录结构的优点是便于文件分类，可为每类文件建立一个子目录；查找速度快，因为每个目录下的文件数目较少；可以实现文件共享；缺点是比较复杂。</span><br></pre></td></tr></table></figure>


<ul>
<li><p>死锁与安全状态的的关系是</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image16.png" class>

</li>
</ul>
<blockquote>
<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p>
</blockquote>
<ul>
<li><p>一般用户更喜欢使用的系统是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image17.png" class>



</li>
</ul>
<blockquote>
<p>批处理系统</p>
</blockquote>
<p>  处理系统，又名批处理操作系统。<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86/1448600">批处理</a>是指<strong>用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行</strong>。这种采用<a href="https://baike.baidu.com/item/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86/4973973">批量处理</a>作业技术的操作系统称为批处理操作系统。批处理操作系统分为<strong>单道批处理系统和<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/3792844">多道批处理系统</a>**。批处理操作系统</strong>不具有交互性**，它是为了提高CPU的利用率而提出的一种操作系统。</p>
  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">所谓批处理(batch processing )就是将作业按照它们的性质分组（或分批），然后再成组（或成批）地提交给计算机系统，由计算机自动完成后再输出结果，从而减少作业建立和结束过程中的时间浪费。根据在内存中允许存放的作业数，批处理系统又分为单道批处理系统和多道批处理系统。早期的批处理系统属于单道批处理系统，其目的是减少作业间转换时的人工操作，从而减少CPU的等待时间。它的特征是内存中只允许存放一个作业，即当前正在运行的作业才能驻留内存，作业的执行顺序是先进先出，即按顺序执行。</span><br><span class="line">由于在单道批处理系统中，一个作业单独进入内存并独占系统资源，直到运行结束后下一个作业才能进入内存，当作业进行I/O操作时，CPU只能处于等待状态，因此，CPU利用率较低，尤其是对于I/O操作时间较长的作业。为了提高CPU的利用率，在单道批处理系统的基础上引入了多道程序设计（multiprogramming）技术，这就形成了多道批处理系统，即在内存中可同时存在若干道作业，作业执行的次序与进入内存的次序无严格的对应关系，因为这些作业是通过一定的作业调度算法来使用CPU的，一个作业在等待I/O处理时，CPU调度另外一个作业运行，因此CPU的利用率显著地提高了。</span><br><span class="line">批处理系统主要指多道批处理系统，它通常用在以科学计算为主的大中型计算机上，由于多道程序能交替使用CPU，提高了CPU及其他系统资源的利用率，同时也提高了系统的效率。多道批处理系统的缺点是延长了作业的周转时间，用户不能进行直接干预，缺少交互性，不利于程序的开发与调试。</span><br></pre></td></tr></table></figure>
<p>  <strong>操作系统的分类</strong></p>
   <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image18.png" class>



<ul>
<li>我们熟知的Windows XP、Linux、Mac OS X等都是<strong>多用户多任务分时操作系统</strong>，可见这个概念一直延续到了今天。它们最显著的特点就是可以让多个人使用同一台电脑而且不能互相窥探对方的秘密。当你使用电脑的时候可以边听音乐边看新闻，同时还能跟朋友聊天。只要你觉得你的大脑还能处理得过来，你还能让这台电脑同时干更多的事情。其实这类操作系统我们完全可以只用“<strong>分时</strong>”二字简要概述下来。因为“分时”就像它最初的定义那样：将电脑的时间资源适当分配给所有使用者身上，让所有使用者有独占机器的感觉。但是如果把“使者”进行抽象，就不仅可以代表人，还可以将任务也理解为电脑时间资源的使用者，那么<strong>“分时”就是多用户和多任务的基础和前提</strong>。所以，既然是“分时”的，一般都会支持多用户和多任务</li>
</ul>
<ul>
<li><p>能实现紧凑技术的存储管理（ ）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image19.png" class>

</li>
</ul>
<blockquote>
<p>—- 动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，<strong>添加了紧凑功能</strong> <strong>。</strong></p>
<p>—- 通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。</p>
</blockquote>
<blockquote>
<p>存储器管理的对象是主存，也称内存。它的主要功能包括分配和回收主存空间、提高主存利用率、扩充主存、对主存信息实现有效保护。</p>
<p>存储管理方案的主要目的是解决多个用户使用主存的问题，其存储管理方案主要包括<strong>分区存储管理</strong>、<strong>分页存储管理</strong>、<strong>分段存储管理</strong>、<strong>段页式存储管理</strong>以及<strong>虚拟存储管理</strong>。</p>
<p>分区存储管理又有三种不同的方式：<strong>静态分区、可变分区、可重定位分区</strong> 。</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image20.png" class>



<ul>
<li><p>为实现设备分配，应为每一类设备配置一张 。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image21.png" class>

</li>
</ul>
<p>逻辑设备表（LUT）功能是完成逻辑名到物理设备名的映射。</p>
<p>设备分配表（DCT）是，系统为每一个设备配置了一张设备控制表，记录设备的特性以及与设备控制器的连接情况，其中有字段“设备状态”用来表示设备是忙还是闲，“COCT指针”指向与该设备相连接的设备控制器。</p>
<ul>
<li>当计算机系统没有用户执行时，处理机完全处于空闲状态。[<strong><em>错</em></strong>]</li>
</ul>
<blockquote>
<p><strong>系统本身也会有很多状态要维护，会一直处于监听状态。</strong></p>
</blockquote>
<p>​                            </p>
<ul>
<li><p>下列关于总线的说法中正确的是(  )</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image22.png" class>



</li>
</ul>
<ul>
<li><p>A：总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及其控制电路。如果不特别指出，总线一般指代内总线。<br>B：内部总线位于CPU内部，连接各个寄存器和运算器。<br>C：I/O总线是用于连接主机和I/O设备的总线。<br>D：计算机总线中包含内部总线、系统总线（前端总线）、I/O总线。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image23.png" class>





</li>
</ul>
<ul>
<li><p>一个进程执行过程中不可能对应()。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image24.png" class>

</li>
</ul>
<blockquote>
<p>PCB:  Process Control Block 进程控制块</p>
<p>了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97/7205297">进程控制块</a>（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image25.png" class>

<p><strong>进程（Process）和作业（Job）是一个意思，不同书中表述不同，JCB就相当于是PCB。一个进程一个PCB，所以不会对应到多个PCB</strong></p>
<ul>
<li>进程申请不到CPU 时，其状态将变为阻塞状态，这样的说法正确吗 【**<em>错误**</em>】</li>
</ul>
<p>也可能是就绪，其他都准备好了，只差CPU</p>
<ul>
<li><p>“进程一次性申请全部所需资源”通过防止( )条件的出现实现死锁预防</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image26.png" class>

</li>
</ul>
<p><img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220217164051506.png" alt="image-20220217164051506"></p>
<ul>
<li><p>在分时系统中，若当前运行的进程连续获得了两个时间片，原因可能是（ ）</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image27.png" class>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就绪队列为空 </span><br><span class="line">无其他进程需要使用CUP,所以连续分配时间片</span><br></pre></td></tr></table></figure>


<ul>
<li><p>在 段页式存储管理中 ，每个进程拥有多个段表，但只有一张页表。[<strong><em>错误</em></strong>]</p>
</li>
<li><p>需要周期刷新的存储器是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image28.png" class>

<p>考察的是不同<strong>存储器</strong>的功能特点。</p>
<ul>
<li>A选项为<strong>静态随机存取存储器</strong>（Static Random-Access Memory，SRAM）是随机存取存储器的一种。是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。</li>
<li>B选项为<strong>动态随机存取存储器</strong>(Dynamic Random Access Memory，DRAM)最为常见的系统内存。<strong>DRAM的存储位元是基于电容器的电荷量存储，这个电荷量会随着时间和温度而减少，因此必须定期的刷新，以保持它们原来记忆的正确信息。对DRAM的所有存储单元恢复一次原状态的时间间隔，叫做刷新周期。</strong></li>
<li>C选项<strong>只读存储器</strong>(Read-Only Memory，ROM)所存数据稳定 ，断电后所存数据也不会改变；其结构较简单，读出较方便，因而常用于存储各种固定程序和数据。</li>
<li>D选项属于<strong>静态存储器的原理</strong>，即靠双稳态触发器的两个稳定状态保存信息</li>
</ul>
</li>
</ul>
<ul>
<li><p>实现虚拟存储的目的是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image29.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image30.png" class>



</li>
</ul>
<ul>
<li>解决死锁问题通常意味着牺牲资源的效率   【**<em>正确**</em>】</li>
</ul>
<blockquote>
<p>解决死锁通常是释放部分进程资源，故牺牲了资源的效率</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">破坏死锁的方法包括： 1. 破坏互斥条件，如果系统资源都能共享，则不会死锁--但由于打印机等资源显然不能被共享，该方法不好。 2. 破坏请求并保持条件，预先分配全部资源，运行时才投入使用，并一直独享，系统资源被浪费。 3. 破坏不可剥夺条件，保持不可剥夺资源的进程，在请求新资源未被满足时，必须先释放保持的资源，需要时重新申请，反复申请和释放增加了开销。 4. 破坏循环等待条件，采用顺序资源分配，用编号分配资源，按次序操作会造成浪费。</span><br></pre></td></tr></table></figure>


<ul>
<li><p>存放在磁盘上的文件</p>
<blockquote>
<p>即可随机访问，又可顺序访问</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>位示图可用于()</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image31.png" class>

</li>
</ul>
<p>操作系统管理空闲存储空间的方法：位示图法【**<em>0表示空闲，1表示已经分配**</em>】、空闲区表法、空闲链表法以及成组链接法</p>
<ul>
<li><p>在 Word 中，执行打开文件 C:\a.doc 操作，是将 <strong><strong>____</strong></strong></p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image32.png" class>

</li>
</ul>
<blockquote>
<p>C盘是硬盘，A盘和B盘都是软盘；我们现在说的内存一般都是RAM，而ROM也可以做内存，只不过是Read Only的(只能写一次)，通常用来存储BIOS程序，断电后内容还在。</p>
</blockquote>
<ul>
<li><p>单道程序系统中程序的执行也需要同步和互斥 【**<em>错**</em>】</p>
<ul>
<li><p>详细解释</p>
<ul>
<li><p><strong>1. 资源独占性</strong></p>
<p>任何时候，位于内存中的程序可以使用系统中的一切资源，不可能有其他程序与之竞争</p>
<p><strong>2. 执行的顺序性</strong></p>
<p>内存中只有一个程序，各个程序是按次序执行的。在做完一个程序的过程中，不可能夹杂进另一个程序执行</p>
<p> <strong>3. 结果的可再现性</strong></p>
<p>只要执行环境和初始条件相同，重复执行一个程序，获得的结果总是一样的</p>
<p> <strong>4. 运行结果的无关性</strong></p>
<p>程序的运行结果与程序执行的速度无关。系统中的作业以串行的方式被处理，无法提高CPU、内存的利用率</p>
<p>本来就是有序的，故不需要同步互斥</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>目录在linux文件系统中是以怎样的形式存在的？</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image33.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image34.png" class>







</li>
</ul>
<ul>
<li><p>使用下面那些存储管理方法可以实现虚拟存储？【**<em>BCD**</em>】</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image35.png" class>

</li>
</ul>
<blockquote>
<p>虚拟存储器的实现方法：<br>1、分页请求系统<br>2、分段请求系统<br>3、两种方式的结合</p>
</blockquote>
<p>而分区分配是指为如何用户程序分配内存空间的策略</p>
<p>分区是为用户程序<strong>分配内存</strong>的策略，不是<strong>虚拟存储</strong>的实现方法。</p>
<ul>
<li><p>假设某系统共有10台磁带机，有三个进程P1，P2，P3对磁带机的需求量分别是8，6，4台。设在T0时刻P1，P2，P3已分别获得3，4，1台，于是在T0时刻后存在的安全序列为（ **?**）。</p>
</li>
<li><p>```<br>（P1，P2，P3）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  （P3，P2，P1）</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>（P2，P3，P1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  （P2，P1，P3）</span><br></pre></td></tr></table></figure></li>
<li><pre><code>（P1，P3，P2）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 关于进程和线程，下列说法正确的是____</span><br><span class="line"></span><br><span class="line"> &#123;%asset_image image36.png%&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;txt</span><br><span class="line">A：进程是资源分配和拥有的单位</span><br><span class="line">C：线程是处理机调度和分配的单位</span><br><span class="line">B：进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</span><br><span class="line">E：每个线程拥有自己的堆栈，和自己的寄存器上下文</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<ul>
<li>两个线程并发执行以下代码，假设a是全局变量，初始值是1，那么以下输出中（）是可能的。</li>
</ul>
<blockquote>
<p>void<code> </code>foo ( )<br>{<br><code>++a; </code>printf<code>(</code>“%d”``,a);<br>}</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image37.png" class>

<blockquote>
<p>假设线程x和y同时执行，x和y可随时被抢占，a的初始值为1</p>
<p>A：3, 2<br>y先执行++a，a为2;<br>y再执行printf，a入栈，在打印到终端之前切换到x<br>x执行＋＋a，a为3;<br>x执行printf，输出3;再切换到y<br>y执行打印，输出2</p>
<p>B：2 3<br>x先执行＋＋a，a为2;<br>x再执行printf，输出2;切换到y<br>y执行＋＋a，a为3;<br>y执行printf，输出3;</p>
<p>C：3 3<br>x先执行＋＋a，a为2;切换到y<br>y执行＋＋a，a为3;<br>y执行printf，输出3;切换到x<br>x执行printf，输出3</p>
<p>D：2 2<br>类似C， 执行++a操作但没有写回到内存</p>
<p>这里关键有两点：<br>（1)两个线程可*<strong>随时被抢占***<br>（2)＋＋a和printf<strong>不是原子指令</strong>，可随时被打断；特别注意函数printf，a作为参数压栈后，*</strong>a再变化则不会影响输出*<strong>（printf实际打印的是压栈的参数，是值**<em>拷贝</em></strong>的栈变量）</p>
</blockquote>
<ul>
<li><p>以下关于Linux操作系统内存的描述中，正确的有（)</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image38.png" class>

<ul>
<li><p>A.<a href="%E8%8B%A5%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%BA2GB%EF%BC%8C%E5%88%99%E5%9C%A8%E8%AF%A5%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8BA%E5%92%8C%E8%BF%9B%E7%A8%8BB%E6%89%80%E5%8D%A0%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B9%8B%E5%92%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E5%A4%A7%E4%BA%8E2GB">点击访问</a>   32位下windows大概2g，而Linux3G，其余的都是给了内核【**<em>注意题中说是用户态地址空间**</em>】</p>
</li>
<li><p>B. [ <strong><em>?</em></strong> ]</p>
<blockquote>
<p>进程A和B都有自己的虚拟地址，程序在运行的时候在一个特定的时候并不会把所有需要的数据都加载到内存中，当前不使用的数据会被置换到硬盘上，只有在使用的时候才会被置换到内存中。因此，两个进程所占的物理存储之和完全有可能大于2GB。例如当进程A和B同时运行的时候，都只有部分数据被加载到内存中，假设在某一时刻A和B进程占用内存之和为2GB，如果此时A所需的数据不在内存中，此时系统采用特定的算法把进程A与B当前可能不使用的数据置换到硬盘上。因此，选项B正确。</p>
</blockquote>
</li>
<li><p>申请了1GB的内存，不一定会全部占用</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>下列软件中，属于系统软件的是（）。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image39.png" class>

</li>
</ul>
<blockquote>
<p>软件系统主要包括系统软件和应用软件。办公自动化软件、管理信息系统、指挥信息系统都是属于应用软件， Windows XP 属于系统软件，因此答案选择 B 。</p>
</blockquote>
<ul>
<li><p>进程A、B共享变量x，需要互斥执行；进程B、C共享变量y，B、C也需要互斥执行，因此进程A、C必须互斥执行    【错】</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在操作系统中，互斥没有传递性。在题目中，AC不存在资源竞争，以为着不需要互斥</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>( ) 被称为文本文件或 ACSII 文件。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image40.png" class>

</li>
</ul>
<blockquote>
<p>exe 可执行文件  软件一般有这样的应用程序</p>
<p>txt  文本文件 </p>
<p>doc  word 文本格式</p>
<p>com  可执行文件的内存映像</p>
</blockquote>
<ul>
<li><p>从执行状态挂起的进程解除挂起时进入()状态。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image41.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image42.png" class>



</li>
</ul>
<ul>
<li><p>采用动态重定位方式装入作业，在执行中允许（）将其移走</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image43.png" class>

</li>
</ul>
<blockquote>
<p><strong>动态重定位装入方式</strong>：</p>
<p>其运行环境：多道程序环境；</p>
<p>程序在运行过程中在内存的位置可能变动，装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正执行时才进行。说白了，动态重定位装入方式，是在程序执行时由CPU硬件进行地址重定位。</p>
<p>特点：程序在内存中可以浮动，不要求整个应用程序占用连续控件；为使地址转换不影响指令的执行速度，需要一个重定位寄存器的支持。</p>
<p>动态重定位分区分配是 内存为程序分配空间的一种分配方式。 可以将内存块进行搬移，将小块拼成大块，将小空闲“紧凑”成大空闲，腾出较大的内存以容纳新的程序进程。可以减少“碎片”，当然这种条件是**<em>系统完成的，并不是用户**</em>。</p>
</blockquote>
<blockquote>
<p><strong>可重定位装入方式</strong>：</p>
<p>运行环境：多道程序环境</p>
<p>程序目标模块的起始地址通常是从0开始的，程序中的其他地址也都是相对于起始地址计算的；根据内存的当前情况，将装入模块装入到内幕才能的适当位子；地址变换通常是装入时一次完成的，以后不再改变，所以是静态重定位。</p>
<p>特点：无需硬件支持；程序不能在内存中移动；要求程序的存储空间是连续的，不能把程序放在若干不连续区域</p>
<p><strong>绝对装入方式</strong>：</p>
<p>环境：使用单批道程序环境</p>
<p>绝对装入需要实现知道程序驻留在内存的位置，程序按照装入模块中的地址，将程序和数据装入内存。所以程序中的逻辑地址与实际地址完全相同，当操作系统把程序装入内存时，不需要对程序和数据进行地址修改；</p>
<p>特点：是CPU执行目标代码块，由于内存大小的限制，能装入内存并发执行的进程数大大减少。</p>
</blockquote>
<ul>
<li>在请求式分页系统中，缺页的中断率与程序结构无关。最短 CPU 执行期优先算法一定是剥夺式的。 【 <strong><em>false</em></strong> 】</li>
</ul>
<blockquote>
<p>第一个问题：false</p>
<p><strong>请求式分页</strong>也称虚拟页式存储管理，在进程开始运行之前不是装入全部页面，而是装入一个或零个页面之后根据进程运行的需要动态装入其他页面。</p>
<p>查页表时，当状态位指示该页不在主存时，则引起一个<strong>缺页中断</strong>发生，相应的中断程序把控制转向缺页中断子程序。————–<strong><em>缺页的中断率与程序结构有关</em></strong></p>
<h4 id="缺页中断率的因素有："><a href="#缺页中断率的因素有：" class="headerlink" title="缺页中断率的因素有："></a><strong>缺页中断率的因素有</strong>：</h4><p>①分配给作业的主存块数多则缺页率低，反之缺页中断率就高。<br>②页面大，缺页中断率低；页面小缺页中断率高。<br>③程序编制方法。以数组运算为例，如果每一行元素存放在一页中，则按行处理各元素缺页中断率低；反之，按列处理各元素，则缺页中断率高。<br>④页面调度算法对缺页中断率影响很大，但不可能找到一种最佳算法。</p>
<h4 id="第二个问题：false"><a href="#第二个问题：false" class="headerlink" title="第二个问题：false"></a><strong>第二个问题：false</strong></h4><h3 id="短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式"><a href="#短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式" class="headerlink" title="短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式"></a>短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式</h3><ul>
<li><strong>非抢占式（非剥夺式）调度</strong>：一旦进程拥有了CPU，只有当该CPU脉冲时间结束才会让出CPU的控制权。</li>
<li><strong>抢占式（剥夺式）调度</strong>：当有比当前进程剩余时间片更短的进程到来时，新来的进程抢占当前进程获得CPU运行。这种方式也被称为最短剩余时间优先调度（SRTF）。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>设计消息队列--&gt;1</title>
    <url>/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>明确了消息队列的使用场景，下一步就是如何设计与实现一个消息队列了。</p>
 <img data-src="/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/01.png" class>

<p>基于消息的系统模型，不一定需要broker(消息队列服务端)。市面上的的Akka（actor模型）、ZeroMQ等，其实都是基于消息的系统设计范式，但是没有broker。 我们之所以要设计一个消息队列，并且配备broker，无外乎要做两件事情：</p>
<blockquote>
<p>消息的转储，在更合适的时间点投递，或者通过一系列手段辅助消息最终能送达消费机。</p>
</blockquote>
<blockquote>
<p>规范一种范式和通用的模式，以满足解耦、最终一致性、错峰等需求。 掰开了揉碎了看，最简单的消息队列可以做成一个消息转发器，把一次RPC做成两次RPC。发送者把消息投递到服务端（以下简称broker），服务端再将消息转发一手到接收端，就是这么简单。</p>
</blockquote>
<p>一般来讲，设计消息队列的整体思路是先build一个整体的数据流,例如producer发送给broker,broker发送给consumer,consumer回复消费确认，broker删除/备份消息等。 利用RPC将数据流串起来。然后考虑RPC的高可用性，尽量做到无状态，方便水平扩展。 之后考虑如何承载消息堆积，然后在合适的时机投递消息，而处理堆积的最佳方式，就是存储，存储的选型需要综合考虑性能/可靠性和开发维护成本等诸多因素。 为了实现广播功能，我们必须要维护消费关系，可以利用zk/config server等保存消费关系。 在完成了上述几个功能后，消息队列基本就实现了。然后我们可以考虑一些高级特性，如可靠投递，事务特性，性能优化等。 下面我们会以设计消息队列时重点考虑的模块为主线，穿插灌输一些消息队列的特性实现方法，来具体分析设计实现一个消息队列时的方方面面。</p>
<img data-src="/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/02.png" class>

<h2 id="实现队列基本功能"><a href="#实现队列基本功能" class="headerlink" title="实现队列基本功能"></a>实现队列基本功能</h2><h3 id="RPC通信协议"><a href="#RPC通信协议" class="headerlink" title="RPC通信协议"></a>RPC通信协议</h3><p>所谓消息队列，无外乎两次RPC加一次转储，当然需要消费端最终做消费确认的情况是三次RPC。既然是RPC，就必然牵扯出一系列话题，什么负载均衡啊、服务发现啊、通信协议啊、序列化协议啊，等等。在这一块，我的强烈建议是不要重复造轮子。利用公司现有的RPC框架：Thrift也好，Dubbo也好，或者是其他自定义的框架也好。因为消息队列的RPC，和普通的RPC没有本质区别。当然了，自主利用Memchached或者Redis协议重新写一套RPC框架并非不可（如MetaQ使用了自己封装的Gecko NIO框架，卡夫卡也用了类似的协议）。但实现成本和难度无疑倍增。排除对效率的极端要求，都可以使用现成的RPC框架。 简单来讲，服务端提供两个RPC服务，一个用来接收消息，一个用来确认消息收到。并且做到不管哪个server收到消息和确认消息，结果一致即可。当然这中间可能还涉及跨IDC的服务的问题。这里和RPC的原则是一致的，尽量优先选择本机房投递。你可能会问，如果producer和consumer本身就在两个机房了，怎么办？首先，broker必须保证感知的到所有consumer的存在。其次，producer尽量选择就近的机房就好了。</p>
<img data-src="/2021/03/13/%E8%AE%BE%E8%AE%A1%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/03.png" class>

<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p> 其实所有的高可用，是依赖于RPC和存储的高可用来做的。先来看RPC的高可用，美团的基于MTThrift的RPC框架，阿里的Dubbo等，其本身就具有服务自动发现，负载均衡等功能。而消息队列的高可用，只要保证broker接受消息和确认消息的接口是幂等的，并且consumer的几台机器处理消息是幂等的，这样就把消息队列的可用性，转交给RPC框架来处理了。 那么怎么保证幂等呢？最简单的方式莫过于共享存储。broker多机器共享一个DB或者一个分布式文件/kv系统，则处理消息自然是幂等的。就算有单点故障，其他节点可以立刻顶上。另外failover可以依赖定时任务的补偿，这是消息队列本身天然就可以支持的功能。存储系统本身的可用性我们不需要操太多心，放心大胆的交给DBA们吧！ 对于不共享存储的队列，如Kafka使用分区加主备模式，就略微麻烦一些。需要保证每一个分区内的高可用性，也就是每一个分区至少要有一个主备且需要做数据的同步，关于这块HA的细节，可以参考下篇pull模型消息系统设计。</p>
<h3 id="服务端承载消息堆积的能力"><a href="#服务端承载消息堆积的能力" class="headerlink" title="服务端承载消息堆积的能力"></a>服务端承载消息堆积的能力</h3><p>消息到达服务端如果不经过任何处理就到接收者了，broker就失去了它的意义。为了满足我们错峰/流控/最终可达等一系列需求，把消息存储下来，然后选择时机投递就显得是顺理成章的了。 只是这个存储可以做成很多方式。比如存储在内存里，存储在分布式KV里，存储在磁盘里，存储在数据库里等等。但归结起来，主要有持久化和非持久化两种。 持久化的形式能更大程度地保证消息的可靠性（如断电等不可抗外力），并且理论上能承载更大限度的消息堆积（外存的空间远大于内存）。 但并不是每种消息都需要持久化存储。很多消息对于投递性能的要求大于可靠性的要求，且数量极大（如日志）。这时候，消息不落地直接暂存内存，尝试几次failover，最终投递出去也未尝不可。 市面上的消息队列普遍两种形式都支持。当然具体的场景还要具体结合公司的业务来看。</p>
<h3 id="存储子系统的选择"><a href="#存储子系统的选择" class="headerlink" title="存储子系统的选择"></a>存储子系统的选择</h3><p>我们来看看如果需要数据落地的情况下各种存储子系统的选择。理论上，从速度来看，文件系统&gt;分布式KV（持久化）&gt;分布式文件系统&gt;数据库，而可靠性却截然相反。还是要从支持的业务场景出发作出最合理的选择，如果你们的消息队列是用来支持支付/交易等对可靠性要求非常高，但对性能和量的要求没有这么高，而且没有时间精力专门做文件存储系统的研究，DB是最好的选择。 但是DB受制于IOPS，如果要求单broker 5位数以上的QPS性能，基于文件的存储是比较好的解决方案。整体上可以采用数据文件+索引文件的方式处理，具体这块的设计比较复杂，可以参考下篇的存储子系统设计。 分布式KV（如MongoDB，HBase）等，或者持久化的Redis，由于其编程接口较友好，性能也比较可观，如果在可靠性要求不是那么高的场景，也不失为一个不错的选择。</p>
<h3 id="消费关系解析"><a href="#消费关系解析" class="headerlink" title="消费关系解析"></a>消费关系解析</h3><p>现在我们的消息队列初步具备了转储消息的能力。下面一个重要的事情就是解析发送接收关系，进行正确的消息投递了。 市面上的消息队列定义了一堆让人晕头转向的名词，如JMS 规范中的Topic/Queue，Kafka里面的Topic/Partition/ConsumerGroup，RabbitMQ里面的Exchange等等。抛开现象看本质，无外乎是单播与广播的区别。所谓单播，就是点到点；而广播，是一点对多点。当然，对于互联网的大部分应用来说，组间广播、组内单播是最常见的情形。 消息需要通知到多个业务集群，而一个业务集群内有很多台机器，只要一台机器消费这个消息就可以了。 当然这不是绝对的，很多时候组内的广播也是有适用场景的，如本地缓存的更新等等。另外，消费关系除了组内组间，可能会有多级树状关系。这种情况太过于复杂，一般不列入考虑范围。所以，一般比较通用的设计是支持组间广播，不同的组注册不同的订阅。组内的不同机器，如果注册一个相同的ID，则单播；如果注册不同的ID(如IP地址+端口)，则广播。 至于广播关系的维护，一般由于消息队列本身都是集群，所以都维护在公共存储上，如config server、zookeeper等。维护广播关系所要做的事情基本是一致的:</p>
<ol>
<li>发送关系的维护。</li>
<li>发送关系变更时的通知。</li>
</ol>
<h2 id="队列高级特性设计"><a href="#队列高级特性设计" class="headerlink" title="队列高级特性设计"></a>队列高级特性设计</h2><p>上面都是些消息队列基本功能的实现，下面来看一些关于消息队列特性相关的内容，不管可靠投递/消息丢失与重复以及事务乃至于性能，不是每个消息队列都会照顾到，所以要依照业务的需求，来仔细衡量各种特性实现的成本，利弊，最终做出最为合理的设计。</p>
<h3 id="可靠投递（最终一致性）"><a href="#可靠投递（最终一致性）" class="headerlink" title="可靠投递（最终一致性）"></a>可靠投递（最终一致性）</h3><p>完全不丢消息，究竟可不可能？答案是，完全可能，前提是消息可能会重复，并且，在异常情况下，要接受消息的延迟。 方案说简单也简单，就是每当要发生不可靠的事情（RPC等）之前，先将消息落地，然后发送。当失败或者不知道成功失败（比如超时）时，消息状态是待发送，定时任务不停轮询所有待发送消息，最终一定可以送达。 具体来说：</p>
<blockquote>
<p>producer往broker发送消息之前，需要做一次落地。</p>
</blockquote>
<blockquote>
<p>请求到server后，server确保数据落地后再告诉客户端发送成功。</p>
</blockquote>
<blockquote>
<p>支持广播的消息队列需要对每个待发送的endpoint，持久化一个发送状态，直到所有endpoint状态都OK才可删除消息。</p>
</blockquote>
<p>对于各种不确定（超时、down机、消息没有送达、送达后数据没落地、数据落地了回复没收到），其实对于发送方来说，都是一件事情，就是消息没有送达。 重推消息所面临的问题就是消息重复。重复和丢失就像两个噩梦，你必须要面对一个。好在消息重复还有处理的机会，消息丢失再想找回就难了。 Anyway，作为一个成熟的消息队列，应该尽量在各个环节减少重复投递的可能性，不能因为重复有解决方案就放纵的乱投递。 最后说一句，不是所有的系统都要求最终一致性或者可靠投递，比如一个论坛系统、一个招聘系统。一个重复的简历或话题被发布，可能比丢失了一个发布显得更让用户无法接受。不断重复一句话，任何基础组件要服务于业务场景。</p>
<h3 id="消费确认"><a href="#消费确认" class="headerlink" title="消费确认"></a>消费确认</h3><p>当broker把消息投递给消费者后，消费者可以立即响应我收到了这个消息。但收到了这个消息只是第一步，我能不能处理这个消息却不一定。或许因为消费能力的问题，系统的负荷已经不能处理这个消息；或者是刚才状态机里面提到的消息不是我想要接收的消息，主动要求重发。 把消息的送达和消息的处理分开，这样才真正的实现了消息队列的本质-解耦。所以，允许消费者主动进行消费确认是必要的。当然，对于没有特殊逻辑的消息，默认Auto Ack也是可以的，但一定要允许消费方主动ack。 对于正确消费ack的，没什么特殊的。但是对于reject和error，需要特别说明。reject这件事情，往往业务方是无法感知到的，系统的流量和健康状况的评估，以及处理能力的评估是一件非常复杂的事情。举个极端的例子，收到一个消息开始build索引，可能这个消息要处理半个小时，但消息量却是非常的小。所以reject这块建议做成滑动窗口/线程池类似的模型来控制， 消费能力不匹配的时候，直接拒绝，过一段时间重发，减少业务的负担。 但业务出错这件事情是只有业务方自己知道的，就像上文提到的状态机等等。这时应该允许业务方主动ack error，并可以与broker约定下次投递的时间。</p>
<h3 id="重复消息和顺序消息"><a href="#重复消息和顺序消息" class="headerlink" title="重复消息和顺序消息"></a>重复消息和顺序消息</h3><p>上文谈到重复消息是不可能100%避免的，除非可以允许丢失，那么，顺序消息能否100%满足呢? 答案是可以，但条件更为苛刻：</p>
<ol>
<li>允许消息丢失。</li>
<li>从发送方到服务方到接受者都是单点单线程。</li>
</ol>
<p>所以绝对的顺序消息基本上是不能实现的，当然在METAQ/Kafka等pull模型的消息队列中，单线程生产/消费，排除消息丢失，也是一种顺序消息的解决方案。 一般来讲，一个主流消息队列的设计范式里，应该是不丢消息的前提下，尽量减少重复消息，不保证消息的投递顺序。 谈到重复消息，主要是两个话题：</p>
<ol>
<li>如何鉴别消息重复，并幂等的处理重复消息。</li>
<li>一个消息队列如何尽量减少重复消息的投递。</li>
</ol>
<p>先来看看第一个话题，每一个消息应该有它的唯一身份。不管是业务方自定义的，还是根据IP/PID/时间戳生成的MessageId，如果有地方记录这个MessageId，消息到来是能够进行比对就 能完成重复的鉴定。数据库的唯一键/bloom filter/分布式KV中的key，都是不错的选择。由于消息不能被永久存储，所以理论上都存在消息从持久化存储移除的瞬间上游还在投递的可能（上游因种种原因投递失败，不停重试，都到了下游清理消息的时间）。这种事情都是异常情况下才会发生的，毕竟是小众情况。两分钟消息都还没送达，多送一次又能怎样呢？幂等的处理消息是一门艺术，因为种种原因重复消息或者错乱的消息还是来到了，说两种通用的解决方案： 1. 版本号。 2. 状态机。</p>
<h4 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h4><p>举个简单的例子，一个产品的状态有上线/下线状态。如果消息1是下线，消息2是上线。不巧消息1判重失败，被投递了两次，且第二次发生在2之后，如果不做重复性判断，显然最终状态是错误的。 但是，如果每个消息自带一个版本号。上游发送的时候，标记消息1版本号是1，消息2版本号是2。如果再发送下线消息，则版本号标记为3。下游对于每次消息的处理，同时维护一个版本号。 每次只接受比当前版本号大的消息。初始版本为0，当消息1到达时，将版本号更新为1。消息2到来时，因为版本号&gt;1.可以接收，同时更新版本号为2.当另一条下线消息到来时，如果版本号是3.则是真实的下线消息。如果是1，则是重复投递的消息。 如果业务方只关心消息重复不重复，那么问题就已经解决了。但很多时候另一个头疼的问题来了，就是消息顺序如果和想象的顺序不一致。比如应该的顺序是12，到来的顺序是21。则最后会发生状态错误。 参考TCP/IP协议，如果想让乱序的消息最后能够正确的被组织，那么就应该只接收比当前版本号大一的消息。并且在一个session周期内要一直保存各个消息的版本号。 如果到来的顺序是21，则先把2存起来，待1到来后，先处理1，再处理2，这样重复性和顺序性要求就都达到了。</p>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><p>基于版本号来处理重复和顺序消息听起来是个不错的主意，但凡事总有瑕疵。使用版本号的最大问题是：</p>
<ol>
<li>对发送方必须要求消息带业务版本号。</li>
<li>下游必须存储消息的版本号，对于要严格保证顺序的。</li>
</ol>
<p>还不能只存储最新的版本号的消息，要把乱序到来的消息都存储起来。而且必须要对此做出处理。试想一个永不过期的”session”，比如一个物品的状态，会不停流转于上下线。那么中间环节的所有存储 就必须保留，直到在某个版本号之前的版本一个不丢的到来，成本太高。 就刚才的场景看，如果消息没有版本号，该怎么解决呢？业务方只需要自己维护一个状态机，定义各种状态的流转关系。例如，”下线”状态只允许接收”上线”消息，“上线”状态只能接收“下线消息”，如果上线收到上线消息，或者下线收到下线消息，在消息不丢失和上游业务正确的前提下。要么是消息发重了，要么是顺序到达反了。这时消费者只需要把“我不能处理这个消息”告诉投递者，要求投递者过一段时间重发即可。而且重发一定要有次数限制，比如5次，避免死循环，就解决了。 举例子说明，假设产品本身状态是下线，1是上线消息，2是下线消息，3是上线消息，正常情况下，消息应该的到来顺序是123，但实际情况下收到的消息状态变成了3123。 那么下游收到3消息的时候，判断状态机流转是下线-&gt;上线，可以接收消息。然后收到消息1，发现是上线-&gt;上线，拒绝接收，要求重发。然后收到消息2，状态是上线-&gt;下线，于是接收这个消息。 此时无论重发的消息1或者3到来，还是可以接收。另外的重发，在一定次数拒绝后停止重发，业务正确。</p>
<h3 id="中间件对于重复消息的处理"><a href="#中间件对于重复消息的处理" class="headerlink" title="中间件对于重复消息的处理"></a>中间件对于重复消息的处理</h3><p>回归到消息队列的话题来讲。上述通用的版本号/状态机/ID判重解决方案里，哪些是消息队列该做的、哪些是消息队列不该做业务方处理的呢？其实这里没有一个完全严格的定义，但回到我们的出发点，我们保证不丢失消息的情况下尽量少重复消息，消费顺序不保证。那么重复消息下和乱序消息下业务的正确，应该是由消费方保证的，我们要做的是减少消息发送的重复。 我们无法定义业务方的业务版本号/状态机，如果API里强制需要指定版本号，则显得过于绑架客户了。况且，在消费方维护这么多状态，就涉及到一个消费方的消息落地/多机间的同步消费状态问题，复杂度指数级上升，而且只能解决部分问题。 减少重复消息的关键步骤：</p>
<ol>
<li>broker记录MessageId，直到投递成功后清除，重复的ID到来不做处理，这样只要发送者在清除周期内能够感知到消息投递成功，就基本不会在server端产生重复消息。</li>
<li>对于server投递到consumer的消息，由于不确定对端是在处理过程中还是消息发送丢失的情况下，有必要记录下投递的IP地址。决定重发之前询问这个IP，消息处理成功了吗？如果询问无果，再重发。</li>
</ol>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度</title>
    <url>/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h1> <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image01.png" class>



<p>调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。进程调度程序(常常简称调度程序)可看做在可运行态进程之间分配有限的**<em>处理器时间资源的内核子系统**</em>。调度程序是像Linux这样的多任务操作系统的基础。只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。 </p>
<blockquote>
<p>在一组处于可运行状态的进程中选择一个来执行，是调度程序所需完成的基本工作,最大程度的利用处理器时间为原则。</p>
</blockquote>
<h2 id="多任务操作系统"><a href="#多任务操作系统" class="headerlink" title="多任务操作系统"></a>多任务操作系统</h2><p>多任务操作系统就是能同时并发地交互执行多个进程的操作系统。在单处理器机器上，这会产生多个进程在同时运行的幻觉。在多处理器机器上，这会使多个进程在不同的处理机上真正同时、并行地运行。无论在单处理器或者多处理器机器上，多任务操作系统都能使多个进程处堵塞或者睡眠状态，</p>
<p>多任务系统可以划分为两类：</p>
<blockquote>
<p>非抢占式多任务(cooperative multitasking)</p>
</blockquote>
<p>在非抢占式多任务模式下，除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作称为让步(yielding)。理想情况下，进程通常做出让步，以便让每个可运行进程享有足够的处理器时间。但这种机制有很多缺点：调度程序无法对每个进程该执行多长时间做出统一规定，所以进程独占的处理器时间可能超出用户的预料；更糟的是，一个决不做出让步的悬挂进程就能使系统崩溃。</p>
<blockquote>
<p>抢占式多任务(preemptive multitasking)</p>
</blockquote>
<p>由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会。这个*<strong>强制的挂起动作就叫做抢占(preemption)**<em>。进程在被抢占之前能够运行的时间是预先设置好的，而且有一个专门的名字，叫</em></strong>进程的时间片(timeslice)***。时间片实际上是分配给每个可运行进程的处理器时间段。有效管理时间片能使调度程序从系统全局的角度做出调度决定，这样做还可以避免个别进程独占系统资源</p>
<h2 id="Linux进程调度-1"><a href="#Linux进程调度-1" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h2><p>开始采用了一种叫做<strong>O(1)*<em>调度程序的新调度程序一一它是因为其算法的行为而得名，0(1)调度程序虽然对于大服务器的工作负载很理想，但是在有很多交互程序要运行的桌面系统上则表现不佳，因为**</em>其缺少交互进程*</strong></p>
<p>自2.6内核系统开发初期，开发人员为了提高对交 互程序的调度性能引入了新的进程调度算法。其中最为著名的是“**<em>反转楼梯最后期限调度算法(Rotating Staircase Deadline scheduler(RSDL)**</em>,该算法吸取了队列理论，将公平调度的概念引入了 Linux调度程序。并且最终在2623内核版本中替代了 0(1)调度算法，它此刻被称为“完全公平调度算法”，或者简称<strong>CFS</strong></p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="根据进程分类确定策略"><a href="#根据进程分类确定策略" class="headerlink" title="根据进程分类确定策略"></a>根据进程分类确定策略</h3><blockquote>
<p>进程可以被分为I/O消耗型和处理器消耗型。</p>
</blockquote>
<ul>
<li><p>IO消耗型</p>
<p>指进程的<strong>大部分时间用来提交I/O请求或是等待I/O请求</strong>。因此，这样的进程经常处于可运行状态，但通常都是**<em>运行短短的一会儿**</em>，因为它在等待更多的I/O请求时总会阻塞</p>
<p>举例来说，多数用户图形界面程序（GUI）都属于I/O密集型，即便它们从不读取或者写入磁盘，它们也会在多数时间里都在等待来自鼠标或者键盘的用户交互操作。</p>
<img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image02.png" class>



</li>
</ul>
<ul>
<li><p>处理器耗费型(用于计算)</p>
<p>处理器耗费型进程把时间大多用在执行代码上。除非被抢占，否则它们通常都一直不停地运行，因为它们没有太多的I/O需求。但是，因为它们不属于I/O驱动类型，所以从系统响应速度考虑，调度器不应该经常让它们运行。对于这类处理器消耗型的进程，调度策略往往是**<em>尽量降低它们的调度频率，而延长其运行时间**</em>。</p>
<img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image03.png" class>

</li>
</ul>
<p>有必要指出，随着CPU变得越来越快*<strong>，更多的进程倾向为I/O密集型**<em>。这种现象之所以发生是因为</em></strong>CPU 的改进比磁盘的改进快得多***，其结果是，未来对I/O密集型进程的调度处理似乎更为重要。这里的基本思想 是，如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙 碌。从图中可以看到，如果进程是I/O密集型的，则需要多运行一些这类进程以保持CPU的充分利用。</p>
<blockquote>
<p>调度策略通常要在两个矛盾的目标中间寻找平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）。</p>
</blockquote>
<p><strong><em>Linux为了保证交互式应用和桌面系统的性能，所以对进程的响应做了优化（缩短响应时间），更倾向于优先调度I/O消耗型进程</em></strong></p>
<h3 id="根据进程优先级确定调度策略"><a href="#根据进程优先级确定调度策略" class="headerlink" title="根据进程优先级确定调度策略"></a>根据进程优先级确定调度策略</h3><p>调度算法中最基本的一类就是基于优先级的调度。这是一种根据进程的价值和其对处理器时</p>
<p>间的需求来对进程分级的想法。</p>
<p>通常做法是（其并未被Linux系统完全采用）优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式进行调度（一个接一个，重复进行）。</p>
<p>Linux采用了两种不同的优先级范围:</p>
<blockquote>
<p>nice值</p>
<p>它的范围是从-20到+19, 默 认值为0 ；越大的nice值意味着更低的优先级;</p>
<p>在Mac OS X, 进程的nice值 代表分配给进程的时间片的绝对值；而Linux系统中，nice值则代表时间片的比例。你可以通过ps-el命令査看系统中的进程列表，结果中标记N1的一列就是进程对应的nice值。 </p>
</blockquote>
<blockquote>
<p>实时优先级</p>
<p>默认情况下它的变化范围是从0到99 （包括0和99）。与nice值意义相反，越高的实时优先级数值意味着进程优先级越高。</p>
<p>实时优先级和nice优先级处于互不相交的两个范畴</p>
</blockquote>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。*<strong>调度策略必须规定一*** *</strong>个默认的时间片***</p>
<blockquote>
<p>时间片太长</p>
</blockquote>
<p>时间片过长会导致系统对交互的响应表现欠佳，让人觉得系统无法并发执行应用程序</p>
<blockquote>
<p>时间片太短</p>
</blockquote>
<p>会明显增大进程切换带来的处理器耗时，因 为肯定会有相当一部分系统时间用在进程切换上，而这些进程能够用来运行的时间片却很短。</p>
<p>i/o消耗型和处理器消耗型的进程之间的矛盾在这里也再次显露出来：I/O消耗型不需要长的时间片，而处理器消耗型的进程则希望越长越好</p>
<p><strong><em>Linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给了进程。</em></strong></p>
<p>进程所获得的处理器时间其实是和系统负载密切相关的。这个比例进一步还会受进程nice值的影响</p>
<p><strong>Linux系统是抢占式的</strong>,其抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢 占当前进程。否则，将推迟其运行。</p>
<h3 id="案例：文本编辑器（IO）VS视频编码器（处理）"><a href="#案例：文本编辑器（IO）VS视频编码器（处理）" class="headerlink" title="案例：文本编辑器（IO）VS视频编码器（处理）"></a>案例：文本编辑器（IO）VS视频编码器（处理）</h3><p>对于视频编码器。它对什么时间开始运行没有太严格的要求 用户几乎分辨不出也并不关心它到底是立刻就运行还是半秒钟以后才开始的。当然，它完成得越早越好，至于所花时间并不是我们关注的主要问题。 </p>
 <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image04.png" class>

<p>​    </p>
<h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><p>Linux调度器是以**<em>模块方式提供**</em>的，这样做的目的是允许不同类型的进程可以有针对性地选择调度算法。 </p>
<p>这种模块化结构被称为<strong>调度器类</strong>（scheduler classes）,它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级，基础的调度器代码定义kemel/schedx文件中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那一个程序。 </p>
<p>完全公平调度（CFS）是一个**<em>针对普通进程的调度类**</em>，在Linux中称为SCHED_NORMAL（在POSIX中称为SCHED_OTHER） , CFS算法实现定义在文件kemel/sched_fair.c中</p>
<h3 id="Unix系统中的进程调度–CFS公平调度"><a href="#Unix系统中的进程调度–CFS公平调度" class="headerlink" title="Unix系统中的进程调度–CFS公平调度"></a>Unix系统中的进程调度–CFS公平调度</h3><p>CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了，CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片</p>
<p>任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的。nice值对时间片的作用<strong>不再是算数加权，而是几何加权</strong>。任何nice值对应的绝对时间不再是一个绝对值，而是<strong>处理器的使用比</strong>。CFS称为公平调度器是因为它确保给每个进程公平 的处理器使用比。正如我们知道的，CFS不是完美的公平，它只是近乎完美的多任务。但是它确实在多进程环境下，降低了调度延迟带来的不公平性。</p>
<blockquote>
<p>目标延迟</p>
</blockquote>
<p>CFS为完美多任务中的无限小调度周期的近似值设立了一个目标。越小的调度周期将带来越好的交互性，同时也更接近完美的多任务。但是你必须承受更高的切换代价和更差的系统总吞吐能力。</p>
<blockquote>
<p>最小粒度</p>
</blockquote>
<p>CFS为此引入每个进程获得的时间片底线， 这个底线称为最小粒度。默认情况下这个值是1ms。如此一来，即便是可运行进程数量趋于无穷，每个最少也能获得1ms的运行时间，确保切换消耗被限制在一定范围内（避免为了降低延迟不断的无限小调度周期，从而增加了进程切换的消耗）</p>
<h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h3><p>所有的调度器都必须对进程运行时间做记账。多数Unix系统，正如我们前面所说，分配一个时间片给每一个进程。那么当每次系统时钟节拍发生时，时间片都会被减少一个节拍周期。当一个进程的时间片被减少到0时，它就会被另一个尚未减到0的时间片可运行进程抢占。</p>
<h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h3><p>当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。这其实就是CFS调度算法的核心：选择具有最小vruntime的任务。【**<em>最完美的调度：所有可运行进程的vruntime值将一致**</em>】</p>
<p>CFS使用**<u>红黑树</u>**来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程。</p>
<h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h3><p>进程调度的主要入口点是函数schedule(),它定义在文件kemel/sched.c中。Schedule()通常都需要和一个具体的调度类相关联，也就是说，它会找到一个最高优先级的调度类睡眠和唤醒。</p>
<p><strong><em>pick_next_task()</em></strong>会以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选取最高优先级的进程。</p>
<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p><strong>休眠</strong>(被阻塞)的进程处于一个特殊的不可执行状态。这点非常重要，如果没有这种特殊状态的话，调度程序就可能选出一个本不愿意被执行的进程。</p>
<blockquote>
<p>休眠的操作</p>
</blockquote>
<p>内核的操作都相同：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule。选择和执行一个其他进程。</p>
<p>休眠有两种相关的进程状态：**<em>TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE**</em>.它们的唯_区别是处于TASK_UNINTERRUPTIBLE的进程会忽略信号，而处于TASK_INTERRUPTIBLE状态的进程如果接收到一个信号，会被提前唤醒并响应该信号。 两种状态的进程位于同一个等待队列上，等待某些事件，不能够运行。</p>
<blockquote>
<p>唤醒的操作</p>
</blockquote>
<p>唤醒操作通过函数wake_up()进行，它会唤醒指定的等待队列上的所有进程。它调用函数try_to_wake_up(),该函数负责将进程设置为TASK_RUNNING状态，调用enqueue_task()将此进程放入红黑树中，如果被唤醒的进程优先级比当前正在执行的进程的优先级高，还要设置need_resched标志</p>
<h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换，也就是从一个可执行进程切换到另一个可执行进程，由定义在kemel/sched.c中的context_switch()函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用该函数。它完成了两项基本的工作： </p>
<ul>
<li><p>调用声明在&lt;asm/mmu_context.h&gt;中的switch_mm(),该函数负责把虚拟内存从上一个进程映射切换到新进程中。</p>
</li>
<li><p>调用声明在＜asm/system.h＞中的switch_to(),该函数负责从上一个进程的处理器状态切换 </p>
<p>到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结’ </p>
<p>构相关的状态信息，都必须以每个进程为对象进行管理和保存。</p>
</li>
</ul>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>内核提供了一个**<em>need_resched**</em>标志来表明是否需要重新执行一次调度。</p>
<h4 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h4><ul>
<li> 从系统调返回用户空间时。 </li>
<li>从中断处理程序返回用户空间时。</li>
</ul>
<h4 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h4><ul>
<li>中断处理程序正在执行，且返回内核空间之前。</li>
<li>内核代码再一次具有可抢占性的时候。 </li>
<li>如果内核中的任务显式地调用schedule。</li>
<li>如果内核中的任务阻塞(这同样也会导致调用schedule())</li>
</ul>
<h1 id="调度【现代操作系统中根据不同操作系统总结】"><a href="#调度【现代操作系统中根据不同操作系统总结】" class="headerlink" title="调度【现代操作系统中根据不同操作系统总结】"></a>调度【现代操作系统中根据不同操作系统总结】</h1><h2 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h2><blockquote>
<p>在创建一个新进程之后，需要决定是运行父进程还是运行子进程。</p>
</blockquote>
<p>由于这两种进程都处于就绪状态，所以这是一种正常的调度决策，可以任意决定，也就是说，调度程序可以合法选择先运行父进程还是先运行子进程。 </p>
<blockquote>
<p>在一个进程退出时必须做出调度决策。</p>
</blockquote>
<p>一个进程不再运行（因为它不再存在），所以必须从就绪进程集中选择另外某个进程。如果没有就绪的进程，通常会运行一个系统提供的空闲进程。</p>
<blockquote>
<p>当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</p>
</blockquote>
<p>有时，阻塞的原因会成为选择的因素。例如，如果A是一个重要的进程，并正在等待B退出临界区，让B随后运行将会使得B退出临界区，从而可以让A运行。不过问题是，通常调度程序并不拥有做出这种相关考虑的必要信息。</p>
<blockquote>
<p>在一个I/O中断发生时，必须做出调度决策。</p>
</blockquote>
<p>如果中断来自I/O设备，而该设备现在完成了工作，某些被阻塞的等待该I/O的进程就成为可运行的就绪进程了。是否让新就绪的进程运行，这取决于调度程序的决定，或者让中断发生时运行的进程继续运行，或者应该让某个其他进程运行。</p>
<p><strong><em>根据如何处理时钟中断，可以把调度算法分为两类。</em></strong></p>
<ul>
<li><p>非抢占式调度算法</p>
<p>非抢占式调度算法挑选一个进程，然后让该进程运行直至被阻塞（阻塞在I/O上或等待另一个进程），或者直到该进程自动释放CPU。即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行。 </p>
</li>
<li><p>抢占式调度算法</p>
<p>抢占式调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程）。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。如果没有可用的时钟，那么非抢占式调度就是惟一的选择了。</p>
</li>
</ul>
<h3 id="调度算法分类"><a href="#调度算法分类" class="headerlink" title="调度算法分类"></a>调度算法分类</h3><p>不同的环境需要不同的调度算法，在不同的系统中，调度程序的优化是不同的。</p>
<ul>
<li><p>批处理 </p>
<blockquote>
<p>批处理系统在商业领域仍在广泛应用，用来处理薪水册、存货清单、账目收入、账目支出、利息计算 （在银行）、索赔处理（在保险公司）和其他的周期性的作业。在批处理系统中，不会有用户不耐烦地在终端旁等待一个短请求的快捷响应。因此，*<strong>非抢占式算法**<em>，或对每个进程</em></strong>都有长时间周期的抢占式算法***，通常都是可接受的。这种处理方式减少了进程的切换从而改善了性能。这些批处理算法实际上相当普及，并经常可以应用在其他场合。</p>
</blockquote>
</li>
<li><p>交互式</p>
</li>
</ul>
<p>为了避免一个进程霸占CPU拒绝为其他进程服务，抢占是必需的。即便没有进程想永远运行，但是，某个进程由于一个程序错误也可能无限期地排斥所有其他进程。为了避免这种现象发生，抢占也是必要的。服务器也归于此类，因为通常它们要服务多个突发的（远程）用户。 </p>
<ul>
<li>实时</li>
</ul>
<p>有实时限制的系统中，抢占有时是不需要的，因为进程了解它们可能会长时间得不到运行，所以 通常很快地完成各自的工作并阻塞。实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。 </p>
 <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image05.png" class>

<blockquote>
<p>在所有的情形中，公平是很重要的。相似的进程应该得到相似的服务。</p>
</blockquote>
<blockquote>
<p>保持系统的所有部分尽可能忙碌。【CPU针对于CPU密集作业和磁盘针对于IO密集作业的组合，保证CPU和磁盘是尽可能忙碌，减少空转】</p>
</blockquote>
<h3 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h3><h4 id="先来先服务（first-come-first-served）"><a href="#先来先服务（first-come-first-served）" class="headerlink" title="先来先服务（first-come first-served）"></a>先来先服务（first-come first-served）</h4><p>使用该算法，进程按照它们请求CPU的顺序使用CPU。【**<em>非抢占式**</em>】</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><blockquote>
<p>有一个就绪进程的单一队列。早上，当第一个作业从外部进入系统，就立即开始并允许运行它所期望的时间。不会中断该作业，因为它需要很长的时间运行。当其他作业进入时，它们就被安排到队列的尾部。当正在运行的进程被阻塞时，队列中的第一个进程就接着运行。在 <strong>被阻塞的进程变为就绪时，就像一个新来到的作业一样，排到队列的末尾。</strong> </p>
</blockquote>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>主要优点是易于理解并且便于在程序中运用</li>
<li>在计算密集型和IO密集型应用的组合上容易出现问题。</li>
</ul>
<p>IO密集型应用在运行期间，多半时间花费在磁盘读写操作上，且时间比较长，影响了计算密集型应用对于CPU的占有使用。</p>
<h5 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h5><p>适用于运行时间可以预知的另一个**<em>非抢占式**</em>的批处理调度算法</p>
<p>当输入队列中有**<em>若干个同等重要的作业**</em>被启动时，调度程序应使用最短作业优先（shortest job first）算法</p>
 <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image06.png" class>

<p><strong>a)</strong>   有4个作业A、B、C、D，运行时间分别为8、4、4、4分钟。若按图中的次序运行，则A的周转时间为8分钟，B为12分钟，C为16分钟，D为20分钟，平均为14分钟。</p>
<p><strong>b）</strong>目前周转时间分别为4、8、12和20分钟，平均为11分钟。可以证明最短作业是最优的。</p>
<blockquote>
<p><strong>为什么最短作业最优</strong>的推导</p>
</blockquote>
<p>考虑有4个作业的情况，其运行时间分别为a、b、c、d。第一个作业在时间a结束，第二个在时间a+b结束，以此类推。平均周转时间为（4a+3b+2c+d）/4。显然a对平均值影响最大，所以它应是最短作业，其次是b，再次是c，最后的d只影响它自己的周转时间</p>
<p><strong><em>只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的</em></strong>，不然，运行时间成本里还需要考虑对相关作业的等待时间。</p>
<h5 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h5><p>最短作业优先的*<strong>抢占式版本**<em>是最短剩余时间优先（shortest remaining time next）算法。使用这个算法， 调度程序总是选择剩余运行时间最短的那个进程运行。再次提醒，有关的运行时间必须提前掌握。当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，</em></strong>当前进程就被挂起，而运行新的进程***【抢占】。这种方式可以使新的短作业获得良好的服务</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker基础命令与镜像</title>
    <url>/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/01.png" class>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>官方文档：<a href="https://docs.docker.com/docker-for-windows/">https://docs.docker.com/docker-for-windows/</a> </p>
<p>【官方文档超级详细】</p>
<p>仓库地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>【发布到仓库，git pull push】</p>
<p>b站教程：<a href="https://www.bilibili.com/video/BV1og4y1q7M4">https://www.bilibili.com/video/BV1og4y1q7M4</a>?</p>
<p>【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】</p>
<h2 id="前期基础"><a href="#前期基础" class="headerlink" title="前期基础"></a>前期基础</h2><p>linux基本命令，类似cd，mkdir等</p>
<h2 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h2><h3 id="Docker为什么会出现"><a href="#Docker为什么会出现" class="headerlink" title="Docker为什么会出现"></a>Docker为什么会出现</h3><p>一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题</p>
<p>尤其对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题</p>
<p>所以发布项目时，不只是一套代码过去，而是<strong>代码+环境</strong>整体打包过去</p>
<p>所谓开发即运维，保证系统稳定性，提高部署效率</p>
<p>使用Docker后的流程：</p>
<p>开发：建立模型–环境–打包带上环境，即镜像–放到Docker仓库</p>
<p>部署：下载Docker中的镜像，直接运行即可</p>
<p>Docker的思想来自于集装箱，集装箱，对环境进行隔离</p>
<p>Docker通过隔离机制，可以将服务器利用到极致。</p>
<h3 id="Docker的历史"><a href="#Docker的历史" class="headerlink" title="Docker的历史"></a>Docker的历史</h3><p>2010年，几个搞IT的人，在美国成立一家公司<code>dotCloud</code></p>
<p>做一些pass的云计算服务</p>
<p>他们将自己的容器化技术命名为Docker</p>
<p>Docker基于Go语言开发</p>
<p>Docker刚刚诞生的时候，没有引起行业的注意，dotCloud活不下去</p>
<p>然后他们决定开源</p>
<p>2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都会更新一个版本</p>
<p>2014年4月9日，Docker 1.0发布</p>
<h3 id="容器vs虚拟机"><a href="#容器vs虚拟机" class="headerlink" title="容器vs虚拟机"></a>容器vs虚拟机</h3><p><strong>在容器技术出来之前，用的是虚拟机技术</strong></p>
<h4 id="虚拟机原理示意图"><a href="#虚拟机原理示意图" class="headerlink" title="虚拟机原理示意图"></a>虚拟机原理示意图</h4><img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/02.png" class>

<p>缺点：</p>
<ol>
<li>资源占用多</li>
<li>冗余步骤多</li>
<li>启动很慢</li>
</ol>
<h4 id="容器化技术示意图"><a href="#容器化技术示意图" class="headerlink" title="容器化技术示意图"></a>容器化技术示意图</h4><p>不是模拟的完整的操作系统</p>
<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/03.png" class>

<h4 id="二者对比"><a href="#二者对比" class="headerlink" title="二者对比"></a>二者对比</h4><p>比较虚拟机和Docker的不同</p>
<table>
<thead>
<tr>
<th></th>
<th>传统虚拟机</th>
<th>Docker</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟内容</td>
<td>硬件+完整的操作系统+软件</td>
<td>APP+LIB</td>
</tr>
<tr>
<td>大小</td>
<td>笨重，通常几个G</td>
<td>轻便几个M或KB</td>
</tr>
<tr>
<td>启动速度</td>
<td>慢，分钟级</td>
<td>快，秒级</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h3><img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/04.png" class>

<p>明确几个概念：</p>
<blockquote>
<p>镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class</p>
</blockquote>
<blockquote>
<p>容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统</p>
</blockquote>
<blockquote>
<p>仓库(repository)：存放镜像的地方，</p>
<p>分为共有仓库和私有仓库</p>
<ul>
<li><p>Docker Hub：国外的</p>
</li>
<li><p>阿里云：配置镜像加速</p>
</li>
</ul>
</blockquote>
<h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我们要有一台服务器，并且可以操作它</p>
<ol>
<li>Linux命令基础，购买linux阿里云的服务器</li>
<li>CentOS 7</li>
<li>使用Xshell链接远程服务器</li>
</ol>
<h3 id="安装xshell"><a href="#安装xshell" class="headerlink" title="安装xshell"></a>安装xshell</h3><p>下载CentOS7 <a href="https://www.jianshu.com/p/a63f47e096e8">https://www.jianshu.com/p/a63f47e096e8</a></p>
<p>下载VMware 360软件管家下载</p>
<p>VMware配置虚拟机 <a href="https://blog.csdn.net/babyxue/article/details/80970526">https://blog.csdn.net/babyxue/article/details/80970526</a></p>
<p>xshell链接服务器 <a href="https://blog.csdn.net/zzy1078689276/article/details/77280814">https://blog.csdn.net/zzy1078689276/article/details/77280814</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# cd &#x2F;</span><br><span class="line">[root@192 &#x2F;]# pwd</span><br><span class="line">&#x2F;</span><br><span class="line">[root@192 &#x2F;]# ls</span><br><span class="line">bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@192 &#x2F;]# uname -r</span><br><span class="line">3.10.0-1127.el7.x86_64</span><br></pre></td></tr></table></figure>
<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/05.png" class>

<p>用户名 </p>
<p>密码</p>
<p>查看ip：vmware里面输入，ip addIPr</p>
<p>视频书签，p602:20</p>
<p><a href="https://www.bilibili.com/video/BV1og4y1q7M4?p=6">https://www.bilibili.com/video/BV1og4y1q7M4?p=6</a></p>
<h3 id="Centos安装"><a href="#Centos安装" class="headerlink" title="Centos安装"></a>Centos安装</h3><p><a href="https://docs.docker.com/engine/install/centos/">https://docs.docker.com/engine/install/centos/</a></p>
<h3 id="卸载旧的版本"><a href="#卸载旧的版本" class="headerlink" title="卸载旧的版本"></a>卸载旧的版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 卸载旧的版本</span><br><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/06.png" class>

<h3 id="安装基本环境"><a href="#安装基本环境" class="headerlink" title="安装基本环境"></a>安装基本环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装基本的安装包</span><br><span class="line">$ sudo yum install -y yum-utils</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/06.png" class>

<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/07.png" class>

<h3 id="设置镜像的仓库"><a href="#设置镜像的仓库" class="headerlink" title="设置镜像的仓库"></a>设置镜像的仓库</h3><p>注意！！下载默认用国外的，太慢不要用！</p>
<p>用国内镜像，百度搜索，docker的阿里云镜像地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 不要用官网默认这个！</span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo # 默认是国外的</span><br><span class="line"></span><br><span class="line"># 换成下面的</span><br><span class="line"></span><br><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo # 阿里云镜像</span><br></pre></td></tr></table></figure>
<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/08.png" class>

<p>直接复制粘贴就OK了</p>
<p>更像软件包索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum makecache fast</span><br></pre></td></tr></table></figure>
<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/09.png" class>

<p>没有问题的话就是可以用的</p>
<h3 id="安装docker引擎"><a href="#安装docker引擎" class="headerlink" title="安装docker引擎"></a>安装docker引擎</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io <span class="comment"># docker-ce 社区版 ee 企业版</span></span><br></pre></td></tr></table></figure>
<p>注意这里会有几个个y/n的判断</p>
<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/10.png" class>

<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/11.png" class>

<p>要看到Complet再收手！</p>
<h3 id="启动Docker"><a href="#启动Docker" class="headerlink" title="启动Docker"></a>启动Docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start docker # 代表启动成功</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           19.03.11</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.13.10</span><br><span class="line"> Git commit:        42e35e61f3</span><br><span class="line"> Built:             Mon Jun  1 09:13:48 2020</span><br><span class="line"> OS&#x2F;Arch:           linux&#x2F;amd64</span><br><span class="line"> Experimental:      false</span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          19.03.11</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.13.10</span><br><span class="line">  Git commit:       42e35e61f3</span><br><span class="line">  Built:            Mon Jun  1 09:12:26 2020</span><br><span class="line">  OS&#x2F;Arch:          linux&#x2F;amd64</span><br><span class="line">  Experimental:     false</span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.2.13</span><br><span class="line">  GitCommit:        7ad184331fa3e55e52b890ea95e65ba581ae3429</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.0.0-rc10</span><br><span class="line">  GitCommit:        dc9208a3303feef5b3839f4323d9beb36df0a9dd</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.18.0</span><br><span class="line">  GitCommit:        fec3683</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>
<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/12.png" class>

<p>中间一堆是签名信息</p>
<p>run的运行流程图</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/14.png" class>

<p>查看下载的镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/13.png" class>

<h3 id="卸载Docker"><a href="#卸载Docker" class="headerlink" title="卸载Docker"></a>卸载Docker</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 卸载依赖</span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"></span><br><span class="line"># 删除资源</span><br><span class="line">rm -rf &#x2F;var&#x2F;lib&#x2F;docker # docker 的默认工作路径</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><p>支付宝扫码登录，短信验证，确认授权</p>
<p>我有两个问题</p>
<ol>
<li><p>阿里云镜像加速必须配置嘛？</p>
<blockquote>
<p>哎呦我去: 加速快</p>
<p>哎呦我去: 要是翻墙就无所谓了</p>
</blockquote>
</li>
<li><p>这个阿里云必须要买嘛，买哪个，我看阿里云好多产品</p>
<blockquote>
<p>哎呦我去:不需要买</p>
<p>哎呦我去:免费的</p>
<p>哎呦我去:阿里云搜索容器服务</p>
<p>哎呦我去:有一个镜像加速</p>
</blockquote>
</li>
</ol>
<ol start="3">
<li>这个地址是哪来的呀</li>
</ol>
<p>操作</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/15.png" class>

 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/16.png" class>

<p>控制台搜索 容器镜像服务</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/17.png" class> 



<p>找到加速地址</p>
  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/18.png" class>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker # 创建一个陌路</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;uyfgafsw.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF # 编写配置文件</span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload # 重启服务</span><br><span class="line">sudo systemctl restart docker # 重启docker</span><br></pre></td></tr></table></figure>
  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/19.png" class>



<p><a href="https://www.processon.com/">在线画图软件ProcessOn</a></p>
<p><a href="https://www.bilibili.com/video/BV177411K7bH">服务器及购买相关介绍</a></p>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>Docker是真么工作的？</p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！</p>
<p>DockerServer接受到Docker-Client的指令，</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/39.png" class>

<p>Docker为什么比VM快？</p>
<ol>
<li><p>Docker有着比虚拟机更少的抽象层</p>
</li>
<li><p>docker主要用的是宿主机的内核，vm需要Guest OS</p>
<img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/38.png" class>

</li>
</ol>
<p>所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导</p>
<h2 id="Docker命令"><a href="#Docker命令" class="headerlink" title="Docker命令"></a>Docker命令</h2><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker version # 显示docker的基本信息</span><br><span class="line">docker info # 系统信息，镜像和容器的数量</span><br><span class="line">docker 命令 --help # 全部信息</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.docker.com/reference/">官网文档</a></p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/37.png" class>



<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h4><p>查看所有本地主机上的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># docker images</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/36.png" class>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 解释</span><br><span class="line">REPOSITORY  # 镜像仓库源</span><br><span class="line">TAG                 # 镜像的标签</span><br><span class="line">IMAGE ID           # 镜像的ID</span><br><span class="line">CREATED           # 镜像的创建时间</span><br><span class="line">SIZE # 镜像的大小</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--all , -a		Show all images (default hides intermediate images) <span class="comment"># 显示所有</span></span><br><span class="line">--digests		Show digests</span><br><span class="line">--filter , -f		Filter output based on conditions provided</span><br><span class="line">--format		Pretty-print images using a Go template</span><br><span class="line">--no-trunc		Don’t truncate output</span><br><span class="line">--quiet , -q		Only show numeric IDs <span class="comment"># 只显示id</span></span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/35.png" class>

<h4 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h4><p>搜索仓库中的镜像，相当于网页搜索</p>
<p><a href="http://hub.docker.com/">网页搜索</a></p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/34.png" class>

<p>mysql</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/33.png" class>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/32.png" class>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search --help</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/31.png" class>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解释</span></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --<span class="built_in">limit</span> int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don<span class="string">&#x27;t truncate output</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search mysql --filter&#x3D;STARS&#x3D;3000 # 搜索出Stars大于3000的</span><br></pre></td></tr></table></figure>
  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/30.png" class>



<h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4><p>下载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull mysql <span class="comment"># 下载mysql镜像，default tag，默认最新版latest</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@192 ~]<span class="comment"># sudo systemctl daemon-reload</span></span><br><span class="line">[root@192 ~]<span class="comment"># sudo systemctl restart docker</span></span><br><span class="line">[root@192 ~]<span class="comment"># docker pull mysql</span></span><br><span class="line">Using default tag: latest <span class="comment"># 不写tag默认最新版</span></span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">8559a31e96f4: Pull complete  <span class="comment"># layer 分层下载，docker image的核心 联合文件系统</span></span><br><span class="line">d51ce1c2e575: Pull complete </span><br><span class="line">c2344adc4858: Pull complete </span><br><span class="line">fcf3ceff18fc: Pull complete </span><br><span class="line">16da0c38dc5b: Pull complete </span><br><span class="line">b905d1797e97: Pull complete </span><br><span class="line">4b50d1c6b05c: Pull complete </span><br><span class="line">c75914a65ca2: Pull complete </span><br><span class="line">1ae8042bdd09: Pull complete </span><br><span class="line">453ac13c00a3: Pull complete </span><br><span class="line">9e680cd72f08: Pull complete </span><br><span class="line">a6b5dc864b6c: Pull complete </span><br><span class="line">Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6<span class="comment">#签名</span></span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> mysql:latest</span><br><span class="line">docker.io/library/mysql:latest <span class="comment"># 真实地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即</span></span><br><span class="line">docker pull mysql</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">docker pull docker.io/library/mysql:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定版本下载 </span></span><br><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<p>版本来自于官网，版本库<a href="https://hub.docker.com/_/mysql">https://hub.docker.com/_/mysql</a></p>
  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/29.png" class>



  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/28.png" class>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>此时查看镜像，可以看到新下载的两个</p>
  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/27.png" class>

<h4 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h4><p>remove images</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除一个 可以通过名称 也可以指定id -f表示删除所有</span></span><br><span class="line">docker rmi -f 9cfcce23593a</span><br><span class="line"><span class="comment"># 删除多个 用空格分隔id</span></span><br><span class="line">docker rmi -f id id id</span><br><span class="line"><span class="comment"># 删除所有 </span></span><br><span class="line">docker rmi -f $(docker images -aq) <span class="comment"># images -aq就是查所有镜像id，从而递归删除</span></span><br></pre></td></tr></table></figure>


 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/26.png" class>

  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/25.png" class>

<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p>说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
  

<h4 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--name=“Name” # 容器名字，用于区分容器</span><br><span class="line">-d 后台方式运行</span><br><span class="line">-it 使用交互方式运行，进入容器查看内容</span><br><span class="line">-p 指定容器的端口 如-p 8080::8080</span><br><span class="line">	-p ip:主机端口：容器端口</span><br><span class="line">	-p 主机端口:容器端口</span><br><span class="line">	-p 容器端口</span><br><span class="line">	</span><br><span class="line">-p 随机指定端口</span><br></pre></td></tr></table></figure>
<h4 id="进入退出容器"><a href="#进入退出容器" class="headerlink" title="进入退出容器"></a>进入退出容器</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入</span></span><br><span class="line">docker run -it centos /bin/bash </span><br><span class="line"><span class="comment"># 查看目录</span></span><br><span class="line">ls</span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/23.png" class>

 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/22.png" class>

<p>注意这里面主机名，变成了centos的id</p>
<p>这里面就是一个容器，套娃啊</p>
<h4 id="查看运行的容器"><a href="#查看运行的容器" class="headerlink" title="查看运行的容器"></a>查看运行的容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看正在运行的容器</span><br><span class="line">docker ps</span><br><span class="line"># 查看曾经运行的容器</span><br><span class="line">docker ps -a</span><br><span class="line"># 显示最近创建的容器，设置显示个数</span><br><span class="line">docker ps -a - n&#x3D;? </span><br><span class="line"># 只显示容器的编号</span><br><span class="line">docker ps -aq</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@192 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">9939864fa2e6        centos              &quot;bin/bash&quot;          4 minutes ago       Exited (0) 4 minutes ago                       unruffled_knuth</span><br><span class="line">5f42e9930435        centos              &quot;/bin/bash&quot;         8 minutes ago       Exited (0) 4 minutes ago                       lucid_cannon</span><br><span class="line">a89ddb393d3d        bf756fb1ae65        &quot;/hello&quot;            19 hours ago        Exited (0) 19 hours ago                        gracious_bhabha</span><br><span class="line">[root@192 ~]# docker ps -a -n=2</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                     PORTS               NAMES</span><br><span class="line">9939864fa2e6        centos              &quot;bin/bash&quot;          6 minutes ago       Exited (0) 6 minutes ago                       unruffled_knuth</span><br><span class="line">5f42e9930435        centos              &quot;/bin/bash&quot;         10 minutes ago      Exited (0) 7 minutes ago </span><br><span class="line">[root@192 ~]# docker ps -aq</span><br><span class="line">9939864fa2e6</span><br><span class="line">5f42e9930435</span><br><span class="line">a89ddb393d3d</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 容器停止退出</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器不停止退出 注意必须在英文输入法下，中文输入法不行</span></span><br><span class="line">Ctrl + P + Q</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED              STATUS              PORTS               NAMES</span><br><span class="line">bfcea13c40cd        centos              &quot;/bin/bash&quot;         About a minute ago   Up About a minute                       stoic_wilson</span><br><span class="line">edbd9366d959        centos              &quot;/bin/bash&quot;         7 minutes ago        Up 7 minutes                            affectionate_bartik</span><br><span class="line">[root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入</span><br><span class="line">[root@edbd9366d959 /]# exit ##停止并推出</span><br><span class="line">exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f</span></span><br><span class="line">docker rm 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器</span></span><br><span class="line">docker rm -f $(docker ps -aq)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器</span></span><br><span class="line">docker ps -a -q|xargs docker rm</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">bfcea13c40cd        centos              &quot;/bin/bash&quot;         29 minutes ago      Up 29 minutes                                   stoic_wilson</span><br><span class="line">edbd9366d959        centos              &quot;/bin/bash&quot;         35 minutes ago      Up 35 minutes                                   affectionate_bartik</span><br><span class="line">9939864fa2e6        centos              &quot;bin/bash&quot;          48 minutes ago      Exited (0) 48 minutes ago                       unruffled_knuth</span><br><span class="line">5f42e9930435        centos              &quot;/bin/bash&quot;         52 minutes ago      Exited (0) 49 minutes ago                       lucid_cannon</span><br><span class="line">a89ddb393d3d        bf756fb1ae65        &quot;/hello&quot;            20 hours ago        Exited (0) 20 hours ago                         gracious_bhabha</span><br><span class="line">[root@192 ~]# docker rm 5f42e9930435</span><br><span class="line">5f42e9930435</span><br><span class="line">[root@192 ~]# docker rm edbd9366d959      # 注意正在运行的容器不能删除</span><br><span class="line">Error response from daemon: You cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. Stop the container before attempting removal or force remove</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# docker ps -aq # 所有容器id</span><br><span class="line">bfcea13c40cd</span><br><span class="line">edbd9366d959</span><br><span class="line">9939864fa2e6</span><br><span class="line">a89ddb393d3d</span><br><span class="line">[root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除</span><br><span class="line">bfcea13c40cd</span><br><span class="line">edbd9366d959</span><br><span class="line">9939864fa2e6</span><br><span class="line">a89ddb393d3d</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start</span><br><span class="line">docker restart</span><br><span class="line">docker stop</span><br><span class="line">docker kill</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@7b1a7dd10ea4 /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@192 ~]# docker ps #查看正在运行的</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">[root@192 ~]# docker ps -a # 查看历史运行过的</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">7b1a7dd10ea4        centos              &quot;/bin/bash&quot;         54 seconds ago      Exited (0) 42 seconds ago                       fervent_mirzakhani</span><br><span class="line">[root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来</span><br><span class="line">7b1a7dd10ea4</span><br><span class="line">[root@192 ~]# docker ps # 查看当前运行容器 发现启动成功</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">7b1a7dd10ea4        centos              &quot;/bin/bash&quot;         2 minutes ago       Up 28 seconds                           fervent_mirzakhani</span><br><span class="line">[root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行</span><br><span class="line">7b1a7dd10ea4</span><br><span class="line">[root@192 ~]# docker ps # 再次查看 没有这个容器了</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="后台启动docker"><a href="#后台启动docker" class="headerlink" title="后台启动docker"></a>后台启动docker</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d 镜像名</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用docker ps 查看的时候 发现停止了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Last login: Wed Jun 17 19:47:35 2020</span><br><span class="line">[root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker</span><br><span class="line">[root@192 ~]# docker run -d centos # 运行</span><br><span class="line">8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded</span><br><span class="line">[root@192 ~]# docker ps -a # 查看正在运行的</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">8ce188e5fee3        centos              &quot;/bin/bash&quot;         19 seconds ago      Exited (0) 18 seconds ago                       tender_dirac</span><br><span class="line">7b1a7dd10ea4        centos              &quot;/bin/bash&quot;         8 hours ago         Exited (0) 8 hours ago                          fervent_mirzakhani</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs</span><br><span class="line">docker logs -f -t --tail n 【id】</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/21.png" class>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# docker logs --help</span><br><span class="line"></span><br><span class="line">Usage:	docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Fetch the logs of a container</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g.</span><br><span class="line">                       2013-01-02T13:23:37) or relative</span><br><span class="line">                       (e.g. 42m for 42 minutes)</span><br><span class="line">      --tail string    Number of lines to show from the</span><br><span class="line">                       end of the logs (default &quot;all&quot;)</span><br><span class="line">  -t, --timestamps     Show timestamps # 时间戳</span><br><span class="line">      --until string   Show logs before a timestamp (e.g.</span><br><span class="line">                       2013-01-02T13:23:37) or relative</span><br><span class="line">                       (e.g. 42m for 42 minutes)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">whiel true;do echo shenzai;sleep </span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行一个</span></span><br><span class="line">[root@192 ~]# docker run -it centos /bin/bash</span><br><span class="line"></span><br><span class="line">[root@c2887d35c71d /]# [root@192 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">c2887d35c71d        centos              &quot;/bin/bash&quot;         57 seconds ago      Up 56 seconds                           vigorous_kare</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志，由于没有运行脚本，所以啥也没显示</span></span><br><span class="line">[root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d</span><br><span class="line">^C # ctrl+c退出</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行centos里面加个脚本</span></span><br><span class="line">[root@192 ~]# docker run -d centos /bin/sh -c &quot;while true;do echo XHD天下最帅;sleep 1;done&quot;</span><br><span class="line">cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388</span><br><span class="line"></span><br><span class="line">[root@192 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES</span><br><span class="line">cb6d7fbc3f27        centos              &quot;/bin/sh -c &#x27;while t…&quot;   7 seconds ago       Up 6 seconds                            dreamy_almeida</span><br><span class="line">c2887d35c71d        centos              &quot;/bin/bash&quot;              3 minutes ago       Up 3 minutes                            vigorous_kare</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志 发现隔一秒打印一条</span></span><br><span class="line">[root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27</span><br><span class="line">2020-06-17T12:02:11.293765084Z shenzai</span><br><span class="line">2020-06-17T12:02:12.297675608Z shenzai</span><br><span class="line">2020-06-17T12:02:13.301845582Z shenzai</span><br><span class="line">2020-06-17T12:02:14.304800996Z shenzai</span><br><span class="line">2020-06-17T12:02:15.307130238Z shenzai</span><br><span class="line">2020-06-17T12:02:16.310574235Z shenzai</span><br><span class="line">2020-06-17T12:02:17.312946923Z shenzai</span><br><span class="line">2020-06-17T12:02:18.314841295Z shenzai</span><br><span class="line">2020-06-17T12:02:19.317021705Z shenzai</span><br><span class="line">2020-06-17T12:02:20.319670013Z shenzai</span><br><span class="line">2020-06-17T12:02:21.322651649Z shenzai</span><br><span class="line">2020-06-17T12:02:22.325466918Z shenzai</span><br><span class="line">2020-06-17T12:02:23.327984704Z shenzai</span><br><span class="line">2020-06-17T12:02:24.329656919Z shenzai</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="查看正在运行的容器信息"><a href="#查看正在运行的容器信息" class="headerlink" title="查看正在运行的容器信息"></a>查看正在运行的容器信息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 ~]# docker inspect cb6d7fbc3f27</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        # 容器的完整id</span><br><span class="line">        &quot;Id&quot;: &quot;cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388&quot;,</span><br><span class="line">        </span><br><span class="line">        # 创建时间</span><br><span class="line">        &quot;Created&quot;: &quot;2020-06-17T12:00:50.706906186Z&quot;,</span><br><span class="line">        </span><br><span class="line">        # 脚本位置</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        </span><br><span class="line">        # 运行的脚本</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true;do echo shenzai;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;, # 状态，正在运行</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 1909, # 父进程id</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2020-06-17T12:00:51.093617477Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        # 来源镜像</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log&quot;,</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &quot;Name&quot;: &quot;/dreamy_almeida&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        </span><br><span class="line">        # 主机配置</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;Capabilities&quot;: null,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        # 其他配置</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907-init/diff:/var/lib/docker/overlay2/7f79322e0f58d651a84a555dadd83d92537788172525945d3f538dd95dce336c/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/3675586ebbd79cd72d2562a90c9380627a331c563724c0dac091f92600af4907/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        &quot;Mounts&quot;: [], # 挂载</span><br><span class="line">        </span><br><span class="line">        # 基本配置</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;cb6d7fbc3f27&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ], # 基本环境变量，这里没有Java</span><br><span class="line">            </span><br><span class="line">            # 基本命令</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true;do echo shenzai;sleep 1;done&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20200611&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">        # 网卡，比如现在用的是桥接的网卡</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;4d701985d7e77aa153790b697b2f38a61e20555c224b7675e4bf650b82799882&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/4d701985d7e7&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;8a6c71e2bafb19ca7dfd85445ccc4bef6d17467360a243d624089e676a24a018&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;22b0fd2290ccbc4e066a75d3f01bd8bf32ee4352c5bbcfc9f911287219219571&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;8a6c71e2bafb19ca7dfd85445ccc4bef6d17467360a243d624089e676a24a018&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止正在疯狂输出的那个容器</span></span><br><span class="line">[root@192 ~]# docker stop cb6d7fbc3f27</span><br><span class="line">cb6d7fbc3f27</span><br></pre></td></tr></table></figure>
<h4 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的e</span></span><br><span class="line"></span><br><span class="line">docker exec -it 容器id bashSHELL</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试</span></span><br><span class="line">[root@192 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">c2887d35c71d        centos              &quot;/bin/bash&quot;         35 minutes ago      Up 35 minutes                           vigorous_kare</span><br><span class="line">[root@192 ~]# docker exec -it c2887d35c71d /bin/bash</span><br><span class="line">[root@c2887d35c71d /]# ls</span><br><span class="line">bin  etc   lib	  lost+found  mnt  proc  run   srv  tmp  var</span><br><span class="line">dev  home  lib64  media       opt  root  sbin  sys  usr</span><br><span class="line">[root@c2887d35c71d /]# ps -ef</span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 11:57 pts/0    00:00:00 /bin/bash</span><br><span class="line">root         14      0  0 12:32 pts/1    00:00:00 /bin/bash</span><br><span class="line">root         28     14  0 12:32 pts/1    00:00:00 ps -ef</span><br><span class="line">[root@c2887d35c71d /]# c2887d35c71d</span><br><span class="line">[root@c2887d35c71d /]# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">[root@192 ~]# docker attach c2887d35c71d</span><br><span class="line">[root@c2887d35c71d /]# </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 区别</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作(常用)</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker attach 进入容器正在执行的终端，不会启动新的进程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="从容器内拷贝文件到主机上"><a href="#从容器内拷贝文件到主机上" class="headerlink" title="从容器内拷贝文件到主机上"></a>从容器内拷贝文件到主机上</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">[root@192 ~]# docker run -it centos</span><br><span class="line"><span class="meta">#</span><span class="bash"> ctrl P Q 不关闭退出，查看</span></span><br><span class="line">[root@0569081aa89c /]# [root@192 ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">0569081aa89c        centos              &quot;/bin/bash&quot;         19 seconds ago      Up 19 seconds    </span><br><span class="line">hopeful_chebyshev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看主机home下无文件</span></span><br><span class="line">[root@192 ~]# cd /home</span><br><span class="line">[root@192 home]# ls</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入正在运行的容器</span></span><br><span class="line">[root@192 home]# docker attach 0569081aa89c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器home目录</span></span><br><span class="line">[root@0569081aa89c /]# cd /home</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在目录中创建java文件</span></span><br><span class="line">[root@0569081aa89c home]# touch test.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出并停止容器</span></span><br><span class="line">[root@0569081aa89c home]# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看现在运行的容器</span></span><br><span class="line">[root@192 home]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器虽然被停止，但是数据都会保留</span></span><br><span class="line">[root@192 home]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                         PORTS               NAMES</span><br><span class="line">0569081aa89c        centos              &quot;/bin/bash&quot;              3 minutes ago       Exited (0) 8 seconds ago                           hopeful_chebyshev</span><br><span class="line">f589e5684a01        centos              &quot;/bin/bash&quot;              44 minutes ago      Exited (0) 44 minutes ago                          cranky_easley</span><br><span class="line">cb6d7fbc3f27        centos              &quot;/bin/sh -c &#x27;while t…&quot;   54 minutes ago      Exited (137) 42 minutes ago                        dreamy_almeida</span><br><span class="line">c2887d35c71d        centos              &quot;/bin/bash&quot;              58 minutes ago      Exited (127) 16 minutes ago                        vigorous_kare</span><br><span class="line">8ce188e5fee3        centos              &quot;/bin/bash&quot;              About an hour ago   Exited (0) About an hour ago                       tender_dirac</span><br><span class="line">7b1a7dd10ea4        centos              &quot;/bin/bash&quot;              9 hours ago         Exited (0) 9 hours ago                             fervent_mirzakhani</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 容器数据拷贝到主机</span></span><br><span class="line">[root@192 home]# docker cp 0569081aa89c:/home/test.java /home</span><br><span class="line">[root@192 home]# ls</span><br><span class="line">test.java</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝是一个手动过程，未来我们使用 -v 卷的技术，可以实现自动同步 /home /home</span></span><br></pre></td></tr></table></figure>
<h4 id="查看内容占用"><a href="#查看内容占用" class="headerlink" title="查看内容占用"></a>查看内容占用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stats</span><br><span class="line"></span><br></pre></td></tr></table></figure>




<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4>  <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/20.png" class>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@192 home]# docker --help</span><br><span class="line"></span><br><span class="line">Usage:	docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config</span><br><span class="line">                           files (default &quot;/root/.docker&quot;)</span><br><span class="line">  -c, --context string     Name of the context to use to</span><br><span class="line">                           connect to the daemon</span><br><span class="line">                           (overrides DOCKER_HOST env var</span><br><span class="line">                           and default context set with</span><br><span class="line">                           &quot;docker context use&quot;)</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to</span><br><span class="line">  -l, --log-level string   Set the logging level</span><br><span class="line">                           (&quot;debug&quot;|&quot;info&quot;|&quot;warn&quot;|&quot;error&quot;|&quot;fatal&quot;) (default &quot;info&quot;)</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by</span><br><span class="line">                           this CA (default</span><br><span class="line">                           &quot;/root/.docker/ca.pem&quot;)</span><br><span class="line">      --tlscert string     Path to TLS certificate file</span><br><span class="line">                           (default &quot;/root/.docker/cert.pem&quot;)</span><br><span class="line">      --tlskey string      Path to TLS key file (default</span><br><span class="line">                           &quot;/root/.docker/key.pem&quot;)</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  builder     Manage builds</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  context     Manage contexts</span><br><span class="line">  engine      Manage the docker engine</span><br><span class="line">  image       Manage images</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container&#x27;s changes</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container&#x27;s filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  exec        Run a command in a running container</span><br><span class="line">  export      Export a container&#x27;s filesystem as a tar archive</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  images      List images</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  info        Display system-wide information</span><br><span class="line">  inspect     Return low-level information on Docker objects</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  login       Log in to a Docker registry</span><br><span class="line">  logout      Log out from a Docker registry</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  ps          List containers</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  search      Search the Docker Hub for images</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/临时markdown文件保存\docker_learning\Docker.assets\image-20200617210932306.png" alt="image-20200617210932306"></p>
<p><img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/临时markdown文件保存\docker_learning\Docker.assets\image-20200617211021003.png" alt="image-20200617211021003"></p>
<p><img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/临时markdown文件保存\docker_learning\Docker.assets\image-20200617211039508.png" alt="image-20200617211039508"></p>
<h2 id="Docker镜像"><a href="#Docker镜像" class="headerlink" title="Docker镜像"></a>Docker镜像</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="UnionFS-联合文件系统"><a href="#UnionFS-联合文件系统" class="headerlink" title="UnionFS 联合文件系统"></a>UnionFS 联合文件系统</h4><p>联合文件系统（<a href="https://en.wikipedia.org/wiki/UnionFS">UnionFS</a>）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（Advanced Multi-Layered Unification Filesystem）就是一种联合文件系统。 <code>AUFS</code> 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 <code>AUFS</code> 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 <code>OverlayFS</code>, <code>AUFS</code>, <code>Btrfs</code>, <code>VFS</code>, <code>ZFS</code> 和 <code>Device Mapper</code>。</p>
<p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p>
<table>
<thead>
<tr>
<th>Linux 发行版</th>
<th>Docker 推荐使用的存储驱动</th>
</tr>
</thead>
<tbody><tr>
<td>Docker on Ubuntu</td>
<td><code>overlay2</code> (16.04 +)</td>
</tr>
<tr>
<td>Docker on Debian</td>
<td><code>overlay2</code> (Debian Stretch), <code>aufs</code>, <code>devicemapper</code></td>
</tr>
<tr>
<td>Docker on CentOS</td>
<td><code>overlay2</code></td>
</tr>
<tr>
<td>Docker on Fedora</td>
<td><code>overlay2</code></td>
</tr>
</tbody></table>
<p>在可能的情况下，<a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/">推荐</a> 使用 <code>overlay2</code> 存储驱动，<code>overlay2</code> 是目前 Docker 默认的存储驱动，以前则是 <code>aufs</code>。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/40.png" class>

<p>bootfs：boot file system</p>
<p>rootfs：root file system</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/41.png" class>





 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/42.png" class>

 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/43.png" class>



 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/44.png" class>

<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/45.png" class>

<h3 id="commit提交镜像"><a href="#commit提交镜像" class="headerlink" title="commit提交镜像"></a>commit提交镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit # 提交容器成为一个新的副本</span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名：[TAG]</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">docker run -it -p 8080:8080 tomcat</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/46.png" class>

<p>这是一个前台程序</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/47.png" class>

<p>将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝</p>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/48.png" class>



 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/49.png" class>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit -a=&quot;paidaxing&quot; -m=&quot;add webapps app&quot; 当前容器的id tomcat02:1.0</span><br></pre></td></tr></table></figure>
 <img data-src="/2021/04/16/Docker%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/50.png" class>

<p>发现新的版本，比之前的大了一些，因为里面记录了我们的改动</p>
<blockquote>
<p>如果想保存当前容器的状态，可以通过commit提交，获得一个镜像</p>
<p>好比我们以前学习VM的时候的快照</p>
<p>到这里算是入门了</p>
<p>接下来三个部分是docker的精髓</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
</search>
