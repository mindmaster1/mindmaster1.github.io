<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTTP/1.1深入学习（一）</title>
    <url>/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="HTTP解决了什么问题"><a href="#HTTP解决了什么问题" class="headerlink" title="HTTP解决了什么问题"></a>HTTP解决了什么问题</h2><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source_posts\HTTP-1-1深入学习\image01.png" alt="image-20220216145214793"></p>
<p>解决 WWW 信息交互必须面对的需求：</p>
<ul>
<li><p> 低门槛 </p>
</li>
<li><p>可扩展性：巨大的用户群体，超长的寿命 </p>
</li>
<li><p> 分布式系统下的 Hypermedia：大粒度数据的网络传输 </p>
</li>
<li><p>Internet 规模 </p>
<ul>
<li><p>无法控制的 scalability </p>
<ul>
<li><p>不可预测的负载、非法格式的数据、恶意消息 </p>
</li>
<li><p>客户端不能保持所有服务器信息，服务器不能保持多个请求间的状态信息</p>
<p>独立的组件部署：新老组件并存</p>
<p>向前兼容：自 1993 年起 HTTP0.9\1.0（1996）已经被广泛使用</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source_posts\HTTP-1-1深入学习\image02.png" alt="image-20220216145500667"></p>
<h2 id="浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式"><a href="#浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式" class="headerlink" title="浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式"></a>浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式</h2><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/BLOG\source\_posts\HTTP-1-1深入学习\image03.png" alt="image-20220216143022772" style="zoom:150%;">

<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143059824.png" alt="image-20220216143059824"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143217688.png" alt="image-20220216143217688"></p>
<p>一种无状态的、应用层的、以<strong>请求/应答方式</strong>运行的协议，使用可扩展的语义和自描述消息格式，与基于网络的超文本信息系统灵活的互动。</p>
<h3 id="HTTP的协议格式"><a href="#HTTP的协议格式" class="headerlink" title="HTTP的协议格式"></a>HTTP的协议格式</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143444135.png" alt="image-20220216143444135"></p>
<h4 id="ABNF-扩充巴科斯-瑙尔范式-操作符"><a href="#ABNF-扩充巴科斯-瑙尔范式-操作符" class="headerlink" title="ABNF(扩充巴科斯-瑙尔范式)操作符"></a>ABNF(扩充巴科斯-瑙尔范式)操作符</h4><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143600821.png" alt="image-20220216143600821"></p>
<p><strong><em>ABNF的核心规则</em></strong></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143608965.png" alt="image-20220216143608965"></p>
<blockquote>
<p>基于ABNF描述的HTTP协议格式 + 具体实例</p>
</blockquote>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143758587.png" alt="image-20220216143758587"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216143824981.png" alt="image-20220216143824981"></p>
<h2 id="网络分层：OSI模型与TCP-IP模型"><a href="#网络分层：OSI模型与TCP-IP模型" class="headerlink" title="网络分层：OSI模型与TCP/IP模型"></a>网络分层：OSI模型与TCP/IP模型</h2><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144746312.png" alt="image-20220216144746312"></p>
<h3 id="OSI模型与TCP模型的对照"><a href="#OSI模型与TCP模型的对照" class="headerlink" title="OSI模型与TCP模型的对照"></a>OSI模型与TCP模型的对照</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144826027.png" alt="image-20220216144826027"></p>
<h3 id="在不同层之间的报文头部封装"><a href="#在不同层之间的报文头部封装" class="headerlink" title="在不同层之间的报文头部封装"></a>在不同层之间的报文头部封装</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216144956500.png" alt="image-20220216144956500"></p>
<p>注意一下在图中表明的各层的报文分别叫什么名字。</p>
<h2 id="评估Web架构的关键属性"><a href="#评估Web架构的关键属性" class="headerlink" title="评估Web架构的关键属性"></a>评估Web架构的关键属性</h2><p>HTTP 协议应当在以下属性中取得可接受的均衡：</p>
<ul>
<li><strong>性能</strong> Performance：影响高可用的关键因素 </li>
<li><strong>可伸缩性</strong> Scalability：支持部署可以互相交互的大量组件 </li>
<li><strong>简单性</strong> Simplicity：易理解、易实现、易验证 </li>
<li><strong>可见性</strong> Visiable：对两个组件间的交互进行监视或者仲裁的能力。如缓存、分层设计等</li>
<li><strong>可移植性</strong> Portability：在不同的环境下运行的能力 </li>
<li><strong>可靠性</strong> Reliability：出现部分故障时，对整体影响的程度 </li>
<li><strong>可修改性</strong> Modifiability：对系统作出修改的难易程度，由可进化性、可定制性、可扩展性、可配置性、可重用性构成</li>
</ul>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154311688.png" alt="image-20220216154311688"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154333582.png" alt="image-20220216154333582"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154407111.png" alt="image-20220216154407111"></p>
<h2 id="从五种架构风格推导出HTTP的REST架构"><a href="#从五种架构风格推导出HTTP的REST架构" class="headerlink" title="从五种架构风格推导出HTTP的REST架构"></a>从五种架构风格推导出HTTP的REST架构</h2><p> <img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154624220.png" alt="image-20220216154624220"></p>
<h3 id="数据流风格-Data-flow-Styles"><a href="#数据流风格-Data-flow-Styles" class="headerlink" title="数据流风格 Data-flow Styles"></a>数据流风格 Data-flow Styles</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154806375.png" alt="image-20220216154806375"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216154827521.png" alt="image-20220216154827521"></p>
<h3 id="复制风格"><a href="#复制风格" class="headerlink" title="复制风格"></a>复制风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155000320.png" alt="image-20220216155000320"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155007623.png" alt="image-20220216155007623"></p>
<h3 id="分层风格"><a href="#分层风格" class="headerlink" title="分层风格"></a>分层风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155144846.png" alt="image-20220216155144846"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155211840.png" alt="image-20220216155211840"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155244132.png" alt="image-20220216155244132"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155251415.png" alt="image-20220216155251415"></p>
<h3 id="移动代码风格-Mobile-Code-Styles"><a href="#移动代码风格-Mobile-Code-Styles" class="headerlink" title="移动代码风格 Mobile Code Styles"></a>移动代码风格 Mobile Code Styles</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155401997.png" alt="image-20220216155401997"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155440972.png" alt="image-20220216155440972"></p>
<h3 id="点对点风格"><a href="#点对点风格" class="headerlink" title="点对点风格"></a>点对点风格</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155509897.png" alt="image-20220216155509897"></p>
<p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155556884.png" alt="image-20220216155556884"></p>
<h3 id="不同风格之间的演化"><a href="#不同风格之间的演化" class="headerlink" title="不同风格之间的演化"></a>不同风格之间的演化</h3><p><img data-src="/2022/02/16/HTTP-1-1%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220216155625246.png" alt="image-20220216155625246"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP报文</title>
    <url>/2022/02/23/HTTP%E6%8A%A5%E6%96%87/</url>
    <content><![CDATA[<h1 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h1><p>HTTP报文是在HTTP应用程序之间发送的数据块。这些数据块以一些文本形式的**<em>元信息**</em>（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着<strong>可选的数据部分</strong>。这些报文在客户端、服务器和代理之间流动。</p>




<h2 id="报文的组成部分"><a href="#报文的组成部分" class="headerlink" title="报文的组成部分"></a>报文的组成部分</h2><p>不论是请求还是响应，由三部分组成；</p>
<blockquote>
<p>起始行(start line)、包含属性的首部(header)块，可选的、包含数据的主体（body）</p>
</blockquote>


<p>起始行和首部就是由行分隔的ASCII文本。每行都以一个由两个字符组成的行终止序列作为结束，其中包括一个回车符（ASCII码13）和一个换行符（ASCII码10）。 这个行终止序列可以写做CRLF.需要指出的是，尽管HTTP规范中说明应该用 CRLF来表示行终止，但稳健的应用程序也应该接受单个换行符作为行的终止。有 些老的，或不完整的HTTP应用程序并不总是既发送回车符，又发送换行符。</p>
<h3 id="报文的语法"><a href="#报文的语法" class="headerlink" title="报文的语法"></a>报文的语法</h3><p>分为：【**<em>请求报文和响应报文**</em>】</p>


<p> <strong><em>浏览器发起HTTP请求的典型场景与ABNF定义HTTP协议格式</em></strong></p>






<h3 id="HTTP的协议格式"><a href="#HTTP的协议格式" class="headerlink" title="HTTP的协议格式"></a>HTTP的协议格式</h3> 



<h4 id="ABNF-扩充巴科斯-瑙尔范式-操作符"><a href="#ABNF-扩充巴科斯-瑙尔范式-操作符" class="headerlink" title="ABNF(扩充巴科斯-瑙尔范式)操作符"></a>ABNF(扩充巴科斯-瑙尔范式)操作符</h4> 

<p><strong><em>ABNF的核心规则</em></strong></p>
 



<blockquote>
<p>基于ABNF描述的HTTP协议格式 + 具体实例</p>
</blockquote>
 







<h3 id="起始行-【Start-line】"><a href="#起始行-【Start-line】" class="headerlink" title="起始行 【Start-line】"></a>起始行 【Start-line】</h3><h4 id="请求行-【Request-line】"><a href="#请求行-【Request-line】" class="headerlink" title="请求行 【Request-line】"></a>请求行 【Request-line】</h4><p>请求报文请求服务器对资源进行一些操作。请求报文的起始行，或称为请求行，包含了一个<strong>方法</strong>和一个<strong>请求URL</strong>,这个方法描述了服务器应该执行的操作，请求URL 描述了要对哪个资源执行这个方法。请求行中还包含<strong>HTTP的版本</strong>，用来告知服务 器，客户端使用的是哪种HTTP。</p>
<h4 id="响应行-【Response-line】"><a href="#响应行-【Response-line】" class="headerlink" title="响应行 【Response-line】"></a>响应行 【Response-line】</h4><p>响应报文承载了状态信息和操作产生的所有结果数据，将其返回给客户端。响应报文的起始行，或称为响应行，包含了响应报文使用的HTTP版本、数字状态码，以及描述操作状态的文本形式的原因短语。</p>
<p><strong><em>对起始行和响应行中的具体内容进行描述</em></strong></p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><table>
<thead>
<tr>
<th>方 法</th>
<th>描 述</th>
<th>是否包含主体</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GET</td>
<td>从服务器获取一份文档</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>HEAD</td>
<td>只从服务器获取文档的首部</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>POST</td>
<td>向服务器发送需要处理的数据</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>PUT</td>
<td>将请求的主体部分存储在服务器上</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>TRACE</td>
<td>对可能经过代理服务器传送到服务器上去的报文进行追踪</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>OPTIONS</td>
<td>决定可以在服务器上执行哪些方法</td>
<td>否</td>
<td></td>
</tr>
<tr>
<td>DELETE</td>
<td>从服务器上删除–份文档</td>
<td>否</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p><strong>HEAD</strong>: lHEAD方法与GET方法的行为很类似，但服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检査。</p>
<ul>
<li>在不获取资源的情况下了解资源的情况（比如，判断其类型）</li>
<li>通过査看响应中的状态码，看看某个对象是否存在</li>
<li>通过査看首部，测试资源是否被修改了。</li>
</ul>
</li>
<li><p><strong>PUT</strong>：PUT方法的语义就是让服务器用请求的主体部分来创建一个由所请求的URL命名 的新文档，或者，如果那个URL已经存在的话，就用这个主体来替代它。</p>
<p>因为PUT允许用户对内容进行修改，所以很多Web服务器都要求在执行PUT之 前，用密码登录。</p>
 
</li>
<li><p><strong>POST</strong>:POST方法起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方。</p>




</li>
</ul>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>方法是用来告诉服务器做什么事情的，状态码则用来告诉客户端，发生了什么事情。 状态码位于响应的起始行中。</p>
<table>
<thead>
<tr>
<th>整体范围</th>
<th>已定义范围</th>
<th>分 类</th>
</tr>
</thead>
<tbody><tr>
<td>100 ~ 199</td>
<td>100 ~ 101</td>
<td>信息提示</td>
</tr>
<tr>
<td>200 - 299</td>
<td>200 〜206</td>
<td>成功</td>
</tr>
<tr>
<td>300 ~ 399</td>
<td>300 ~ 305</td>
<td>重定向</td>
</tr>
<tr>
<td>400 ~ 499</td>
<td>400 ~ 415</td>
<td>客户端错误</td>
</tr>
<tr>
<td>500 ~ 599</td>
<td>500 ~ 505</td>
<td>服务器错误</td>
</tr>
</tbody></table>
<p>【**<em>原因短语**</em>】：原因短语和状态码是成对出现的。原因短语是状态码的可读版本，应用程序开发者 将其传送给用户，用以说明在请求期间发生了什么情况。</p>
<h3 id="首部-【header-field】"><a href="#首部-【header-field】" class="headerlink" title="首部 【header-field】"></a>首部 【header-field】</h3>

<p>每个HTTP首部都有-种简单的语法：名字后面跟着冒号（：），然后跟上**<em>可选的空格**</em>，再跟上字段值，最后是一个CRLF。</p>
<table>
<thead>
<tr>
<th>首部实例</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>Date：Tue,30ct 1997 02:16:03 GMT</td>
<td>服务器产生响应的日期</td>
</tr>
<tr>
<td>Content-length：15040</td>
<td>实体的主体部分包含了 15 040字节的数据</td>
</tr>
<tr>
<td>Content-type:image/gif</td>
<td>实体的主体部分是一个GIF图片</td>
</tr>
</tbody></table>
<p> 首部延续行：</p>
<p>将长的首部行分为多行可以提高可读性，多出来的每行前面至少要有一个空格或制表符（tab）。</p>
 



<h3 id="Messege-body"><a href="#Messege-body" class="headerlink" title="Messege-body"></a>Messege-body</h3><p>HTTP报文的第三部分是可选的实体主体部分。实体的主体是HTTP报文的负荷。 就是HTTP要传输的内容。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>LVS负载均衡</title>
    <url>/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
    <content><![CDATA[<blockquote>
<h3 id="LVS是什么"><a href="#LVS是什么" class="headerlink" title="LVS是什么?"></a>LVS是什么?</h3></blockquote>
<p>LVS，全称Linux Virtual Server，是国人章文嵩发起的一个开源项目。<br> 在社区具有很大的热度，是一个基于四层、具有强大性能的反向代理服务器。<br> <code>早期使用lvs需要修改内核才能使用，但是由于性能优异，现在已经被收入内核。</code></p>
<p>LVS通过工作于内核的ipvs模块来实现功能，其主要工作于netfilter 的INPUT链上。<br> 而用户需要对ipvs进行操作配置则需要使用ipvsadm这个工具。<br> ipvsadm主要用于设置lvs模型、调度方式以及指定后端主机。</p>
<blockquote>
<h3 id="LVS中的角色"><a href="#LVS中的角色" class="headerlink" title="LVS中的角色"></a>LVS中的角色</h3></blockquote>
<h5 id="LVS的一些相关术语"><a href="#LVS的一些相关术语" class="headerlink" title="LVS的一些相关术语"></a><strong>LVS的一些相关术语</strong></h5><p>LVS的模型中有两个角色：<br> **调度器:**Director，又称为Dispatcher，Balancer<br> <code>调度器主要用于接受用户请求。</code><br> **真实主机:**Real Server，简称为RS。<br> <code>用于真正处理用户的请求。</code></p>
<p>而为了更好地理解，我们将所在角色的IP地址分为以下三种：<br> <strong>Director Virtual IP:**调度器用于与客户端通信的IP地址，简称为VIP<br> **Director IP</strong>:调度器用于与RealServer通信的IP地址，简称为DIP。<br> <strong>Real Server :</strong> 后端主机的用于与调度器通信的IP地址，简称为RIP。</p>
<img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/02.webp" class>

<p>基本模型</p>
<blockquote>
<h3 id="LVS的三种调度模式"><a href="#LVS的三种调度模式" class="headerlink" title="LVS的三种调度模式"></a>LVS的三种调度模式</h3></blockquote>
<h3 id="LVS-NATNetwork-Address-Transform"><a href="#LVS-NATNetwork-Address-Transform" class="headerlink" title="LVS-NATNetwork Address Transform"></a>LVS-NAT<code>Network Address Transform</code></h3><h6 id="示意图和调度步骤"><a href="#示意图和调度步骤" class="headerlink" title="示意图和调度步骤"></a><strong>示意图和调度步骤</strong></h6><img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/01.webp" class>

<p>LVS-NAT</p>
<h6 id="原理："><a href="#原理：" class="headerlink" title="原理："></a><strong>原理：</strong></h6><p>基于ip伪装<code>MASQUERADES</code>，原理是多目标DNAT。<br> 所以请求和响应都经由Director调度器。</p>
<h6 id="LVS-NAT的优点与缺点"><a href="#LVS-NAT的优点与缺点" class="headerlink" title="LVS-NAT的优点与缺点"></a><strong>LVS-NAT的优点与缺点</strong></h6><h6 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>支持端口映射</li>
<li>RS可以使用任意操作系统</li>
<li>节省公有IP地址。<br> <code>RIP和DIP都应该使用同一网段私有地址，而且RS的网关要指向DIP。</code><br> <code>使用nat另外一个好处就是后端的主机相对比较安全。</code></li>
</ul>
<h6 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>请求和响应报文都要经过Director转发;极高负载时，Director可能成为系统瓶颈。<br> <code>就是效率低的意思。</code></li>
</ul>
<h3 id="LVS-TUNIP-Tuneling"><a href="#LVS-TUNIP-Tuneling" class="headerlink" title="LVS-TUNIP Tuneling"></a>LVS-TUN<code>IP Tuneling</code></h3><h6 id="示意图和调度步骤-1"><a href="#示意图和调度步骤-1" class="headerlink" title="示意图和调度步骤"></a><strong>示意图和调度步骤</strong></h6><img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/03.webp" class>

<p>LVS-TUN</p>
<h6 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a><strong>原理：</strong></h6><p>基于隧道封装技术。在IP报文的外面再包一层IP报文。<br> 当Director接收到请求的时候，选举出调度的RealServer<br> 当接受到从Director而来的请求时，RealServer则会使用lo接口上的VIP直接响应CIP。<br> 这样CIP请求VIP的资源，收到的也是VIP响应。</p>
<h6 id="LVS-TUN的优点与缺点"><a href="#LVS-TUN的优点与缺点" class="headerlink" title="LVS-TUN的优点与缺点"></a><strong>LVS-TUN的优点与缺点</strong></h6><h6 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>RIP,VIP,DIP都应该使用公网地址，且RS网关不指向DIP;<br> <code>只接受进站请求，解决了LVS-NAT时的问题，减少负载。</code><br> <code>请求报文经由Director调度，但是响应报文不需经由Director。</code></li>
</ul>
<h6 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>不指向Director所以不支持端口映射。</li>
<li>RS的OS必须支持隧道功能。</li>
<li>隧道技术会额外花费性能，增大开销。</li>
</ul>
<h3 id="LVS-DRDirect-Routing"><a href="#LVS-DRDirect-Routing" class="headerlink" title="LVS-DRDirect Routing"></a>LVS-DR<code>Direct Routing</code></h3><h6 id="示意图和调度步骤-2"><a href="#示意图和调度步骤-2" class="headerlink" title="示意图和调度步骤"></a><strong>示意图和调度步骤</strong></h6><img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/04.webp" class>

<p>LVS-DR</p>
<h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h6><p>当Director接收到请求之后，通过调度方法选举出RealServer。<br> 讲目标地址的MAC地址改为RealServer的MAC地址。<br> RealServer接受到转发而来的请求，发现目标地址是VIP。<code>RealServer配置在lo接口上。</code><br> 处理请求之后则使用lo接口上的VIP响应CIP。</p>
<h6 id="LVS-DR的优点与缺点"><a href="#LVS-DR的优点与缺点" class="headerlink" title="LVS-DR的优点与缺点"></a><strong>LVS-DR的优点与缺点</strong></h6><h6 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a>优点：</h6><ul>
<li>RIP可以使用私有地址，也可以使用公网地址。<br> <code>只要求DIP和RIP的地址在同一个网段内。</code></li>
<li>请求报文经由Director调度，但是响应报文不经由Director。</li>
<li>RS可以使用大多数OS</li>
</ul>
<h6 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a>缺点：</h6><ul>
<li>不支持端口映射。</li>
<li>不能跨局域网。</li>
</ul>
<h6 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h6><p>三种模型虽然各有利弊，但是由于追求性能和便捷，DR是目前用得最多的LVS模型。</p>
<blockquote>
<h3 id="LVS的八种调度方法"><a href="#LVS的八种调度方法" class="headerlink" title="LVS的八种调度方法"></a>LVS的八种调度方法</h3></blockquote>
<h5 id="静态方法-仅依据算法本身进行轮询调度"><a href="#静态方法-仅依据算法本身进行轮询调度" class="headerlink" title="静态方法:仅依据算法本身进行轮询调度"></a>静态方法:仅依据算法本身进行轮询调度</h5><ul>
<li>RR:Round Robin,轮调<br> <code>一个接一个，自上而下</code></li>
<li>WRR:Weighted RR，加权论调<br> <code>加权，手动让能者多劳。</code></li>
<li>SH:SourceIP Hash<br> <code>来自同一个IP地址的请求都将调度到同一个RealServer</code></li>
<li>DH:Destination Hash<br> <code>不管IP，请求特定的东西，都定义到同一个RS上。</code></li>
</ul>
<h5 id="动态方法-根据算法及RS的当前负载状态进行调度"><a href="#动态方法-根据算法及RS的当前负载状态进行调度" class="headerlink" title="动态方法:根据算法及RS的当前负载状态进行调度"></a>动态方法:根据算法及RS的当前负载状态进行调度</h5><ul>
<li>LC:least connections(最小链接数)<br> <code>链接最少，也就是Overhead最小就调度给谁。</code><br> <code>假如都一样，就根据配置的RS自上而下调度。</code></li>
<li>WLC:Weighted Least Connection (加权最小连接数)<br> <code>这个是LVS的默认算法。</code></li>
<li>SED:Shortest Expection Delay(最小期望延迟)<br> <code>WLC算法的改进。</code></li>
<li>NQ:Never Queue<br> <code>SED算法的改进。</code></li>
<li>LBLC:Locality-Based Least-Connection,基于局部的的LC算法<br> 正向代理缓存机制。访问缓存服务器，调高缓存的命中率。<br> 和传统DH算法比较，考虑缓存服务器负载。可以看做是DH+LC<br> 如果有两个缓存服务器<br> 1.只要调度到其中的一个缓存服务器，那缓存服务器内就会记录下来。下一次访问同一个资源的时候也就是这个服务器了。   (DH)<br> 2.有一个用户从来没有访问过这两个缓存服务器，那就分配到负载较小的服务器。<code>LC</code></li>
</ul>
<p>LBLCR:Locality-Based Least-Connection  with  Replication(带复制的lblc算法)<br> 缓存服务器中的缓存可以互相复制。<br> 因为即使没有，也能立即从另外一个服务器内复制一份，并且均衡负载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">man ipvsadm有讲这几种动态或者静态的rs调度方法</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="配置LVS-DR"><a href="#配置LVS-DR" class="headerlink" title="配置LVS-DR"></a>配置LVS-DR</h4></blockquote>
<table>
<thead>
<tr>
<th align="center">主机名</th>
<th align="center">主机地址</th>
<th align="center">角色</th>
</tr>
</thead>
<tbody><tr>
<td align="center">node1</td>
<td align="center">DIP:192.168.2.201，VIP:192.168.2.211</td>
<td align="center">Director</td>
</tr>
<tr>
<td align="center">node3</td>
<td align="center">RIP:192.168.2.203，VIP:192.168.2.211</td>
<td align="center">RealServer</td>
</tr>
<tr>
<td align="center">node4</td>
<td align="center">RIP:192.168.2.204，VIP:192.168.2.211</td>
<td align="center">RealServer</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本文中的主机系统均为CentOS7.1，Apache2.4，数据库：MariaDB-5.5.50</span><br></pre></td></tr></table></figure>
<p>实验拓扑：</p>
<img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/05.webp" class>

<p>lvs-dr实验拓扑</p>
<p><strong>(1)在Director上配置VIP和DIP</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  [root@bc ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736</span><br><span class="line">    TYPE=Ethernet</span><br><span class="line">    BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">    DEFROUTE=yes</span><br><span class="line">    PEERDNS=yes</span><br><span class="line">    PEERROUTES=yes</span><br><span class="line">    NAME=eno16777736</span><br><span class="line">    DEVICE=eno16777736</span><br><span class="line">    ONBOOT=yes</span><br><span class="line">    IPADDR=<span class="string">&quot;192.168.2.201&quot;</span></span><br><span class="line">    NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line">    DNS1=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line">    GATEWAY=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line"></span><br><span class="line">[root@bc ~]# vim /etc/sysconfig/network-scripts/ifcfg-eno16777736:0</span><br><span class="line">    TYPE=Ethernet</span><br><span class="line">    BOOTPROTO=<span class="string">&quot;static&quot;</span></span><br><span class="line">    NAME=eno16777736:<span class="number">0</span></span><br><span class="line">    ONBOOT=yes</span><br><span class="line">    IPADDR=<span class="string">&quot;192.168.2.211&quot;</span></span><br><span class="line">    NETMASK=<span class="string">&quot;255.255.255.0&quot;</span></span><br><span class="line">    DNS1=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line">    GATEWAY=<span class="string">&quot;192.168.2.1&quot;</span></span><br><span class="line">    ONPARENT=yes</span><br></pre></td></tr></table></figure>
<p>重启网络之后查看配置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@bc ~]# service NetworkManager stop</span><br><span class="line">  Redirecting to /bin/systemctl stop  NetworkManager.service</span><br><span class="line">[root@bc ~]# service network restart</span><br><span class="line">  Restarting network (via systemctl):                        [  OK  ]</span><br><span class="line">[root@bc ~]# ifconfig</span><br><span class="line">  eno16777736: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.2</span><span class="number">.201</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.2</span><span class="number">.255</span></span><br><span class="line">        inet6 fe80::<span class="number">250</span>:56ff:fe3c:d757  prefixlen <span class="number">64</span>  scopeid <span class="number">0x20</span>&lt;link&gt;</span><br><span class="line">        ether <span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:3c:d7:<span class="number">57</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line">        RX packets <span class="number">88853</span>  bytes <span class="number">14843664</span> (<span class="number">14.1</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">79195</span>  bytes <span class="number">6551143</span> (<span class="number">6.2</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  eno16777736:<span class="number">0</span>: flags=<span class="number">4163</span>&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu <span class="number">1500</span></span><br><span class="line">        inet <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span>  netmask <span class="number">255.255</span><span class="number">.255</span><span class="number">.0</span>  broadcast <span class="number">192.168</span><span class="number">.2</span><span class="number">.255</span></span><br><span class="line">        ether <span class="number">00</span>:<span class="number">50</span>:<span class="number">56</span>:3c:d7:<span class="number">57</span>  txqueuelen <span class="number">1000</span>  (Ethernet)</span><br><span class="line"></span><br><span class="line">  lo: flags=<span class="number">73</span>&lt;UP,LOOPBACK,RUNNING&gt;  mtu <span class="number">65536</span></span><br><span class="line">        inet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>  netmask <span class="number">255.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">        inet6 ::<span class="number">1</span>  prefixlen <span class="number">128</span>  scopeid <span class="number">0x10</span>&lt;host&gt;</span><br><span class="line">        loop  txqueuelen <span class="number">0</span>  (Local Loopback)</span><br><span class="line">        RX packets <span class="number">12998</span>  bytes <span class="number">1140269</span> (<span class="number">1.0</span> MiB)</span><br><span class="line">        RX errors <span class="number">0</span>  dropped <span class="number">0</span>  overruns <span class="number">0</span>  frame <span class="number">0</span></span><br><span class="line">        TX packets <span class="number">12998</span>  bytes <span class="number">1140269</span> (<span class="number">1.0</span> MiB)</span><br><span class="line">        TX errors <span class="number">0</span>  dropped <span class="number">0</span> overruns <span class="number">0</span>  carrier <span class="number">0</span>  collisions <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><strong>(2)Director使用ipvsadm修改创建ipvs规则</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[root@bc ~]# ipvsadm -A -t 192.168.2.211:80 -s rr</span><br><span class="line">[root@bc ~]# ipvsadm -a -t 192.168.2.211:80 -r 192.168.2.203 -g</span><br><span class="line">[root@bc ~]# ipvsadm -a -t 192.168.2.211:80 -r 192.168.2.204 -g</span><br><span class="line">[root@bc ~]# ipvsadm -L -n</span><br><span class="line">IP Virtual Server version <span class="number">1.2</span><span class="number">.1</span> (size=<span class="number">4096</span>)</span><br><span class="line">Prot LocalAddress:Port Scheduler Flags</span><br><span class="line">  -&gt; RemoteAddress:Port           Forward Weight ActiveConn InActConn</span><br><span class="line">TCP  <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span>:<span class="number">80</span> rr</span><br><span class="line">  -&gt; <span class="number">192.168</span><span class="number">.2</span><span class="number">.203</span>:<span class="number">80</span>             Route   <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span>         </span><br><span class="line">  -&gt; <span class="number">192.168</span><span class="number">.2</span><span class="number">.204</span>:<span class="number">80</span>             Route   <span class="number">1</span>      <span class="number">0</span>          <span class="number">0</span>   </span><br></pre></td></tr></table></figure>
<p><strong>(3)RealServer安装httpd</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node3 ~]# yum install httpd -y</span><br><span class="line">[root@node4 ~]# yum install httpd -y</span><br></pre></td></tr></table></figure>
<p><code>可以在里面放一个Wordpress,也可以简单echo几个字到index.html</code><br> <strong>(4)node3和node4修改RealServer内核参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">echo <span class="string">&quot;1&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/ip_forward</span><br><span class="line">echo <span class="string">&quot;2&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/all/arp_announce</span><br><span class="line">echo <span class="string">&quot;1&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/all/arp_ignore</span><br><span class="line">echo <span class="string">&quot;1&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/lo/arp_ignore</span><br><span class="line">echo <span class="string">&quot;2&quot;</span> &gt; <span class="regexp">/proc/</span>sys/net/ipv4/conf/lo/arp_announce</span><br><span class="line">ifconfig lo:<span class="number">0</span> <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span>/<span class="number">32</span> broadcast <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span> up</span><br><span class="line">route add -host <span class="number">192.168</span><span class="number">.2</span><span class="number">.211</span> dev lo:<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>修改内核参数，并且配置VIP地址到RealServer的loopback接口上。</code><br> <strong><code>那样的话，当RealServer接到从Director转发而来的数据报文时，RealServer也不会丢弃报文。</code></strong><br> <code>同时，修改了RealServer的参数，局域网内的arp表就只有Director有VIP。</code><br> <code>RealServer的的机器上有VIP这件事，只有RealServer自己知道。</code><br> <strong><code>这样可以保证，当请求到来的时候，第一个会送到Director那里去。</code></strong></p>
<p><strong>(5)测试结果</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[root@node3 httpd]# vim  /var/log/httpd/access_log </span><br><span class="line">[root@node4 httpd]# vim  /var/log/httpd/access_log </span><br></pre></td></tr></table></figure>
<p>效果差不多就是这样:<br> <code>因为我们使用了RR静态调度方法,所以这node3和node4的请求是一人一个。</code></p>
<img data-src="/2021/03/14/LVS%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/06.webp" class>



]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公--Word</title>
    <url>/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/</url>
    <content><![CDATA[<h1 id><a href="#" class="headerlink" title></a></h1><h1 id="Python实现高效自动化Word办公：如何批量合并多个文档-python-docx库）"><a href="#Python实现高效自动化Word办公：如何批量合并多个文档-python-docx库）" class="headerlink" title="Python实现高效自动化Word办公：如何批量合并多个文档(python-docx库）"></a>Python实现高效自动化Word办公：如何批量合并多个文档(python-docx库）</h1><p>在Word文件中，不但有文字内容，还有加粗、红色等格式，而且这些特殊的格式和文字内容是混合在一起的，但如果用Python来读取Word文件，这段文字会被分为纯文字、段落、字体、字号以及表格 等更具体的部分，而且每一个部分都对应着<strong>Python的变量和函数。</strong></p>
<p>用Python读取文件时，你需要记住很多个Python变量和函数。当然了，针对这一点， 你也不用担心，这些变量和函数在Python的Word扩展库<a href="https://python-docx.readthedocs.io/en/latest/#"><strong><em>官方文档</em></strong></a>可以查看。所以如果你需 要某个功能，但是不知道应该用什么变量和函数名称时，可以在官方文档中找到它的名字和 描述信息。</p>
<h3 id="用Python自动合并两个Word文件"><a href="#用Python自动合并两个Word文件" class="headerlink" title="用Python自动合并两个Word文件"></a>用Python自动合并两个Word文件</h3><ul>
<li><p>文件一（内容包含字体、字号、颜色等额外信息）：</p>
 <img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/image.png" class>
</li>
<li><p>文件二（内容文字出现在表格中）:</p>
 <img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-Word/image01.png" class>

</li>
</ul>
<blockquote>
<p>第一个文件中，字体使用了黑体和宋体字，此外还有红色字体和加粗等格式。现在我需要 只提取其中的文字内容，不带任何格式。 </p>
<p>第二个文件中，文字被放在了一张表格里。现在我需要用Python把表格中的文字提取出 来，合并成一个新的文件。</p>
</blockquote>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mrge_without_format</span>(<span class="params">docfiles:<span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    只获取内容进行合并</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#遍历文件</span></span><br><span class="line">    <span class="keyword">for</span> docx_file <span class="keyword">in</span> <span class="built_in">sorted</span>(docfiles):</span><br><span class="line">        another_doc = Document(docx_file)</span><br><span class="line">        <span class="comment"># 获取每个文件的的所有段落</span></span><br><span class="line">        paras = another_doc.paragraphs</span><br><span class="line">        <span class="keyword">for</span> para <span class="keyword">in</span> paras:</span><br><span class="line">            <span class="comment"># 为新的word文件创建一个新段落</span></span><br><span class="line">            newpar = doc.add_paragraph(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            <span class="comment">#将提取的内容写入新的文本段落中</span></span><br><span class="line">            newpar.add_run(para.text)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#所有文件合并完成后在指定路径中保存</span></span><br><span class="line">        doc.save(Path(word_files_path,<span class="string">&#x27;new.docx&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">#调用函数</span></span><br><span class="line">    merge-mrge_without_format(files)</span><br></pre></td></tr></table></figure>


<h3 id="用Python合并Word和其他类型的文件"><a href="#用Python合并Word和其他类型的文件" class="headerlink" title="用Python合并Word和其他类型的文件"></a>用Python合并Word和其他类型的文件</h3><p>相较于其他文件，Word文件支持的格式丰富程度远远高于Txt文件等，所以当这两种格式丰富程度不一致的文件进行合并时，要么向下兼容，去掉Txt不支持的格式；要 么向上兼容，对Txt进行格式再调整。否则容易出现合并之后仍需要手动调整格式的问题，影 响工作效率。</p>
<h4 id="将纯文本和Word文件合并"><a href="#将纯文本和Word文件合并" class="headerlink" title="将纯文本和Word文件合并"></a>将纯文本和Word文件合并</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> docx.shared <span class="keyword">import</span> RGBColor</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># word文件所在路径</span></span><br><span class="line">word_files_path = <span class="string">&#x27;D:/Python自动化办公/Day02/word样例文件&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 取得该目录下所有的docx格式文件</span></span><br><span class="line"><span class="comment"># p = Path(word_files_path)</span></span><br><span class="line"></span><br><span class="line">my_content = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">野老篱边江岸回，柴门不正逐江开。</span></span><br><span class="line"><span class="string">渔人网集澄潭下，贾客船随返照来。</span></span><br><span class="line"><span class="string">长路关心悲剑阁，片云何意傍琴台？</span></span><br><span class="line"><span class="string">王师未报收东郡，城阙秋生画角哀。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_content_mode1</span>(<span class="params">content</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    增加内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    print(doc)</span><br><span class="line">    para = doc.add_paragraph().add_run(content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置字体格式</span></span><br><span class="line">    para.font.name = <span class="string">&#x27;仿宋&#x27;</span></span><br><span class="line">    <span class="comment"># 设置下划线</span></span><br><span class="line">    para.font.underline = <span class="literal">True</span></span><br><span class="line">    <span class="comment"># 设置颜色</span></span><br><span class="line">    para.font.color.rgb = RGBColor(<span class="number">255</span>, <span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line">    <span class="comment"># 其他设置参考官方文档</span></span><br><span class="line">    <span class="comment"># https://python-docx.readthedocs.io/en/latest/api/text.html#run-objects</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line">add_content_mode1(my_content)</span><br><span class="line">doc.save(Path(word_files_path, <span class="string">&#x27;new2.docx&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="将图片和Word文件合并"><a href="#将图片和Word文件合并" class="headerlink" title="将图片和Word文件合并"></a>将图片和Word文件合并</h4><p>我们经常见到的图片格式就有.jpg、.png、.gif等，由于这些格式应用范围广，格式 没有被商业软件加密，所以python-docx库的add_picture函数就能实现把图片插入Word的 功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> shared</span><br><span class="line"></span><br><span class="line">doc = Document()</span><br><span class="line"><span class="comment"># 按英寸设置宽度，添加图片</span></span><br><span class="line">doc_add_picture(<span class="string">&#x27;test.jpg&#x27;</span>,width=shared.Inches(<span class="number">1</span>))</span><br></pre></td></tr></table></figure>


<h4 id="将Execl和Word文件合并"><a href="#将Execl和Word文件合并" class="headerlink" title="将Execl和Word文件合并"></a>将Execl和Word文件合并</h4><ul>
<li><p>使用Python制作邀请函</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">from</span> docx <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">today=datetime.date.today().strftime(<span class="string">&#x27;%Y-%m-%d&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户信息文件</span></span><br><span class="line">customer = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/客户信息.xlsx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邀请函模版</span></span><br><span class="line">invitation = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/邀请函模版.docx&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 邀请函路径</span></span><br><span class="line">invitation_path = <span class="string">&#x27;/Users/edz/Desktop/效率专栏/文章2/邀请函样例文件/&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换内容</span></span><br><span class="line">replace_content = &#123;</span><br><span class="line">    <span class="string">&#x27;&lt;姓名&gt;&#x27;</span> : <span class="string">&#x27;no_name&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;性别&gt;&#x27;</span> : <span class="string">&#x27;m_f&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&lt;今天日期&gt;&#x27;</span> : today</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generat_invitation</span>():</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    生成邀请函文件</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    doc = Document(invitation)</span><br><span class="line">    <span class="comment"># 取出每一段</span></span><br><span class="line">    <span class="keyword">for</span> para <span class="keyword">in</span> doc.paragraphs:</span><br><span class="line">        <span class="keyword">for</span> key, value <span class="keyword">in</span> replace_content.items():</span><br><span class="line">            <span class="keyword">if</span> key <span class="keyword">in</span> para.text:</span><br><span class="line">                <span class="comment"># 逐个关键字进行替换</span></span><br><span class="line">                para.text = para.text.replace(key, value)</span><br><span class="line"></span><br><span class="line">    file_name = PurePath(invitation_path).with_name(replace_content[<span class="string">&#x27;&lt;姓名&gt;&#x27;</span>]).with_suffix(<span class="string">&#x27;.docx&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    doc.save(file_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_customer</span>(<span class="params">customer_file: Path</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    获取邀请函信息</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 从第一个sheet中取出客户信息</span></span><br><span class="line">    data = xlrd.open_workbook(customer_file)</span><br><span class="line">    table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得客户数量</span></span><br><span class="line">    customer_number = table.nrows</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, customer_number):</span><br><span class="line">        content = table.row_values(rowx=line, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">        replace_content[<span class="string">&#x27;&lt;姓名&gt;&#x27;</span>] = content[<span class="number">0</span>]</span><br><span class="line">        replace_content[<span class="string">&#x27;&lt;性别&gt;&#x27;</span>] = content[<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># print(replace_content)</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;&lt;姓名&gt;&#x27;: &#x27;韩梅梅&#x27;, &#x27;&lt;性别&gt;&#x27;: &#x27;女士&#x27;, &#x27;&lt;今天日期&gt;&#x27;: &#x27;2021-01-01&#x27;&#125;</span></span><br><span class="line">        <span class="comment"># &#123;&#x27;&lt;姓名&gt;&#x27;: &#x27;李雷&#x27;, &#x27;&lt;性别&gt;&#x27;: &#x27;先生&#x27;, &#x27;&lt;今天日期&gt;&#x27;: &#x27;2021-01-01&#x27;&#125;</span></span><br><span class="line">        generat_invitation()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    get_customer(customer)</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在对不同类型文件进行合并时，要考虑不同的问题</p>
<blockquote>
<ol>
<li>对于支持格式丰富不同的文件时要考虑格式的兼容性；</li>
<li>  对于图片、音乐、视频和Word合并时要考虑是否是受到word支持的通用格式；</li>
<li>  对于像Excel格式于Word合并时能实现更复杂的功能，代码的复杂程度也会随之提高，一 般需要先分析功能，再进行代码编写。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-图片识别</title>
    <url>/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h1 id="使用Python实现高效自动化图片组在线-离线识别（转文字）"><a href="#使用Python实现高效自动化图片组在线-离线识别（转文字）" class="headerlink" title="使用Python实现高效自动化图片组在线/离线识别（转文字）"></a>使用Python实现高效自动化图片组在线/离线识别（转文字）</h1><h2 id="图片识别转文字的两种方式："><a href="#图片识别转文字的两种方式：" class="headerlink" title="图片识别转文字的两种方式："></a>图片识别转文字的两种方式：</h2><blockquote>
<p>在线识别</p>
<p>优点： 在线识别在初次进行文字识别的时候，准确率非常高。比如对聊天截图中的识别准确率就高达99%。因为在线识别使用了人工智能领域的深度学习算法和文字识别相结合的技术，能够把图片转换成文字后，还能在语义上把相近的字进行二次纠正。 比如说，被识别的内容包含英文单词“Hello”，一旦它的字母“o”被识别成数字“0”，在 线识别软件就会根据上下文语境把这类错误纠正回来，而这种二次纠正的功能在离线识别软 件中是没有的。</p>
<p>缺点：</p>
<ol>
<li>识别文字的过程需要在公有云的服务器上完成。也 就是说需要通过互联网把图片上传到服务器，那么一旦图片过大，或者图片数量比较多，就会导致上传时间过长。对于一些大批量文字识别场景/实时性要求很高的场景，在线识别不能满足要求</li>
<li>图片需要经过互联网传输，识别以后的图片该怎么保存，怎么销毁，是不是会被其他 人得到，这些都是安全风险。总之，信息泄露的风险比较大。所以像公司的合同、财务资料 等涉密程度比较高的扫描件，很少使用在线识别。</li>
</ol>
</blockquote>
<blockquote>
<p>离线识别</p>
<p>这种方式在识别过程中不需要连接网络，节省了在线传输图片的时间，适合那些对实时性要 求比较高或网络信号比较差的场景。</p>
<p>离线识别方式的问题就在于，初次识别文字的准确率比较低，识别完之后必须要经过人 工二次纠正才行。所以在前期人工校对，花费的时间相对来说会比较长。</p>
</blockquote>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image01.png" class>

<h2 id="在线识别"><a href="#在线识别" class="headerlink" title="在线识别"></a>在线识别</h2><p>在线文字识别方式，识别的主要功能的需要放在公有云的服务器中才能实现，所以在代码实 现中就要考虑用户验证和图片加密传输问题。</p>
<p>用户验证能确保识别的结果交还给你本人，图片加密传输能确保图片上的信息不会被其他人 窃取到。这些功能，各个公有云的AI产品都考虑得非常周全，一般会提供给用户一个扩展 库。你要做的，就是安装这些扩展库。</p>
<p><strong>以百度Ai图片转文字识别产品为例</strong></p>
<blockquote>
<p>pip install baidu-aip</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr</span><br><span class="line"></span><br><span class="line">APP_ID = <span class="string">&#x27;&#x27;</span></span><br><span class="line">API_Key = <span class="string">&#x27;&#x27;</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID,API_Key,SECRET_KEY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图片</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_content</span>(<span class="params">filepath</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filepath,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">return</span> fp.read()</span><br><span class="line"></span><br><span class="line">image = get_file_content(<span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用文字识别，图片参数为本地图片</span></span><br><span class="line">result = client.basicGeneral(image)</span><br><span class="line">print(result)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image02.png" class>

<p>当把这三个变量传入AipOcr函数，使用AipOcr函数通过互联网交互后，就可以用来识别用户 是不是被授权使用相应的产品，之后就可以把图片加密发送到AI产品的服务器上了。</p>
<h2 id="离线识别（pytesseract）"><a href="#离线识别（pytesseract）" class="headerlink" title="离线识别（pytesseract）"></a>离线识别（pytesseract）</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开图片</span></span><br><span class="line">image = Image.<span class="built_in">open</span>(<span class="string">&#x27;example.png&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转为灰度图片</span></span><br><span class="line">imgry = image.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line"><span class="comment"># 二值化，采用阈值分割算法，threhold为分割点，根据图片质量调节</span></span><br><span class="line">threhold = <span class="number">150</span></span><br><span class="line">table = []</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    <span class="keyword">if</span> j&lt;threhold:</span><br><span class="line">        table.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        table.append(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">temp = imgry.point(table,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">temp = imgry.point(table,<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OCR识别，调用pytesseract库，lang指定中文，--psm 6表示按行识别，有助于提升准确率</span></span><br><span class="line">text = pytesseract.image_to_string(temp,lang=<span class="string">&quot;chi_sim+eng&quot;</span>,config=<span class="string">&#x27;--psm 6&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印识别结果</span></span><br><span class="line">print(text)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>遇到问题</strong></p>
<p>TesseractNotFoundError: tesseract is not installed or it’s not in your PATH. See README file for more information.</p>
<p><strong>原因</strong>：</p>
<p>pytesseract是依赖c++编写的tesseract工具才能正常工作的，需要先安装teseract</p>
<p><strong>解决</strong>：</p>
<p><a href="https://blog.csdn.net/wang_hugh/article/details/80760940">https://blog.csdn.net/wang_hugh/article/details/80760940</a></p>
</blockquote>
<p>对图片文字离线识别的一般过程如下：</p>
<ul>
<li>图像输入</li>
<li>前期处理，比如二值化，图像降噪，倾斜纠正</li>
<li>文字检测，比如版面分析，字符分割</li>
<li>文本识别，比如字符识别，后期纠正（<strong>影响准确率最大</strong>）</li>
<li>输出文本</li>
</ul>
<p>离线识别训练样本较小，正确率相较于在线识别是不高的。具体的解决方案有以下两种</p>
<blockquote>
<p>通过人工纠正，形成新的训练模型（不断增加算法模型中标本的数量）</p>
</blockquote>
<p>像身份证识别、票据识别、聊天截图等大部分文字识别场景，这些待识别图片采用了印刷体，每个字的间隔都是固定的，所以我们要想提升准确率，通常的做法是对每个字都进行人 工纠错。</p>
<p>所以整个过程你可以理解成三个步骤： 第一步，人工观察； 第二步，对比原始图像； 第三步，把错误的文字手工纠正为正确的汉字。 比如截图中的“某”字，多次识别错误，当我们人工把这些文字改为正确的“某”字之后， 就可以生成一个训练文件，再把训练文件和文字识别的算法合并成新的识别模型。等下次再 识别发票的时候，就可以采用新的模型进行识别。所以再次出  现“某”字，就可以正确识别了。</p>
<p><strong>这种文字标注对于单一场景非常有效，比如名片、火车票、飞机票、发票、车牌的识别场 景，经过手工标注，不断增加样本数量之后，能够让正确率呈对数级别增加。</strong></p>
<blockquote>
<p>使用在线识别软件来优化离线识别软件</p>
</blockquote>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image03.png" class>



<h2 id="识别成功后的文字处理工作"><a href="#识别成功后的文字处理工作" class="headerlink" title="识别成功后的文字处理工作"></a>识别成功后的文字处理工作</h2><p>下图为在线识别的结果</p>
<img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/image04.png" class>

<p>为了能够提取文本内容，去掉记录分段信息的”word”和 “{ }”，需要对这段文字再加工处理。</p>
<p>仔细观察的话，就会发现这段文字是有一定规律的，它的写法就是Python的基本数据类型“字典”，字典类型会强调一对或多对数据之间的映射关系。为了将识别的文字结果进行保存，我们还会使用另一个基本数据类型“列表”，一般用来表示多段文字的并列关系， 为了提取文本内容，我接下来把字典转换成列表就可以实现内容的提取了。 从字典到列表转换的功能怎么实现呢？首先来看一下两种数据类型的定义</p>
<p><img data-src="/2022/01/31/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E5%9B%BE%E7%89%87%E8%AF%86%E5%88%AB/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220131094327030.png" alt="image-20220131094327030"></p>
<p>观察这两个数据类型不难发现，把字典的VALUE存放到列表里就能实现内容的提取了，如果 字典里有多个值，可以使用for循环进行遍历，然后批量提取。对于识别的结果，我们可以采 用一段代码进行从字典到列表的转换。代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">info = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result[<span class="string">&#x27;words_result&#x27;</span>]:</span><br><span class="line">	info.append(i[<span class="string">&#x27;words&#x27;</span>])</span><br><span class="line">print(info)</span><br></pre></td></tr></table></figure>
<p>处理好的内容如下</p>


]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-跨文件字数统计</title>
    <url>/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="使用Python实现快速读写文件，跨文件字数统计"><a href="#使用Python实现快速读写文件，跨文件字数统计" class="headerlink" title="使用Python实现快速读写文件，跨文件字数统计"></a>使用Python实现快速读写文件，跨文件字数统计</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">使用Python来批量统计多个文件的字数和标点符号</span><br></pre></td></tr></table></figure>
<h2 id="实现单个文件字数统计"><a href="#实现单个文件字数统计" class="headerlink" title="实现单个文件字数统计"></a>实现单个文件字数统计</h2><p>统计单个文件的字数，需要用到Python的文件读写函数和变量这两个功能。Python的读写函 数是对文件内容的读取操作，变量呢，用来存储统计好的文件字数。</p>
<ul>
<li>先把要统计的文件读入内存；</li>
<li>再对读入到内存的字数数量进行统计，并用变量保存；</li>
<li>最后是将结果写入统计字数的专用文件中。</li>
</ul>
<h3 id="将文件内容读取到内存中"><a href="#将文件内容读取到内存中" class="headerlink" title="将文件内容读取到内存中"></a>将文件内容读取到内存中</h3><p>Python实现读取文件内容到内存的函数有三个，这三个函数原理相同，但是读取的内容多少有些不同，分别为：</p>
<img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209190932306.png" alt="image-20220209190932306" style="zoom:50%;">

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pathlib</span><br><span class="line">file_name = <span class="string">&quot;./e.txt&quot;</span></span><br><span class="line"><span class="comment"># 取得脚本所在目录</span></span><br><span class="line">current_path = pathlib.PurePath(__file__).parent</span><br><span class="line"></span><br><span class="line"><span class="comment">#和脚本同目录下的要打开文件绝对路径</span></span><br><span class="line">file = current_path.joinpath(file_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 读取文件</span></span><br><span class="line">    content = f.read()</span><br><span class="line">    words = content.rstrip()</span><br><span class="line">    number = <span class="built_in">len</span>(words)</span><br><span class="line">    print(number)</span><br></pre></td></tr></table></figure>
<p>open()函数参数说明：</p>
<p>第一个参数file变量的值是要操作的文件路径和文件名称，你需要正 确指定它所在的路径和文件名称。第二个参数encoding变量的值指定了以哪种字符编码打开文件，错误的字符编码会导致内容读取异常，文字内容显示为“乱码”。</p>
<h4 id="获取完整路径"><a href="#获取完整路径" class="headerlink" title="获取完整路径"></a>获取完整路径</h4><ul>
<li>在代码中使用pathlib库的PurePath()函数，把当前Python脚本的路径转化为标准的 pathlib格式。</li>
<li>通过parent属性去掉脚本的文件名，取得当前脚本所在的路径。</li>
<li>再通过joinpath()函数把脚本所在的路径和e.txt文件名进行拼接，得到e.txt的完整路径。</li>
</ul>
<p>这种取得脚本同目录下的其他文件完整路径的用法，要比直接指定文件完整路径用法更灵活。</p>
<blockquote>
<p>__file__变量比较特殊，它是在Python中预先定义好的一个变量，默认情况下它的值会被 Python自动设置为当前脚本的完整路径名称。有了它，我就可以通过Python脚本的路径取得 e.txt的完整路径了。</p>
</blockquote>
<h4 id="设置字符编码"><a href="#设置字符编码" class="headerlink" title="设置字符编码"></a>设置字符编码</h4><p>第二个参数的作用是设置open()函数使用何种字符编码打开文件。</p>
<h4 id="函数传参调用"><a href="#函数传参调用" class="headerlink" title="函数传参调用"></a>函数传参调用</h4><p>为什们指定这个参数的时候，要特意写出变量名称encoding呢？</p>
<p>在函数定义的时候我们可以为函数指定一个或多个参数，如果使用了多个参数，你在调用函 数的时候需要按顺序依次传入每一个参数。但是如果你想要使用某个参数默认值或不想按照 顺序传入参数时怎么办呢？函数调用时，还可以根据参数的关键字来指定为函数传入哪些参 数。比如说open()函数的参数有7个，</p>
<p><img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209193920724.png" alt="image-20220209193920724"></p>
<p>在open()函数的定义中，encoding参数是open()函数的第4个参数。如果我们只需要第1个和 第4个参数，其他参数需要保持默认时，就可以使用如下格式调用open()函数：</p>
<p><img data-src="/2022/02/06/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E8%B7%A8%E6%96%87%E4%BB%B6%E5%AD%97%E6%95%B0%E7%BB%9F%E8%AE%A1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220209193956499.png" alt="image-20220209193956499"></p>
<p>在代码中，调用open()函数时，由于file参数是open()函数的第一个参数，因此可以不用指定 参数的关键字。encoding参数并非open()函数定义的第二个参数，而是第四个参数，所以需 要指定它的参数名称为encoding，根据open()函数的定义，encoding=”utf-8”会作为 open()函数的第四个参数使用。这种使用关键字作为函数的参数的方式，也被称作<strong>函数的关键字传参方式</strong>。</p>
<h3 id="with使用"><a href="#with使用" class="headerlink" title="with使用"></a>with使用</h3><p>with关键字下面的代码是缩进形式，和with关键字形成了一个语句块</p>
<p>在with语句 块结束之后，不必手动调用close()函数关闭文件，Python会自动将文件关闭。因此，你会看到我在程序中调用了open()函数打开文件，但是没有调用关闭文件的close()函数。</p>
<p>总的来说，相对于手动调用close()函数来关闭文件，使用with函数减少了打开过多文件造成系统资源浪费和数据丢失的风险。</p>
<h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>正确使用了open()函数的两个参数以后，会返回一个表示文件的对象f, 只有设置了正确 的文件路径、文件名称和字符编码，才能继续进行文件读取操作。文件的读取操作使用的是 read()函数，read()函数会根据文件的对象f，按照open()函数定义好的打开方式进行逐个字 的读取操作。Python对文件的其他操作，全都需要通过文件操作函数调用对象f来完成。</p>
<h4 id="统计文件的字数"><a href="#统计文件的字数" class="headerlink" title="统计文件的字数"></a>统计文件的字数</h4><p>Python的内置函数**len()**来实现</p>
<p>len()函数在Python中最初设计的功能就是统计字符串的长度，即字符串中有多少字符。利用len()函数可以对字符串数据类型进行操作的特性，将文件一次性读入内存，放入字符串数据类型中。我在统计字数之前还增加了一个rstrip()函数，它会自动剔除出现在文件末尾的空行、空格，让你统计的结果更精确。</p>
<p>在进行文件字数统计的时候，需要注意，在代码中使用了read()函数实现了对文件内容的一<br>次性读取到内存的功能。如果你的文件较大，我建议你使用readline()函数按行读取，并逐行<br>统计字数，否则容易出现内存不足的问题。</p>
<h4 id="将统计结果写入文件"><a href="#将统计结果写入文件" class="headerlink" title="将统计结果写入文件"></a>将统计结果写入文件</h4><p>将统计结果写入文件，可以对<strong>open()函数</strong>打开文件方式进行简单的修改，就可以实现文件写入功能了，写入文件的代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;total.txt&quot;</span>, <span class="string">&quot;w&quot;</span>, encodong=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">	 f.write(<span class="string">&quot;15个字符&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>open()函数的第二个参数表示文件的打开方式，它默认值是“r”，代表了文件以读取方式进行打开。这时对象f只能进行文件读取操作，我们需要将第二个参数指定为”w”，就可以使用wirte()函数对文件进行写入操作了。而write()函数的第一个参数就是即将要写入文件的内容。</p>
<h3 id="怎么统计多个文件的次数"><a href="#怎么统计多个文件的次数" class="headerlink" title="怎么统计多个文件的次数"></a>怎么统计多个文件的次数</h3><p>对多个文件的字数统计，就可以使用for循环来实现批量读取多个文件的内容。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Path(src_path)</span><br><span class="line">files = [x <span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath(x).match(<span class="string">&#x27;*.txt&#x27;</span>)]</span><br><span class="line"><span class="keyword">for</span> files <span class="keyword">in</span> files:</span><br><span class="line">	<span class="keyword">with</span> <span class="built_in">open</span>(file,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        content = f.read()</span><br><span class="line">words = content.rstrip()</span><br><span class="line">    	number = <span class="built_in">len</span>(words)</span><br></pre></td></tr></table></figure>
<p>数字类型是一种非常适合进行整数、浮点数的转换和算数几何计算最常用的类型。在单文件字数统计的场景，用来储存每个文件的字数是最合适的类型。如果把场景扩展到统计多个文件的字数，使用一个数字类型的变量是不够的，你需要在循环中再增加一个新的数字类型的变量，对多个文件的统计结果进行依次累加就可以了。</p>
]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公</title>
    <url>/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/</url>
    <content><![CDATA[<h1 id="任务场景一：拆分与合并–快速的批量处理内容相似的Excel"><a href="#任务场景一：拆分与合并–快速的批量处理内容相似的Excel" class="headerlink" title="任务场景一：拆分与合并–快速的批量处理内容相似的Excel"></a>任务场景一：拆分与合并–快速的批量处理内容相似的Excel</h1><blockquote>
<p>批量合并</p>
<p>假设你需要对某些工作内容进行问卷调查，这时你用Excel做了调查问卷模版。 我想你会这样做：先把Excel通过工作群分发给所有员工，再把群里收集到的反馈附件汇总 成一个文件。</p>
<p>批量拆分</p>
<p>假设你是公司的财务人员，你需要使用Excel对员工工资进行核算，之后再打印 出来。但是公司要求员工薪水保密，所以每个员工的工资需要拆分成一个独立的文件，最 后还需要打印出来。</p>
</blockquote>
<ul>
<li>解决方案：使用Python实现自动化批量处理。<ul>
<li>安装扩展库：支持Excel读取的扩展库叫做xlrd库，支持Excel写入的扩展库叫做xlwt库</li>
<li>找到整个工作过程当中重复操作的部分；</li>
<li> 将重复操作的部分需要哪些手工操作找出来，使用Python编写程序代替手工操作的部分；</li>
<li> 对重复的部分，使用循环语句进行批量处理。</li>
<li>可以使用绘制时序图来实现手工操作到Python程序的过渡</li>
</ul>
</li>
</ul>
<img data-src="/2022/01/30/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/image.png" class>





<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="Merge-py"><a href="#Merge-py" class="headerlink" title="Merge.py"></a>Merge.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入Excel和文件操作库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定要合并excel的路径</span></span><br><span class="line">src_path = <span class="string">&#x27;D:/Python自动化办公/Day01/调查问卷&#x27;</span></span><br><span class="line"><span class="comment"># 指定合并完成的路径</span></span><br><span class="line">dst_file = <span class="string">&#x27;D:/Python自动化办公/Day01/result/结果.xls&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得给目录下所有的xlsx格式文件</span></span><br><span class="line">p = Path(src_path)</span><br><span class="line">files = [x <span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath(x).match(<span class="string">&#x27;*.xls&#x27;</span>)]</span><br><span class="line">print(files)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备列表存放读取结果</span></span><br><span class="line">content = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个文件进行重复处理</span></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">    <span class="comment"># 用文件作为每个用户的标识</span></span><br><span class="line">    username = file.stem</span><br><span class="line">    data = xlrd.open_workbook(file)</span><br><span class="line">    table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取得每一项的结果</span></span><br><span class="line">    answer1 = table.cell_value(rowx=<span class="number">4</span>, colx=<span class="number">4</span>)</span><br><span class="line">    answer2 = table.cell_value(rowx=<span class="number">10</span>, colx=<span class="number">4</span>)</span><br><span class="line">    temp = <span class="string">f&#x27;<span class="subst">&#123;username&#125;</span>,<span class="subst">&#123;answer1&#125;</span>,<span class="subst">&#123;answer2&#125;</span>&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 合并为一行存储</span></span><br><span class="line">    content.append(temp.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    print(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line">    print(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备写入文件的表头</span></span><br><span class="line">table_header = [<span class="string">&#x27;员工姓名&#x27;</span>, <span class="string">&#x27;第一题&#x27;</span>, <span class="string">&#x27;第二题&#x27;</span>]</span><br><span class="line"></span><br><span class="line">workbook = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">x1sheet = workbook.add_sheet(<span class="string">&quot;统计结果&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入表头</span></span><br><span class="line">row = <span class="number">0</span></span><br><span class="line">col = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> cell_header <span class="keyword">in</span> table_header:</span><br><span class="line">    x1sheet.write(row, col, cell_header)</span><br><span class="line">    col += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向下移动一行</span></span><br><span class="line">row += <span class="number">1</span></span><br><span class="line"><span class="comment"># 取出每一行的内容</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> content:</span><br><span class="line">    col = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 取出每个单元格内容</span></span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> line:</span><br><span class="line">        <span class="comment"># 写入内容</span></span><br><span class="line">        x1sheet.write(row, col, cell)</span><br><span class="line">        <span class="comment"># 向右移动一个单元格</span></span><br><span class="line">        col += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 向下移动一行</span></span><br><span class="line">    row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存最终结果</span></span><br><span class="line">workbook.save(dst_file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Split-py"><a href="#Split-py" class="headerlink" title="Split.py"></a>Split.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path, PurePath</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工资单文件</span></span><br><span class="line">salary_file = <span class="string">&#x27;D:/Python自动化办公/Day01/工资单/工资单.xls&#x27;</span></span><br><span class="line"><span class="comment"># 拆分文件保存路径</span></span><br><span class="line">dst_path = <span class="string">&#x27;D:/Python自动化办公/Day01/工资单&#x27;</span></span><br><span class="line"></span><br><span class="line">data = xlrd.open_workbook(salary_file)</span><br><span class="line">table = data.sheets()[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 取得表头</span></span><br><span class="line">salary_header = table.row_values(rowx=<span class="number">0</span>, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义写入文件的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span>(<span class="params">filename, cnt</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">    filename : 写入的文件名</span></span><br><span class="line"><span class="string">    cnt      : 写入的内容</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    workbook = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    xlsheet = workbook.add_sheet(<span class="string">&quot;本月工资&quot;</span>)</span><br><span class="line"></span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> cnt:</span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> cell <span class="keyword">in</span> line:</span><br><span class="line">            xlsheet.write(row, col, cell)</span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    workbook.save(PurePath(salary_file).with_name(filename).with_suffix(<span class="string">&#x27;.xls&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取得员工数量</span></span><br><span class="line">employee_number = table.nrows</span><br><span class="line"><span class="comment"># 取得每一行,并用第二个单元格作为新的文件名</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,employee_number):</span><br><span class="line">    content = table.row_values(rowx=line, start_colx=<span class="number">0</span>, end_colx=<span class="literal">None</span>)</span><br><span class="line">    <span class="comment"># 将表头和员工数量重新组成一个新的文件 </span></span><br><span class="line">    new_content = []</span><br><span class="line">    <span class="comment"># 增加表头到要写入的内容中</span></span><br><span class="line">    new_content.append(salary_header)</span><br><span class="line">    <span class="comment"># 增加员工工资到要写入的内容中</span></span><br><span class="line">    new_content.append(content)</span><br><span class="line">    <span class="comment"># 调用自定义函数write_to_file()写入新的文件</span></span><br><span class="line">    write_to_file(filename = content[<span class="number">1</span>], cnt = new_content)</span><br></pre></td></tr></table></figure>


<h2 id="Python与Excel交互模块学习"><a href="#Python与Excel交互模块学习" class="headerlink" title="Python与Excel交互模块学习"></a>Python与Excel交互模块学习</h2>]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Python自动化办公-长图拼接</title>
    <url>/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/</url>
    <content><![CDATA[<h1 id="Python自动化办公–长图拼接"><a href="#Python自动化办公–长图拼接" class="headerlink" title="Python自动化办公–长图拼接"></a>Python自动化办公–长图拼接</h1><h2 id="Python调用外部程序的原理"><a href="#Python调用外部程序的原理" class="headerlink" title="Python调用外部程序的原理"></a>Python调用外部程序的原理</h2><blockquote>
<p>导入函数库[对应的Python外部功能已经开发为库]</p>
</blockquote>
<p>例如：Python语言默认是不支持Excel的。那么通过导入函数库xlrd，Python就可以获得对Excel的操作能力。</p>
<blockquote>
<p>需要操作Python语言之外的功能，但这个功能没有人将它开发成函数库， 那如果我们想要使用这些功能，使用的途径就是调用外部命令了，而调用外部命令就需要 Python内部函数库的subprocess模块来实现。</p>
</blockquote>
<ul>
<li><p>实现机制</p>
<p>它的run()函数的参数可以指定一个可以运行的程序的路径，而 Python会根据这个路径来运行可执行文件，然后再根据运行结果，以及Python的逻辑判断去进行后续的自动化处理工作。</p>
</li>
<li><p>举例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> run,Popen,PIPE</span><br><span class="line"></span><br><span class="line">cmd = [<span class="string">&quot;dir&quot;</span>]</span><br><span class="line">returncode = run(cmd)</span><br><span class="line"><span class="comment"># returncode是dir命令的退出状态码，通常来说, 一个为 0 的退出码表示进程运行正常</span></span><br><span class="line">print(returncode)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Popen(cmd,shell=<span class="literal">True</span>,stdout=PIPE,stderr=PIPE,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fs:</span><br><span class="line">    fs.wait(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    files = fs.communicate()[<span class="number">0</span>]</span><br><span class="line">print(files)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这段代码中最核心的函数是run()函数和Popen类。subprocess模块就是通过这两个函数实现 的外部程序调用。</p>
</li>
</ul>
<img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image01.png" class>

<p>和import方式导入函数库的区别是，这种形式可以让你直接使用模块中的类和方法。 如果你使用 “import subprocess”方式导入subprocess库的话，在调用run()函数的时候， 就需要用 “库.函数”的形式在Python中使用库当中的函数，即“subprocess.run()”。在你 多次调用run()函数时，代码会较长，那么使用“from import”方式导入，就可以在当前代 码文件中直接使用run()函数，为代码的阅读带来更好的体验。</p>
 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image02.png" class>

 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image03.png" class>

<p>以上就是用subprocess库实现Python调用可执行程序的方法。Python之所以被我们称作最佳的“<strong>胶水语言</strong>”，就是因为它能轻易“粘合”可执行程序。利用Python灵活的逻辑判 断、循环语法可以实现程序的批量执行和流程管理。</p>
<h2 id="长图拼接"><a href="#长图拼接" class="headerlink" title="长图拼接"></a>长图拼接</h2><p>拼接图片的功能Python本身是不具备的，因此就需要引入外部命令来实现图片拼接功能。</p>
<p>以MacOS平台图像处理软件ImageMagick，它能对图片进行编辑、合并、切割、旋转等90多种操作， ImageMagick软件实现图片拼接的命令格式是这样的：</p>
 <img data-src="/2022/02/01/Python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC-%E9%95%BF%E5%9B%BE%E6%8B%BC%E6%8E%A5/image04.png" class>

<p>在这段命令格式中，composite命令的参数包含了多个图片文件，每个图片需要对照着文件 将图片的路径和文件名写在参数中。如果手工输入图片名称，不仅效率低，而且容易遗漏。 另外，如果需要大量重复使用composite，还需要精细调整合并结果，给composite程序增加很多参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = Path(jpg_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加图片命令</span></span><br><span class="line">cmd = [<span class="string">&quot;composite&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#增加参数</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> p.iterdir() <span class="keyword">if</span> PurePath.match(<span class="string">&#x27;*.jpg&#x27;</span>):</span><br><span class="line">    cmd.append(x)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 增加结果</span></span><br><span class="line">cmd.append(result_path)</span><br><span class="line"></span><br><span class="line">run(cmd)</span><br></pre></td></tr></table></figure>


<h2 id="视频的拆分与合并"><a href="#视频的拆分与合并" class="headerlink" title="视频的拆分与合并"></a>视频的拆分与合并</h2><p>如何使用 subprocess库调用可执行程序，来进行视频的拆分与合并。</p>
<p><strong>视频拆分的原理</strong></p>
<p>你在电脑本地经常见到的视频格式是MP4，但如果要把视频放在互联网上，为了减少首次播放的加载时间，你就必须把一个MP4切分成多个文件，而且切分之后还需要把格式转换为.TS 格式的视频文件。 </p>
<p>为什么不直接使用MP4格式，而是要把MP4格式改成.TS格式呢？这是因为.TS格式可以保证 多个文件之间的视频无缝播放，而且还会保证视频不会在播放下一个文件的时候，出现破音 或画面中断等影响用户体验的情况。 </p>
<p>当我们将一个视频切分成多个文件的时候，就要考虑文件的播放顺序问题了。为了记录顺序，我们需要在切分之后引入一个索引文件，这个索引文件不用手动编写，我们直接使 <strong>FFmpeg命令</strong>就行了，它可以实现视频格式的转换、合并和拆分。FFmpeg命令会在切分之 后，自动产生一个以.M3U8结尾的索引文件。 </p>
<p>我来解释一下这个索引文件。M3U8文件是指UDF-8编码格式下的M3U视频索引，播放器通 过这个索引文件就可以找到视频下所有的分段，并依次播放视频。</p>
<p>所以，想要使用Python进行视频拆分，我们首先需要FFmpeg命令， 然后通过Python设置FFmpeg的参数，最后再指定MP4文件和.TS文件的路径，这样就能实现拆分视频的功能了。</p>
<p>首先需要下载ffmpeg命令，用于把MP4切分成多段TS文件。</p>
<p>为了实现MP4文件格式的分割，需要使用ffmpeg非常多的参数。不过使用Python进行调用 的好处，就是你不用记住复杂的参数。我们把输入文件路径、切分大小、输出的M3U8和TS 文件指定为四个变量，这样只修改这四个变量，就可以实现拆分功能了。</p>
<blockquote>
<p>相比直接使用FFmpeg，subprocess调用FFmpeg的优势就在于两点，一是不用 记住复杂参数，二是对批量转换视频非常有利</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> run</span><br><span class="line"><span class="comment"># 拆分文件的路径</span></span><br><span class="line">input_video = <span class="string">&quot;/Users/edz/Desktop/05/xxx.mp4&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 10秒分为一个文件</span></span><br><span class="line">segment_time = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># m3u8文件保存位置</span></span><br><span class="line"><span class="comment"># m3u8_list = &quot;/Users/edz/Desktop/05/xxx.m3u8&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ts文件保存位置</span></span><br><span class="line">output_video = <span class="string">&quot;/Users/edz/Desktop/05/video-%04d.ts&quot;</span></span><br><span class="line"></span><br><span class="line">cmd1 = [<span class="string">&quot;ffmpeg&quot;</span>, <span class="string">&quot;-i&quot;</span>, input_video, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;segment&quot;</span>, <span class="string">&quot;-segment_time&quot;</span>, <span class="built_in">str</span>(segment_time), <span class="string">&quot;-segment_format&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mpegts&quot;</span>, <span class="string">&quot;-segment_list&quot;</span>, m3u8_list, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;copy&quot;</span>, <span class="string">&quot;-bsf:v&quot;</span>, <span class="string">&quot;h264_mp4toannexb&quot;</span>, <span class="string">&quot;-map&quot;</span>, <span class="string">&quot;0&quot;</span>, output_video]</span><br><span class="line"></span><br><span class="line">run(cmd1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并</span></span><br><span class="line"><span class="comment"># ffmpeg -allowed_extensions ALL -protocol_whitelist &quot;file,http,crypto,tcp,https&quot; -i index.m3u8 -c copy out.mp4</span></span><br></pre></td></tr></table></figure>




























]]></content>
      <categories>
        <category>Python开发</category>
      </categories>
      <tags>
        <tag>Python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy1</title>
    <url>/2022/02/21/Scrapy1/</url>
    <content><![CDATA[<h1 id="Scrapy爬虫Section1"><a href="#Scrapy爬虫Section1" class="headerlink" title="Scrapy爬虫Section1"></a>Scrapy爬虫Section1</h1><h2 id="认识Scrapy爬虫"><a href="#认识Scrapy爬虫" class="headerlink" title="认识Scrapy爬虫"></a>认识Scrapy爬虫</h2> <img data-src="/2022/02/21/Scrapy1/image17.png" class>

<p>网络爬虫是指在互联网上自动爬取网站内容信息的程序，也被称作网络蜘蛛或网络机器人。大型的爬虫程序被广泛应用于搜索引擎、数据挖掘等领域，个人用户或企业也可以利用爬虫收集对自身有价值的数据。</p>
<blockquote>
<p>网络爬虫的基本执行流程</p>
</blockquote>
 <img data-src="/2022/02/21/Scrapy1/image01.png" class>

<ul>
<li><p>下载页面</p>
<p>一个网页的内容本质上就是一个HTML文本，爬取一个网页内容之前，首先要根据网页的URL下载网页。</p>
</li>
<li><p>提取页面数据</p>
<p>当一个网页（HTML）下载完成后，对页面中的内容进行分析，并提取出我们感兴趣的数据，提取到的数据可以以多种形式保存起来，比如将数据以某种格式（CSV、JSON）写入文件中，或存储到数据库（MySQL、MongoDB）中。</p>
</li>
<li><p>提取页面链接</p>
<p> 通常，我们想要获取的数据并不只在一个页面中，而是分布在多个页面中，这些页面彼此联系，一个页面中可能包含一个或多个到其他页面的链接，<strong>提取完当前页面中的数据</strong>后，还要**<em>把页面中的某些链接也提取出来**</em>，然后对链接页面进行爬取（循环1-3步骤）。</p>
</li>
</ul>
<p>使用Python可以从头开始写一个爬虫程序，为了避免因制造轮子 而消耗大量时间，在实际应用中我们可以选择使用一些优秀的爬虫框 架，使用框架可以降低开发成本，提高程序质量。所以就有了**<em>Scrapy**</em>的出现。</p>
<h3 id="Scrapy的安装"><a href="#Scrapy的安装" class="headerlink" title="Scrapy的安装"></a>Scrapy的安装</h3><blockquote>
<p>pip install scrapy </p>
</blockquote>
<p>出现图示则代表安装成功。</p>
 <img data-src="/2022/02/21/Scrapy1/image02.png" class>

<h3 id="编写Spider（Scrapy-爬虫程序中最核心的组件）"><a href="#编写Spider（Scrapy-爬虫程序中最核心的组件）" class="headerlink" title="编写Spider（Scrapy 爬虫程序中最核心的组件）"></a>编写Spider（Scrapy 爬虫程序中最核心的组件）</h3><h4 id="Scrapy框架结构及工作原理"><a href="#Scrapy框架结构及工作原理" class="headerlink" title="Scrapy框架结构及工作原理"></a>Scrapy框架结构及工作原理</h4> <img data-src="/2022/02/21/Scrapy1/image03.png" class>

<blockquote>
<p>对**<em>各个组件**</em>的介绍如下图所示</p>
</blockquote>
 <img data-src="/2022/02/21/Scrapy1/image04.png" class>

<blockquote>
<p>对框架中的**<em>数据流**</em>介绍如图所示</p>
</blockquote>
  <img data-src="/2022/02/21/Scrapy1/image05.png" class>

<p>Request和Response是HTTP协议中的术语，即HTTP请求和 HTTP响应，Scrapy框架中定义了相应的Request和Response类，这里的Item代表Spider从页面中爬取的一项数据。</p>
<blockquote>
<p>数据在框架中的流动过程</p>
</blockquote>
<ul>
<li><p>当SPIDER要爬取某URL地址的页面时，需使用该URL构造一个Request对象，提交给ENGINE。</p>
</li>
<li><p>Request对象随后进入SCHEDULER按某种算法进行排队，之后的某个时刻SCHEDULER将其出队，送往DOWNLOADER。</p>
</li>
<li><p>DOWNLOADER根据Request对象中的URL地址发送一次HTTP请求 到网站服务器，之后用服务器返回的HTTP响应构造出一个Response对象，其中包含页面的HTML文本。</p>
</li>
<li><p>Response对象最终会被递送给SPIDER的页面解析函数（构造Request对象时指定）进行处理，页面解析函数从页面中提取数据，封装成Item后提交给ENGINE，Item之后被送往ITEM </p>
<p>PIPELINES进行处理，最终可能由EXPORTER以某种数据格式写入文件（csv，json）；另一方面，页面解析函数还从页面中提取链接（URL），构造出新的 Request对象提交给ENGINE。</p>
</li>
</ul>
<h4 id="Request对象"><a href="#Request对象" class="headerlink" title="Request对象"></a>Request对象</h4><p>Request对象用来描述一个HTTP请求，下面是其构造器方法的参数列表：</p>
<blockquote>
<p>Request(url[, callback, method=’GET’, headers, body, cookies, meta, encoding=’utf-8’, priority=0, dont_filter=False,errback,flags])</p>
</blockquote>
<p><strong><em>Request参数介绍：</em></strong></p>
<ul>
<li><p>url（必选）</p>
<p>请求页面的url地址，bytes或str类型。</p>
</li>
<li><p>callback</p>
<p>页面解析函数， Callable类型，Request对象请求的页面下载完成后，由该参数指定的页面解析函数被调用。如果未传递该参数，默认**<em>调用Spider的parse**</em>方法。</p>
</li>
<li><p>method </p>
<p>HTTP请求的方法，默认为’GET。</p>
 <img data-src="/2022/02/21/Scrapy1/image06.png" class>

<img data-src="/2022/02/21/Scrapy1/image14.png" class>

</li>
</ul>
<p>虽然参数很多，但除了url参数外，其他都带有默认值。在构造Request对象时，通常我们只需传递一个url参数或再加一个callback参数，其他使用默认值即可。</p>
<blockquote>
<p>&gt;&gt;&gt; request = scrapy.Request(‘<a href="http://books.toscrape.com/&#39;">http://books.toscrape.com/&#39;</a>) </p>
</blockquote>
<h4 id="Response对象"><a href="#Response对象" class="headerlink" title="Response对象"></a>Response对象</h4><p>Response对象用来描述一个HTTP响应，Response只是一个基类，根据响应内容的不同有如下子类：</p>
<ul>
<li>TextResponse</li>
<li>HtmlResponse</li>
<li>XmlResponse</li>
</ul>
<p>当一个页面下载完成时，下载器依据HTTP响应头部中的 Content-Type信息创建某个Response的子类对象。我们通常爬取的网页，其内容是HTML文本，创建的便是HtmlResponse对象，其 中**<em>HtmlResponse和XmlResponse是TextResponse的子类**</em>。实际上，这3个子类只有细微的差别</p>
<p>​        </p>
<p><strong><em>HtmlResponse对象的属性与方法</em></strong></p>
 <img data-src="/2022/02/21/Scrapy1/image07.png" class>

 <img data-src="/2022/02/21/Scrapy1/image08.png" class>

 <img data-src="/2022/02/21/Scrapy1/image15.png" class>

 <img data-src="/2022/02/21/Scrapy1/image09.png" class>



<h3 id="Spider开发流程"><a href="#Spider开发流程" class="headerlink" title="Spider开发流程"></a>Spider开发流程</h3><p>爬虫开发的逻辑：</p>
 <img data-src="/2022/02/21/Scrapy1/image10.png" class>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> ..items <span class="keyword">import</span> BookItem</span><br><span class="line"><span class="keyword">from</span> scrapy.linkextractors <span class="keyword">import</span> LinkExtractor</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksSpider</span>(<span class="params">scrapy.Spider</span>):</span></span><br><span class="line">    <span class="comment"># 爬虫名，每一个爬虫的唯一标识</span></span><br><span class="line">    name = <span class="string">&#x27;books&#x27;</span></span><br><span class="line">    <span class="comment"># 第 1 章 1.3.4 实现 Spider</span></span><br><span class="line">    <span class="comment"># 定义爬虫爬取的起始点，起始点可以是多个，这里只有一个。</span></span><br><span class="line">    <span class="comment">#start_urls = [&#x27;http://books.toscrape.com/&#x27;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第 2 章 2.3.3 设定起始爬取点</span></span><br><span class="line">    <span class="comment"># 实现 start_resquests 方法代替start_urls类属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(<span class="string">&#x27;http://books.toscrape.com/&#x27;</span>,</span><br><span class="line">                             callback=self.parse,</span><br><span class="line">                             headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozill/5.0&#x27;</span>&#125;,</span><br><span class="line">                             dont_filter=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">        <span class="comment"># 提取数据</span></span><br><span class="line">        <span class="comment"># 重写</span></span><br><span class="line">        <span class="keyword">for</span> sel <span class="keyword">in</span> response.css(<span class="string">&#x27;article.product_pod&#x27;</span>):</span><br><span class="line">            book = BookItem() <span class="comment"># from ..items import BookItem 类</span></span><br><span class="line">            book[<span class="string">&#x27;name&#x27;</span>] = sel.xpath(<span class="string">&#x27;./h3/a/@title&#x27;</span>).extract_first()</span><br><span class="line">            book[<span class="string">&#x27;price&#x27;</span>] = sel.css(<span class="string">&#x27;p.price_color::text&#x27;</span>).extract_first()</span><br><span class="line">            <span class="keyword">yield</span> book</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第 1 章 1.3.4 实现 Spider</span></span><br><span class="line">        <span class="comment"># 以下代码值直接保存，没有通过 Item 封装数据</span></span><br><span class="line">        <span class="comment"># for book in response.css(&#x27;article.product_pod&#x27;):</span></span><br><span class="line">            <span class="comment"># name = book.xpath(&#x27;./h3/a/@title&#x27;).extract_first()</span></span><br><span class="line">            <span class="comment"># price = book.css(&#x27;p.price_color::text&#x27;).extract_first()</span></span><br><span class="line">            <span class="comment"># yield &#123;</span></span><br><span class="line">            <span class="comment">#     &#x27;name&#x27;: name,</span></span><br><span class="line">            <span class="comment">#     &#x27;price&#x27;: price</span></span><br><span class="line">            <span class="comment"># &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第 1 章 1.3.4 实现 Spider</span></span><br><span class="line">        <span class="comment"># 直接用 Selector 提取下一页链接 （没有用 LinkExtractor 提取链接）</span></span><br><span class="line">        <span class="comment"># 下一页链接在 ul.pager &gt; li.next &gt; a 里</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        &lt;ul class=&quot;pager&quot;&gt;          </span></span><br><span class="line"><span class="string">            &lt;li class=&quot;current&quot;&gt; Page 1 of 50 &lt;/li&gt;           </span></span><br><span class="line"><span class="string">            &lt;li class=&quot;next&quot;&gt;&lt;a href=&quot;catalogue/page-2.html&quot;&gt;next&lt;/a&gt;&lt;/li&gt;            </span></span><br><span class="line"><span class="string">        &lt;/ul&gt;</span></span><br><span class="line"><span class="string">        #default &gt; div &gt; div &gt; div &gt; div &gt; section &gt; div:nth-child(2) &gt; div &gt; ul.pager &gt; li.next &gt; a</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># next_url = response.css(&#x27;ul.pager li.next a::attr(href)&#x27;).extract_first()</span></span><br><span class="line">        <span class="comment"># if next_url:</span></span><br><span class="line">        <span class="comment">#     next_url = response.urljoin(next_url)</span></span><br><span class="line">        <span class="comment">#     yield scrapy.Request(next_url, callback=self.parse)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 第6章 使用 LinkExtractor 提取链接</span></span><br><span class="line">        <span class="comment"># 提取下一页链接重写（用 LinkExtractor提取）</span></span><br><span class="line">        <span class="comment"># 说明 from scrapy.linkextractors import LinkExtractor</span></span><br><span class="line">        le = LinkExtractor(restrict_css=<span class="string">&#x27;ul.pager li.next&#x27;</span>)</span><br><span class="line">        links = le.extract_links(response)</span><br><span class="line">        <span class="comment"># print(type(links),links)</span></span><br><span class="line">        <span class="keyword">if</span> links:</span><br><span class="line">            <span class="comment"># 用links[0]获取的Link对象属性是绝对链接地址，无需要用response.urljoin拼接</span></span><br><span class="line">            next_url = links[<span class="number">0</span>].url</span><br><span class="line">            <span class="keyword">yield</span> scrapy.Request(next_url, callback=self.parse)</span><br></pre></td></tr></table></figure>
  <img data-src="/2022/02/21/Scrapy1/image16.png" class>



<h4 id="继承scrapy-Spider"><a href="#继承scrapy-Spider" class="headerlink" title="继承scrapy.Spider"></a>继承scrapy.Spider</h4><p>Scrapy框架提供了一个Spider基类，我们编写的Spider需要继承它</p>
<blockquote>
<p>import scrapy </p>
<p>class BooksSpider(scrapy.Spider): </p>
</blockquote>
<p>这个Spider基类实现了以下内容： </p>
<ul>
<li>供Scrapy引擎调用的<strong>接口</strong>，例如用来创建Spider实例的类方法from_crawler。 </li>
</ul>
<p>● 供用户使用的<strong>实用工具函数</strong>，例如可以调用log方法将调试信息输出到日志。 </p>
<p>● 供用户访问的<strong>属性</strong>，例如可以通过settings属性访问配置文件中的配置。 </p>
<h4 id="为Spider命名"><a href="#为Spider命名" class="headerlink" title="为Spider命名"></a>为Spider命名</h4><p>在一个Scrapy项目中可以实现多个Spider，每个Spider需要有一个能够区分彼此的唯一标识，Spider的类属性name便是这个唯一标识。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksSpider</span>(<span class="params">scrapy.Spider</span>):</span> </span><br><span class="line">    name = <span class="string">&quot;books&quot;</span> </span><br><span class="line">    	...</span><br></pre></td></tr></table></figure>
<p>执行scrapy crawl命令时就用到了这个标识，告诉Scrapy使用哪个Spider进行爬取。</p>
<h4 id="设定起始爬取点"><a href="#设定起始爬取点" class="headerlink" title="设定起始爬取点"></a>设定起始爬取点</h4><p>Spider必然要从某个或某些页面开始爬取，我们称这些页面为**<em>起始爬取点**</em>，可以通过类属性start_urls来设定起始爬取点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BooksSpider</span>(<span class="params">scrapy.Spider</span>):</span> </span><br><span class="line">    ... </span><br><span class="line">    start_urls = [<span class="string">&#x27;http://books.toscrape.com/&#x27;</span>]</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>start_urls通常被实现成一个列表，其中放入所有起始爬取点的url。</p>
<p>请求页 面下载一定要提交Request对象，这时候，我们仅仅定义了URL列表，Spider基类的start_requests方法帮助我们基于URL构造并提交了Request对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spider</span>(<span class="params">object_ref</span>):</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_requests</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">for</span> url <span class="keyword">in</span> self.start_urls: </span><br><span class="line">            <span class="keyword">yield</span> self.make_requests_from_url(url)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_requests_from_url</span>(<span class="params">self, url</span>):</span> </span><br><span class="line">        <span class="keyword">return</span> Request(url, dont_filter=<span class="literal">True</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span> </span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError ..</span><br></pre></td></tr></table></figure>
 <img data-src="/2022/02/21/Scrapy1/image11.png" class>

<p>由于起始爬取点的下载请求是由引擎调用Spider对象的 start_requests方法产生的，因此我们也可以在BooksSpider中实现start_requests方法（**<em>覆盖基类Spider的start_requests方法**</em>），直接构造并提交起始爬取点的Request对象。在某些场景下使用这种方式更加灵活，例如有时想为Request添加特定的HTTP请求头部,或想为Request指定特定的页面解析函数</p>
 <img data-src="/2022/02/21/Scrapy1/image12.png" class>





<h4 id="实现页面解析函数"><a href="#实现页面解析函数" class="headerlink" title="实现页面解析函数"></a>实现页面解析函数</h4><p>页面解析函数也就是构造Request对象时**<em>通过callback参数指定**</em> 的回调函数（或默认的parse方法）。页面解析函数是实现Spider中最核心的部分，它需要完成以下两项工作：</p>
 <img data-src="/2022/02/21/Scrapy1/image13.png" class>

<p>一个页面中可能包含多项数据以及多个链接，因此页面解析函数被要求返回一个可迭代对象（通常被实现成一个生成器函数），每次迭代返回一项数据（Item或字典）或一个Request对象。</p>
]]></content>
      <categories>
        <category>Scrapy爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Section1</title>
    <url>/2022/02/21/Section1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>中断</title>
    <url>/2021/02/03/%E4%B8%AD%E6%96%AD/</url>
    <content><![CDATA[<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断使得硬件得以发出通知给处理器，是一种变内核主动为硬件主动的方式。中断本质上是一种特殊的电信号。硬件在生成中断的时候并不需要考虑与处理器的时钟同步，即中断可以随时产生，<strong>内核随时可能因为新到来的中断而被打断</strong>。</p>
<img data-src="/2021/02/03/%E4%B8%AD%E6%96%AD/%E4%B8%AD%E6%96%AD1.png" class>

<p>不同的设备对应的中断不同，而每个中断都通过唯一的数字标识，这样，操作系统才能给不同的中断提供对应的中断处理程序。硬件发出中断，就是在提醒内核，有新的请求需要读取并处理。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>异常与中断不同之处就是在于异常在产生时必须要考虑处理器与时钟同步，所以其经常被称为同步中。</p>
<p>异常的产生原因：</p>
<blockquote>
<p>1.处理器由于执行到编程失误而导致的错误指令（如被0除）</p>
</blockquote>
<blockquote>
<p>2.执行期间出现特殊情况，例如缺页</p>
</blockquote>
<blockquote>
<p>3.系统调用陷入内核—–引起了系统调用处理程序异常</p>
</blockquote>
<p>以上，产生异常，都需要内核处理。</p>
<h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>内核通过执行中断处理程序(interrupt handler)来对某一特定的中断进行响应，产生中断的每一个设备都有一个相应的中断处理程序。一个设备的中断处理程序是其设备驱动程序的一部分—–设备驱动程序是<strong>用于对设备进行管理的内核代码</strong>。</p>
<p>中断处理程序被内核调用，运行于中断上下文，该上下文的执行代码不可阻塞。</p>
<h3 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h3><p>将中断处理分为两个部分。</p>
<blockquote>
<p>中断处理程序是上半部分（top half），接收到一个中断会被立即执行，只做有严格时限的工作。</p>
</blockquote>
<blockquote>
<p>能够被允许稍后完成的工作会被推迟到下半部去执行。即处理和操作中断的非即时完成请求会在随后的下半部中执行。</p>
</blockquote>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h3><p>当执行一个中断处理程序时，内核处于中断上下文中(interrupt context)。</p>
<p>注意：</p>
<ul>
<li>中断上下文没有后备进程，所以其不可以睡眠。如果一个函数要进行睡眠，就不能出现在中断处理程序中。</li>
<li>中断处理程序实际上打断了其他的代码，这种异步执行的特性，要求所有的中断处理程序必须尽可能的快速、简单。尽量将工作从中断处理程序中分离出来，放在中断下半部执行。</li>
<li>中断处理程序栈是一个配置选项。在内核早期版本中，中断处理程序是共享别人的堆栈，获取空间时非常节约。后期，中断处理程序有了自己的栈（中断栈），但无论无何，在内核中还是要尽可能的节省空间的使用，因为内核栈本身就是有限的。</li>
<li><strong>进程上下文是可以睡眠的</strong></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>大多数现代硬件都通过中断来与操作系统进行通信。对给定的硬件进行管理的驱动程序注册中断处理程序，是为了响应并处理来自相关硬件的中断。中断过程所作的工作包括应答并重新设置硬件，从设备拷贝数据到内存以及反之，处理硬件请求，并发送新的硬件请求。</p>
<p>内核提供的接口包括注册和注销中断处理程序、禁止中断、屏蔽中断线以及检查中断系统的状态。</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统种类</title>
    <url>/2022/02/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%A7%8D%E7%B1%BB/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>创建高性能索引</title>
    <url>/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h1><p>索引（在MySQL中也叫做“键（key）是**<em>存储引擎用于快速找到记录**</em>的一种数据结构。 这是索引的基本功能。在MySQL中，存储引擎用书本目录类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行</p>
<p>索引可以包含一个或多个列的值。如果索引包含多个列，那么**<em>列的顺序**</em>也十分重要，因为MySQL只能高效地使用索引的<u><strong>最左前缀列</strong></u>。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的，</p>
<p><img data-src="/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220222091253478.png" alt="image-20220222091253478"></p>
<h2 id="索引的类型"><a href="#索引的类型" class="headerlink" title="索引的类型"></a>索引的类型</h2><p>索引有很多种类型，可以为不同的场景提供更好的性能。在MySQL中，索引是在**<em>存储引擎层**</em>而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<p>MySQL支持的索引类型，以及它们的优点和缺点如下：</p>
<h3 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B-Tree索引"></a>B-Tree索引</h3><p>当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引，它使用 B-Tree数据结构来存储数据，大多数MySQL引擎都支持这种索引。</p>
<blockquote>
<p>实际上很多存储引擎使用的是**<em>B+Tree**</em>,即每一个叶子节点都包含指向下一个叶子节点的指针，从 而方便叶子节点的范围遍历。</p>
</blockquote>
<p>存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MylSAM 使用前缀压缩技术使得索引更小，但InnoDB则按照原数据格式进行存储。再如 MylSAM索引通过数据的物理位置引用被索引的行，而InnoDB则根据主键引用被索引的行。</p>
<p><img data-src="/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220222092648551.png" alt="image-20220222092648551"></p>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层査找。通过比较节点页的值和要査找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值 的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页（不同引擎的“指针”类型不同）    </p>
<blockquote>
<p>B-Tree对索引列是顺序组织存储的，所以很适合査找范围数据。索引对多个值进行排序的依据是CREATE TABLE语句中定义索引时列的顺序。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">	last_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    first_name <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    dob 	  <span class="type">date</span>         <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    gender    enum(<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;f&#x27;</span>) <span class="keyword">not</span> <span class="keyword">null</span>.</span><br><span class="line">    key(last_name,first_name,dob)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure>
<p><strong><em>B-Tree索引对以下类型的查询有效：</em></strong><br><img data-src="/2022/02/20/%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220222093555561.png" alt="image-20220222093555561"></p>
]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库索引</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网刷题-操作系统2</title>
    <url>/2022/02/18/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F2/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>系统调用是内核与用户进程进行交互的一组接口，这些接口让应用程序受限制的访问硬件设备，提供了创建新进程并与已有进程进行交互通信的机制，也提供了申请操作系统其他资源的能力。</p>
<p>系统调用在Linux系统中的地位如下图所示：</p>
<img data-src="/2021/02/01/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/OIP1.jpg" class>

<h3 id="2-与内核通信"><a href="#2-与内核通信" class="headerlink" title="2.与内核通信"></a>2.与内核通信</h3><p>系统调用在用户空间进程和硬件设备之间添加了一个中间层。这样的中间层有如下作用：</p>
<blockquote>
<p>1.为用户空间提供了一种硬件的抽象接口。</p>
</blockquote>
<blockquote>
<p>2.系统调用确保了系统的稳定与安全。内核可以作为硬件设备与用户空间之间的中间人，基于权限、用户类型和一些其他的规则对需要进行的访问做出裁决。</p>
</blockquote>
<blockquote>
<p>3.避免用户空间的应用程序对硬件资源随意访问而内核一无所知，这样既无法实现多任务和虚拟内存，也不能确保良好的稳定性和安全性。</p>
</blockquote>
<p><strong>Linux中：系统调用是用户空间访问内核的唯一手段—-除了异常和陷入外，它们是内核唯一的合法入口</strong></p>
<h3 id="3-API、POSIX、C库"><a href="#3-API、POSIX、C库" class="headerlink" title="3.API、POSIX、C库"></a>3.API、POSIX、C库</h3><p>应用程序通过在用户空间实现的应用编程接口（API）而不是直接通过系统调用。</p>
<blockquote>
<p>1.API实际上并不需要与内核提供的系统调用一一对应，程序员只跟API打交道。</p>
<p>2.内核只跟系统调用打交道，库函数以及应用程序如何使用系统调用不是内核所关心的。</p>
<p>3.API可以实现成一个系统调用，也可以实现多个系统调用，甚至也可以不实现系统调用。</p>
</blockquote>
<p>在UNIX中，最流行的应用编程接口是基于POSIX标准的。</p>
<p>Linux系统调用作为C库的一部分提供。C库实现了Unix系统的主要API，包括标准C库函数和系统调用接口，此外，C库提供了POSIX的绝大部分API。</p>
<h3 id="4-系统调用-syscall"><a href="#4-系统调用-syscall" class="headerlink" title="4.系统调用(syscall)"></a>4.系统调用(syscall)</h3><p><strong>通过在C库中定义的函数调用来执行</strong></p>
<p>系统调用在出现错误的时候C库会将错误码写入errno全局变量。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。</p>
<p>为了保证32为操作系统和64位操作系统的兼容，系统调用在用户空间和内核空间有着不同的返回值类型。用户空间为int，内核空间为long。系统调用在内核中前面会加上sys_。例如：返回当前进程PID的系统调用get_pid（）在内核中被定义为sys_getpid()。</p>
<h4 id="4-1系统调用号"><a href="#4-1系统调用号" class="headerlink" title="4.1系统调用号"></a>4.1系统调用号</h4><p>在Linux中，每个系统调用都会被赋予一个系统调用号（独一无二的）。进程在执行系统调用时，不需要提及系统调用的名称，只需要使用系统调用号即可。</p>
<p><strong>系统调用号相当重要，一旦分配好就不能再更改，因为会导致之前编译好的应用程序崩溃。</strong>即使这个系统调用被删除，它所占用的系统调用号也不允许被回收利用。</p>
<p>内核记录了系统调用表中的所有已经注册过的系统调用的列表，存储在sys_call_table中，这个表为每一个有效的</p>
<p>系统调用指定了唯一的系统调用号。</p>
<h4 id="4-2系统调用的性能"><a href="#4-2系统调用的性能" class="headerlink" title="4.2系统调用的性能"></a>4.2系统调用的性能</h4><p>Linux系统调用比其他许多的操作系统执行要快。原因如下：</p>
<blockquote>
<p>1.Linux很短的上下文切换时间，进出内核都被优化的极为高效。</p>
<p>2.系统调用处理程序和每个系统调用本身非常简洁。</p>
</blockquote>
<h3 id="5-系统调用处理程序"><a href="#5-系统调用处理程序" class="headerlink" title="5.系统调用处理程序"></a>5.系统调用处理程序</h3><p>应用程序通过<strong>软中断</strong>的方式来告诉内核自己期望执行一个系统调用，希望系统当前可以从用户态切换到内核态，这样内核就可以代表应用程序在内核空间中执行系统调用。</p>
<p><strong>软中断</strong>：通过引起一个异常来促使系统切换到内核态前去执行异常处理程序。此时的异常处理程序其实就是<strong>系统调用处理程序</strong>。</p>
<p>在X86系统中预定义的软中断是中断号128，通过int $0x80来触发中断。这条指令会触发一个异常导致系统切换到内核态并执行128号异常处理程序（系统调用处理程序）。</p>
<h4 id="5-1指定恰当的系统调用"><a href="#5-1指定恰当的系统调用" class="headerlink" title="5.1指定恰当的系统调用"></a>5.1指定恰当的系统调用</h4><p>在陷入内核空间时，要将系统调用号传给内核空间。X86系统，系统调用号是通过eax寄存器传递给内核的。system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。大于或者等于NR_syscalls，函数就返回-ENOSYS,否则，执行相应的系统调用。</p>
<p>系统调用表中的表项是以64位类型存放的，所以内核需要将给定的系统调用号乘4，然后用所得结果在表中查询位置。</p>
<h4 id="5-2参数传递"><a href="#5-2参数传递" class="headerlink" title="5.2参数传递"></a>5.2参数传递</h4><p>部分系统调用除了系统调用号之外，还需要传入一些外部参数，在发生陷入的时候，一并传给内核，同样是放在寄存器中。<strong>给用户空间的返回值同样是通过寄存器来传递的</strong></p>
<h3 id="6-系统调用的实现"><a href="#6-系统调用的实现" class="headerlink" title="6.系统调用的实现"></a>6.系统调用的实现</h3><h4 id="6-1实现系统调用"><a href="#6-1实现系统调用" class="headerlink" title="6.1实现系统调用"></a>6.1实现系统调用</h4><p>要求：</p>
<ul>
<li>Linux中不提倡采用多用途的系统调用（一个系统调用通过传递不同的参数值来完成选择的工作）</li>
<li>系统调用的接口应该力求简洁，参数尽量少。提供标志参数以确保向前兼容。</li>
<li>系统调用的设计越通用越好。</li>
</ul>
<h4 id="6-2参数验证"><a href="#6-2参数验证" class="headerlink" title="6.2参数验证"></a>6.2参数验证</h4><p>系统调用必须检查参数是否合法有效。系统调用在内核空间中执行，任由用户将不合法的输入传递给内核，系统大的安全和稳定性将面临考验。进程不能让内核访问那些他没有权限访问的数据。</p>
<ul>
<li>与文件IO有关的系统调用需要检查文件描述符是否有效，与进程有关的函数必须检查提供的PID是否有效。</li>
<li>检查用户提供的指针是否有效<ul>
<li>指针指向的内存区域只能属于用户空间，进程不能告诉内核去读内核空间中的数据。</li>
<li>指针指向的内存区域在自己的进程中，不能让内核去读其他进程中的数据。</li>
<li>进程不能越过内存访问限制（可读、可写、可执行）</li>
</ul>
</li>
<li>检查是否有合法权限</li>
</ul>
<p>内核提供了两个方法来完成必须的检查和内核空间与用户空间之间的数据来回拷贝</p>
<ul>
<li>写入：copy_to_user()</li>
<li>读取：copy_from_user()</li>
</ul>
<p>这两个方法可能会引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，进程会休眠，直到缺页处理程序将该页从硬盘从新换回物理内存。</p>
<h3 id="7-系统调用上下文"><a href="#7-系统调用上下文" class="headerlink" title="7.系统调用上下文"></a>7.系统调用上下文</h3><p>在进程调用系统调用时，会有进程上下文。既可以被抢占也可以休眠。</p>
<p>可以休眠说明系统调用可以利用内核提供的绝大部分功能。可以被抢占说明该系统调用时可重入的（新的进程同样可以使用相同的系统调用）。</p>
<p>系统调用返回时，控制权仍然在system_call()中，它最终会负责切换到内核工作空间，并让用户进程继续执行下去。</p>
<h4 id="7-1绑定一个系统调用的最后步骤"><a href="#7-1绑定一个系统调用的最后步骤" class="headerlink" title="7.1绑定一个系统调用的最后步骤"></a>7.1绑定一个系统调用的最后步骤</h4><blockquote>
<p>1.在系统调用表中的最后加入一个表项。从0开始算起，系统调用在表中的位置就是他的系统调用号。</p>
</blockquote>
<blockquote>
<p>2.系统调用必须被编译进内核映像（不能被编译成模块）</p>
</blockquote>
<h4 id="7-2从用户空间访问系统调用"><a href="#7-2从用户空间访问系统调用" class="headerlink" title="7.2从用户空间访问系统调用"></a>7.2从用户空间访问系统调用</h4><p>系统调用靠的时C库的支持，用户程序通过包含标准头文件并和C库链接，就可以使用系统调用。</p>
<p><strong>Linux新系统调用增添频率很低，说明Linux系统是一个相对较为稳定并且功能已经较为完善的操作系统</strong></p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>Linux系统内核设计</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络/应用层</title>
    <url>/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>研发网络应用程序的核心是写出能够运行在**<em>不同的端系统**</em>和通过网络彼此通信的程序。</p>
<img data-src="/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220223121648233.png" alt="image-20220223121648233" style="zoom:50%;">

<h2 id="网络应用体系结构（network-application-architecture）"><a href="#网络应用体系结构（network-application-architecture）" class="headerlink" title="网络应用体系结构（network application architecture）"></a>网络应用体系结构（network application architecture）</h2><h3 id="客户端-服务器体系结构（client-server-architecture）"><a href="#客户端-服务器体系结构（client-server-architecture）" class="headerlink" title="客户端-服务器体系结构（client-server architecture）"></a>客户端-服务器体系结构（client-server architecture）</h3><p>特征：</p>
<blockquote>
<p>有一个总是打开的主机成为服务器，服务于来自许多客户端的请求</p>
</blockquote>
<blockquote>
<p>服务器具有固定的、周知的地址，成为IP地址</p>
</blockquote>
<p><img data-src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F1725642%2F202003%2F1725642-20200329223925870-559284185.png&refer=http%3A%2F%2Fimg2020.cnblogs.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1648189567&t=9fa0bc55891c197654d45ebacade79eb" alt="img"></p>
<h3 id="P2P体系结构（P2P-architecture）"><a href="#P2P体系结构（P2P-architecture）" class="headerlink" title="P2P体系结构（P2P architecture）"></a>P2P体系结构（P2P architecture）</h3><p> <img data-src="/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220223143338617.png" alt="image-20220223143338617"></p>
<p><img data-src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/3f/P2P-network.svg/200px-P2P-network.svg.png" alt="img"></p>
<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>多数应用程序是由通信进程对组成，每对中的两个进程五相发送报文。进程向另一个进程发送的报文必须通过下面的网络 。进程通过一个称为**<em>套接字 (socket)**</em>的软件接口向网络发送报文和从网络接收报文 </p>
<img data-src="/2022/02/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82/BLOG\source\_posts\计算机网络-应用层\image01.png" style="zoom:200%;">

<h2 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h2><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>Web 的应用层协议是超文本传输协议 (HyperText Transfer Protocol , HTTP) ，它是 Web</p>
<p>的核心。客户程序和服务器程序运行在不同的端系统中，通过交换HTTP 报文进行会话。 HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p>HTTP 使用 TCP 作为它的支撑运输协议，(而不是在 UDP 上运行)  。HTTP 客户首先发起一个与服务器的 TCP 连接 一旦连接建立，该浏览器和 服务器进程就可以通过套接字接口访问 TCP。</p>
<p><strong><em>HTTP 个无状态协议 (stateless protocol)</em></strong></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>进程通信</title>
    <url>/2022/02/17/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CDN</title>
    <url>/2021/03/14/CDN/</url>
    <content><![CDATA[<h2 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h2><p><code>CDN（内容分发网络）</code>全称是 <code>Content Delivery Network</code>，建立并覆盖在承载网之上、由分布在不同区域的边缘节点服务器群组成的分布式网络，替代传统以 <code>WEB Server</code> 为中心的数据传输模式。</p>
<p>作用是将源内容发布到边缘节点，配合精准的<strong>调度系统</strong>；将用户的请求分配至最适合他的节点，使用户可以以最快的速度取得他所需的内容，有效解决Internet网络拥塞状况，提高用户访问的响应速度。</p>
<h3 id="CDN的基本工作过程"><a href="#CDN的基本工作过程" class="headerlink" title="CDN的基本工作过程"></a>CDN的基本工作过程</h3><p>用户通过浏览器等方式访问网站的过程如图所示：</p>
<img data-src="/2021/03/14/CDN/01.png" class>

<ol>
<li>用户在自己的浏览器中输入要访问的网站域名。</li>
<li>浏览器向 <strong>本地DNS服务器</strong> 请求对该域名的解析。</li>
<li>本地DNS服务器中如果缓存有这个域名的解析结果，则直接响应用户的解析请求。</li>
<li>本地DNS服务器中如果没有关于这个域名的解析结果的缓存，则以递归方式向整个DNS系统请求解析，获得应答后将结果反馈给浏览器。</li>
<li>浏览器得到域名解析结果，就是该域名相应的服务设备的 <strong>IP地址</strong> 。</li>
<li>浏览器向服务器请求内容。</li>
<li>服务器将用户请求内容传送给浏览器。</li>
</ol>
<p>在网站和用户之间加入 CDN 以后，用户不会有任何与原来不同的感觉。最简单的 CDN 网络有一个 DNS 服务器和几台缓存服务器就可以运行了。一个典型的 CDN 用户访问<strong>调度流程</strong>如图所示:</p>
<img data-src="/2021/03/14/CDN/02.png" class>

<ol>
<li>当用户点击网站页面上的内容URL，经过本地DNS系统解析，DNS 系统会最终将域名的解析权交给 <a href="https://en.wikipedia.org/wiki/CNAME_record">CNAME</a> 指向的 <strong>CDN 专用 DNS 服务器</strong>。</li>
<li>CDN 的 DNS 服务器将 CDN 的全局负载均衡设备 IP 地址返回用户。</li>
<li>用户向 CDN 的全局负载均衡设备发起内容 URL 访问请求。</li>
<li>CDN 全局负载均衡设备根据用户 IP 地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。</li>
<li>基于以下这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址：<ul>
<li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li>
<li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需内容；</li>
<li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li>
</ul>
</li>
<li>全局负载均衡设备把<strong>服务器的 IP 地址</strong>返回给用户。</li>
<li>用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。如果这台缓存服务器上并没有用户想要的内容，而区域均衡设备依然将它分配给了用户，那么这台服务器就要向它的上一级缓存服务器请求内容，直至追溯到网站的源服务器将内容拉到本地。</li>
</ol>
<p><strong>DNS 服务器根据用户 IP 地址，将域名解析成相应节点的缓存服务器IP地址，实现用户就近访问。</strong>使用 CDN 服务的网站，只需将其域名解析权交给 CDN 的全局负载均衡（GSLB）设备，将需要分发的内容注入 CDN，就可以实现内容加速了。</p>
<p>使用CDN后的<strong>http请求处理流程</strong>如下图，其中左边为<strong>DNS解析过程</strong>，右边为<strong>内容访问过程</strong>：</p>
<img data-src="/2021/03/14/CDN/03.png" class>

<h3 id="CDN的功能架构"><a href="#CDN的功能架构" class="headerlink" title="CDN的功能架构"></a>CDN的功能架构</h3><p>CDN基于这样的原理：</p>
<ol>
<li>挑选最优设备为用户提供服务；</li>
<li>如果某个内容被很多用户所需要，它就被缓存到距离用户最近的节点中。</li>
</ol>
<p>CDN 公司在整个互联网上部署数以百计的CDN服务器（Cache），这些服务器通常在运营商的 <code>IDC (互联网数据中心Internet Data Center）</code>中，尽量靠近接入网络和用户。CDN在Cache中复制内容，当内容的提供者更新内容时，CDN 向Cache重新分发这些被刷新的内容。CDN提供一种机制，当用户请求内容时，该内容能够由以最快速度交付的Cache 来向用户提供，这个挑选”最优”的过程就叫做<strong>负载均衡</strong>。被选中的最优 Cache 可能最靠近用户，或者有一条与用户之间条件最好的路径。</p>
<p>从功能上划分，典型的 CDN 系统架构由<code>分发服务系统</code>、<code>负载均衡系统</code>和<code>运营管理系统</code>三大部分组成，如图所示：</p>
<img data-src="/2021/03/14/CDN/04.png" class>

<h4 id="分发服务系统"><a href="#分发服务系统" class="headerlink" title="分发服务系统"></a>分发服务系统</h4><p>该系统的主要作用是实现将内容从内容源中心向边缘的推送和存储，承担实际的内容数据流的全网分发工作和面向最终用户的数据请求服务。分发服务系统最基本的工作单元就是许许多多的 Cache设备（缓存服务器），Cache 负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时 Cache 还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。</p>
<p>一般来说，根据承载内容类型和服务种类的不同，分发服务系统会分为多个子服务系统，如<code>网页加速子系统</code>、<code>流媒体加速子系统</code>、<code>应用加速子系统</code>等。每个子服务系统都是一个分布式服务集群，由一群功能近似的、在地理位置上分布部署的 Cache 或 Cache 集群组成，彼此间相互独立。每个子服务系统设备集群的数量根据业务发展和市场需要的不同，少则几十台，多则可达上万台，对外形成一个整体，共同承担分发服务工作。<strong>Cache 设备的数量、规模、总服务能力是衡量一个 CDN 系统服务能力的最基本的指标。</strong></p>
<p>分发服务系统在承担内容的更新、同步和响应用户需求的同时，还需要向上层的调度控制系统提供每个Cache设备的<strong>健康状况信息、响应情况</strong>，有时还需要提供内容分布信息，以便调度控制系统根据设定的策略决定由哪个Cache（组）来响应用户的请求最优。</p>
<h4 id="负载均衡系统"><a href="#负载均衡系统" class="headerlink" title="负载均衡系统"></a>负载均衡系统</h4><p>负载均衡系统是一个 CDN 系统的神经中枢，主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。大多数 CDN 系统的负载均衡系统是分级实现的，这里以最基本的两级调度体系进行简要说明。一般而言，两级调度体系分为<code>全局负载均衡（GSLB）</code>和<code>本地负载均衡（SLB）</code>。</p>
<p>其中，全局负载均衡（GSLB）主要根据 <strong>用户就近性原则</strong>，通过对每个服务节点进行”最优”判断，确定向用户提供服务的 Cache 的物理位置。最通用的 GSLB 实现方法是基于<code>DNS解析</code>的方式实现，也有一些系统采用了<code>应用层重定向</code>等方式来解决。本地负载均衡（SLB）主要负责节点内部的设备负载均衡，当用户请求从 GSLB 调度到 SLB 时，SLB 会根据节点内各 Cache 设备的实际能力或内容分布等因素对用户进行重定向，常用的本地负载均衡方法有<code>基于4层调度</code>、<code>基于7层调度</code>、<code>链路负载调度</code>等。</p>
<h4 id="运营管理系统"><a href="#运营管理系统" class="headerlink" title="运营管理系统"></a>运营管理系统</h4><p>CDN的运营管理系统与一般的电信运营管理系统类似，分为运营管理和网络管理两个子系统。</p>
<p>运营管理子系统是CDN系统的业务管理功能实体，负责处理业务层面的与外界系统交互所必需的一些收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</p>
<p>网络管理子系统实现对CDN系统的<strong>网络设备管理、拓扑管理、链路监控和故障管理</strong>，为管理员提供对全网资源进行集中化管理操作的界面，通常是基于Web方式实现的。</p>
<h3 id="CDN的部署架构"><a href="#CDN的部署架构" class="headerlink" title="CDN的部署架构"></a>CDN的部署架构</h3><p>CDN 系统设计的首要目标是尽量减少用户的访问响应时间，为达到这一目标，CDN 系统应该尽量将用户所需要的内容存放在距离用户最近的位置。也就是说，负责为用户提供内容服务的 Cache 设备应部署在物理上的网络边缘位置，我们称这一层为<code>CDN边缘层</code>。CDN 系统中负责全局性管理和控制的设备组成 <code>中心层</code>，中心层同时保存着最多的内容副本，当边缘层设备未命中时，会向中心层请求，如果在中心层仍未命中，则需要中心层向源站回源。</p>
<p>不同CDN系统设计之间存在差异，中心层可能具备用户服务能力，也可能不直接提供服务，只向下级节点提供内容。如果CDN网络规模较大，边缘层设备直接向中心层请求内容或服务会造成中心层设备压力过大，就要考虑在边缘层和中心层之间部署一个<code>区域层</code>，负责一个区域的管理和控制，也保存部分内容副本供边缘层访问。</p>
<p>如图是一个典型的CDN系统三级部署示意图:</p>
<img data-src="/2021/03/14/CDN/05.png" class>

<p>节点是 CDN 系统中最基本的部署单元，一个CDN系统由大量的、地理位置上分散的 POP（point-of-presence）节点组成，为用户提供就近的内容访问服务。</p>
<p>CDN 节点网络主要包含 <code>CDN 骨干点</code>和 <code>POP 点</code>。<code>CDN 骨干点</code>和 <code>CDN POP 点</code>在功能上不同。</p>
<ul>
<li>中心和区域节点一般称为骨干点，主要作为内容分发和边缘未命中时的服务点；</li>
<li>边缘节点又被称为<code>POP（point-of-presence）节点</code>，CDN POP点主要作为直接向用户提供服务的节点。</li>
</ul>
<p>但是，从节点构成上来说，无论是CDN骨干点还是CDN POP点，都由Cache设备和本地负载均衡设备构成。</p>
<p>在一个节点中，Cache设备和本地负载均衡设备的连接方式有两种：一种是旁路方式，一种是穿越方式。</p>
<p>如图所示：</p>
<img data-src="/2021/03/14/CDN/06.png" class>

<p>在穿越方式下，<code>SLB（Server Load Balancer，负载均衡</code> 一般由 L4-7 交换机实现，SLB 向外提供可访问的 <code>公网IP地址（VIP</code>，每台Cache仅分配私网IP地址，该台SLB下挂的所有Cache构成一个服务组。所有用户请求和媒体流都经过该SLB设备，再由SLB设备进行向上向下转发。SLB实际上承担了 <code>NAT（Network Address Translation，网络地址转换）</code>功能，向用户屏蔽了Cache设备的IP地址。这种方式是CDN系统中应用较多的方式，优点是具有较高的安全性和可靠性，缺点是L4-7交换机通常较为昂贵。另外，当节点容量大时，L4-7交换机容易形成性能瓶颈。不过近年来，随着 <code>LVS (Linux Virtual Server，即Linux虚拟服务器)</code> 等技术的兴起，SLB设备价格有了大幅下降。</p>
<p>在旁路方式下，有两种 SLB 实现方式：</p>
<ul>
<li>在早期，这种 SLB 一般由软件实现。SLB 和 Cache 设备都具有公共的IP地址，SLB 和 Cache 构成并联关系。用户需要先访问 SLB 设备，然后再以重定向的方式访问特定的 Cache。这种实现方式简单灵活，扩展性好，缺点是安全性较差，而且需要依赖于应用层重定向。</li>
<li>随着技术的发展，L4-7 交换机也可采用旁路部署（负载均衡硬件设备的部署）方式，旁挂在路由交换设备上，数据流量通过三角传输方式进行。</li>
</ul>
<p>在CDN系统中，不仅分发服务系统和调度控制系统是分布式部署的，运营管理系统也是分级分布式部署的，每个节点都是运营管理数据的生成点和采集点，通过日志和网管代理等方式上报数据。<strong>可以说，CDN本身就是一个大型的具有中央控制能力的分布式服务系统。</strong></p>
<h2 id="为什么需要CDN"><a href="#为什么需要CDN" class="headerlink" title="为什么需要CDN"></a>为什么需要CDN</h2><p>当下的互联网应用都包含大量的静态内容，但静态内容以及一些准动态内容又是最耗费带宽的，特别是针对全国甚至全世界的大型网站，如果这些请求都指向主站的服务器的话，不仅是主站服务器受不了，单端口500M左右的带宽也扛不住，所以大多数网站都需要CDN服务。</p>
<p>根本上的原因是，访问速度对互联网应用的用户体验、口碑、甚至说直接的营收都有巨大的影响，任何的企业都渴望自己站点有更快的访问速度。而HTTP传输时延对web的访问速度的影响很大，在绝大多数情况下是起决定性作用的，这是由TCP/IP协议的一些特点决定的。物理层上的原因是光速有限、信道有限，协议上的原因有丢包、慢启动、拥塞控制等。</p>
<p>这就是你使用CDN的第一个也是最重要的原因：<strong>为了加速网站的访问。</strong></p>
<p>除了加速网站的访问之外，CDN还有一些作用：</p>
<ul>
<li>为了实现跨运营商、跨地域的全网覆盖</li>
</ul>
<p>互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。阿里云在国内有500+节点，海外300+节点，覆盖主流国家和地区不是问题，可以确保CDN服务的稳定和快速。</p>
<ul>
<li>为了保障你的网站安全</li>
</ul>
<p>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</p>
<ul>
<li>为了异地备援</li>
</ul>
<p>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。</p>
<ul>
<li>为了节约成本</li>
</ul>
<p>投入使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</p>
<ul>
<li>为了让你更专注业务本身</li>
</ul>
<p>CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="网站站点-应用加速"><a href="#网站站点-应用加速" class="headerlink" title="网站站点/应用加速"></a>网站站点/应用加速</h3><p>站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，建议结合 对象存储OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p>
<img data-src="/2021/03/14/CDN/07.png" class>

<h3 id="视音频点播-大文件下载分发加速"><a href="#视音频点播-大文件下载分发加速" class="headerlink" title="视音频点播/大文件下载分发加速"></a>视音频点播/大文件下载分发加速</h3><p>支持各类文件的下载、分发，支持在线点播加速业务，如mp4、flv视频文件或者平均单个文件大小在20M以上，主要的业务场景是视音频点播、大文件下载（如安装包下载）等，建议搭配对象存储OSS使用，可提升回源速度，节约近2/3回源带宽成本。</p>
<img data-src="/2021/03/14/CDN/08.png" class>

<h3 id="视频直播加速"><a href="#视频直播加速" class="headerlink" title="视频直播加速"></a>视频直播加速</h3><p>视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。</p>
<img data-src="/2021/03/14/CDN/09.png" class>

<h3 id="移动应用加速"><a href="#移动应用加速" class="headerlink" title="移动应用加速"></a>移动应用加速</h3><p>移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。</p>
<img data-src="/2021/03/14/CDN/10.png" class>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="流量劫持"><a href="#流量劫持" class="headerlink" title="流量劫持"></a>流量劫持</h3><p>其实，CDN本身就是一种DNS劫持，只不过是良性的。 不同于黑客强制DNS把域名解析到自己的钓鱼IP上，CDN则是让DNS主动配合，把域名解析到临近的服务器上。</p>
<p>劫持通常分为两类：</p>
<ol>
<li>域名劫持，又称<code>DNS劫持</code>，通常是指域名指向到非正常IP（恶意IP），该恶意IP通过反向代理的方式，在能返回网页正常内容的情况，可能插入恶意代码、监听网民访问、劫持敏感信息等操作。通常验证一个域名是否被劫持的方法是PING一个域名，如果发现PING出来的IP不是您的服务器真实IP，则可以确定被劫持了（当然如果使用了知道创宇云安全等安全加速平台，得到的IP为平台IP，并非劫持）</li>
<li>数据劫持，通常由电信运营商中某些员工等勾结犯罪分子，在公网中进行数据支持，插入，此类情况极隐蔽，不会改变用户域名解析IP，而是直接数据流经运营商宽带时在网页中挺入内容，此类情况，建议网页启用<code>HTTPS加密</code>，可以解决这一问题（通信是加密的，运营商无法插入恶意内容）</li>
</ol>
<p>某运营商对新浪首页的广告强制插入：</p>
<img data-src="/2021/03/14/CDN/11.png" class>

<p>如果使用CDN服务时，当源站向CDN返回被劫持的内容时，此时CDN将获取到的并不是正确的网页内容（而是经运营商篡改强制植入广告的页面），此时可能导致该内容在CDN中长时间缓存，发现这种问题，可以清理CDN缓存后，一般即可恢复正常。</p>
<p>遇到劫持现象，可以向工信部投诉：<a href="http://www.chinatcc.gov.cn:8080/cms/shensus/">http://www.chinatcc.gov.cn:80…</a></p>
<p>可参考：</p>
<ul>
<li><a href="http://paper.seebug.org/181/">互联网黑势力之流量劫持</a></li>
<li><a href="http://blog.sae.sina.com.cn/archives/3464">流量劫持是如何产生的？</a></li>
</ul>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的 <code>Cache-control: max-age</code>的字段来设置CDN边缘节点数据缓存时间。</p>
<p>当客户端向CDN节点请求数据时，CDN节点会判断缓存数据是否过期，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出<code>回源请求（back to the source request）</code>，从源站拉取最新数据，更新本地缓存，并将最新数据返回给客户端。</p>
<p>CDN服务商一般会提供基于文件后缀、目录多个维度来指定CDN缓存时间，为用户提供更精细化的缓存管理。</p>
<p>CDN缓存时间会对<code>回源率</code>产生直接的影响。若CDN缓存时间较短，CDN边缘节点上的数据会经常失效，导致频繁回源，增加了源站的负载，同时也增大的访问延时；若CDN缓存时间太长，会带来数据更新时间慢的问题。开发者需要增对特定的业务，来做特定的数据缓存时间管理。</p>
<p>CDN边缘节点对开发者是透明的，相比于浏览器 <code>Ctrl+F5</code> 的强制刷新来使浏览器本地缓存失效，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用 <code>刷新缓存</code> 功能来强制CDN节点上的数据缓存过期，保证客户端在访问时，拉取到最新的数据。</p>
<p>可参考：</p>
<ul>
<li><a href="https://xuexb.com/post/qing-chu-jing-tai-cdnhuan-cun-de-yan-jiu.html">清除静态cdn缓存的研究</a></li>
</ul>
<h2 id="深入研究"><a href="#深入研究" class="headerlink" title="深入研究"></a>深入研究</h2><ul>
<li>阿里基于Nginx开发的高性能HTTP服务器，已经开源，详细请了解 <a href="https://link.zhihu.com/?target=http://tengine.taobao.org/">The Tengine Web Server</a></li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>负载均衡</tag>
      </tags>
  </entry>
  <entry>
    <title>Process</title>
    <url>/2022/02/16/Process/</url>
    <content><![CDATA[<h1 id="Unix-Process"><a href="#Unix-Process" class="headerlink" title="Unix Process"></a>Unix Process</h1><img data-src="/2022/02/16/Process/image16.png" class>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>进程就是处于执行期的程序(目标码存放在某种存储介质上)。但进程并不仅仅局限于一段可执行程序代码(Unix称其为代码段，text section)，通常<strong>进程还要包含其他资源</strong>，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程(thread of execution),当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明地管理所有细节。</p>
<blockquote>
<p>所以说，程序本身并不是进程，<strong>进程是处于执行期的程序以及相关资源的总称</strong></p>
</blockquote>
<h3 id="进程的两种虚拟机制"><a href="#进程的两种虚拟机制" class="headerlink" title="进程的两种虚拟机制"></a>进程的两种虚拟机制</h3><ul>
<li><p>虚拟处理器</p>
<p>虽然实际上可能是 许多进程正在分享一个处理器，但虚拟处理器给进程一种假象，让这些进程觉得自己在独享处理器</p>
</li>
<li><p>虚拟内存</p>
<p>虚拟内存让进程在分配和管理内存时觉得自己拥有整个 系统的所有内存资源。</p>
</li>
</ul>
<h2 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h2><p>内核把<strong>进程的列表</strong>存放在叫做<strong>任务队列(task list©)的双向循环链表</strong>中。链表中的每一 项都是类型为task_struct、称为<strong>进程描述符</strong>(process descriptor)的结构，该结构定义在＜linux/ sched.h＞文件中。<strong>进程描述符中包含一个具体进程的所有信息</strong>。</p>
<p>进程描述符中包含的数据能完整 地描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有其他更多信息</p>
 <img data-src="/2022/02/16/Process/image01.png" class>

<h3 id="分配进程描述符-slab-thread-info"><a href="#分配进程描述符-slab-thread-info" class="headerlink" title="分配进程描述符(slab+thread_info)"></a>分配进程描述符(slab+thread_info)</h3><p>Linux通过<strong>slab分配器</strong>分配task_struct结构，这样能达到<strong>对象复用</strong>和<strong>缓存着色</strong>（cache coloring）</p>
<p>在2.6以前的内核中，各个进程的task_struct存放在它们 内核栈的尾端。这样做是为了让那些像x86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，而避免使用额外的寄存器专门记录。由于现在用slab分配器动态生成task_ struct,所以只需在栈底（对于向下增长的栈来说）或栈顶（对于向上增长的栈来说）创建一个 新的结构 struct thread_info 。</p>
  <img data-src="/2022/02/16/Process/image02.png" class>



 <img data-src="/2022/02/16/Process/image03.png" class>

<p>每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任 务实际task_struct的指针。</p>
<h3 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h3><p>内核通过一个唯一的进程标识值（process identification value）或<strong>PID</strong>来标识每个进程。PID是 一个数，表示为pid_t隐含类型,实际上就是一个int类型。为了与老版本的Unix和Linux兼容， PID的最大值默认设置为32768 （short int短整型的最大值,），这个最大值很重要，因为它实际上就是系统中允许同时存在的进程的最大数目。尽管这个值也可以增加到高达400万 （这受&lt;linux/threads.h＞中所定义PID最大值的限制）。内核把每个进程的PID存放在它们各自的进程描述符中。 </p>
<p>在内核中，<strong>访问任务通常需要获得指向其task_struct的指针</strong>。实际上，内核中大部分处理进程的代码都是直接通过task_struct进行的。因此，通过<strong>current宏査找到当前正在运行进程</strong>的进程描述符的速度就显得尤为重要。硬件体系结构不同，该宏的实现也不同，它必须针对专门的硬件体系结构做处理。</p>
<ul>
<li>有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程task_struct 的指针，用于加快访问速度。</li>
<li>像x86这样的体系结构（其寄存器并不富余），就只能在内 核栈的尾端创建thread_info结构，通过计算偏移间接地查找task_struct结构。 </li>
</ul>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程描述符中的state域描述了进程的当前状态，系统中的每个进程都必然处于五种进程状态中的一种。该域的值也必为下列五种状态标志之一:</p>
<ul>
<li><p><strong>TASK_RUNNING</strong> （运行）— 进程是可执行的；它或者正在执行，或者在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态； 这种状态也可以应用到内核空间中正在执行的进程。</p>
</li>
<li><p>**TASK_INTERRUPTIBLE **（可中断）— 进程正在睡眠（也就是说它被阻塞），等待某些条 件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会 因为接收到信号而提前被唤醒并随时准备投入运行</p>
</li>
<li><p>**TASK_UNINTERRUPTIBLE **（不可中断）— 除了就算是接收到信号也不会被唤醒或准备 投入运行外，这个状态与可打断状态相同。这个状态通常在进程必须在等待时不受干扰或 等待事件很快就会发生时出现。由于处于此状态的任务对信号不做响应，所以较之可中断 状态e,使用得较少。</p>
</li>
<li><p><strong>_TASK_TRACED</strong>—被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。</p>
</li>
<li><p>**_TASK_STOPPED **（停止）— 进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP, SIGTTIN, SIGTTOU等信号的时候。此外, 在调试期间接收到任何信号，都会使进程进入这种状态。</p>
<img data-src="/2022/02/16/Process/image04.png" class>

</li>
</ul>
<h3 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h3> <img data-src="/2022/02/16/Process/image05.png" class>



<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间 执行。一般程序在用户空间执行。当一个程序调执行了系统调用或者触发了某个 异常，它就<strong>陷入了内核空间</strong>。此时，我们称内核“代表进程执行”并<strong>处于进程上下文</strong>中。在此上下文中current宏是有效的°。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间会继续执行。 系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核 执行— 对内核的所有访问都必须通过这些接口。</p>
<p>​    </p>
<h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>Unix系统的进程之间存在一个明显的继承关系，在Linux系统中也是如此。所有的进程都 是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初 始化脚本(initscript)并执行其他的相关程序，最终完成系统启动的整个过程</p>
<p>系统中的每个进程必有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。拥 有同一个父进程的所有进程被称为兄弟。<strong>进程间的关系存放在进程描述符中</strong>。每个task_struct都 包含一个指向其<strong>父进程tast_struct</strong>、叫做<strong>parent</strong>的指针，还包含一个称为<strong>children的子进程链表</strong>。 所以。</p>
<ul>
<li>对于当前进程，通过下面的代码获得其父进程的进程描述符：</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span>  current-&gt;parent;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>通过以下方式访问子进程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>,&amp;current-&gt;children)&#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>,struct task_struct,sibling); <span class="comment">//task指向当前的某个子进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
 <img data-src="/2022/02/16/Process/image06.png" class>

<h2 id="进程创建（fork-exec）"><a href="#进程创建（fork-exec）" class="headerlink" title="进程创建（fork+exec）"></a>进程创建（fork+exec）</h2><p>在新的地址空间创建线程，读入可执行文件，最后开始执行。</p>
<blockquote>
<p>fork</p>
</blockquote>
<p><strong>拷贝当前进程创建一个子进程</strong>。子进程与父进程的区别仅仅在于PID (每个进程唯一)、PPID (父进程的进程号，子进程将其设置为被拷贝进程的PID)和某些资源和统计量(例如，挂起的信号，它没有必要被继承)。</p>
<blockquote>
<p>exec</p>
</blockquote>
<p><strong>exec()函数负责读取可执行文件并将其载入地址空间开始运行</strong>。把这两个函数组合起来使用的效果跟其他系统使用的单一函数的效果相似。</p>
<h3 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h3><p>传统的fork()系统调用<strong>直接把所有的资源复制给新创建的进程</strong></p>
<p>Linux的fbrk()使用写时拷贝(copy-on-write)页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。</p>
<p><strong>只有在需要写入的时候</strong>，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资 源的复制只有在需要写入的时候才进行，在此之前，<strong>只是以只读方式共享</strong>。这种技术使地址空间 上的页的拷贝被推迟到实际发生写入的时候才进行。在页根本不会被写入的情况下(举例来说， fork。后立即调用exec())它们就无须复制了</p>
<p><strong>fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符</strong>。在一般情况 下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本就不会被使用的数据(地址空间里常常包含数十兆的数据)。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。</p>
<h3 id="frok-函数"><a href="#frok-函数" class="headerlink" title="frok()函数"></a>frok()函数</h3><p>Linux通过<strong>clone()系统调用</strong>实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源</p>
<blockquote>
<p>fbrk()、▼fork和_clone () 库函数都<strong>根据各自需要的参数</strong>标志去调用clone(),然后由clone()去调用do_fork().</p>
</blockquote>
<p>do_fork完成了创建中的大部分工作，它的定义在kernel/fork.c文件中。该函数调用copy_ process()函数，然后让进程开始运行。</p>
<p>**copy_process()**函数流程如下：</p>
 <img data-src="/2022/02/16/Process/image07.png" class>

 <img data-src="/2022/02/16/Process/image08.png" class>

<p>再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其 投入运行。<strong>内核有意选择子进程首先执行</strong>°。因为一般子进程都会马上调用exec()函数，这样可 以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<h3 id="vfork-函数"><a href="#vfork-函数" class="headerlink" title="vfork()函数"></a>vfork()函数</h3> <img data-src="/2022/02/16/Process/image09.png" class>

<h2 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h2><p>线程机制是现代编程技术中常用的一种抽象概念。该机制提供了在同一程序内共享内存地址 空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。线程机制<strong>支持并发</strong>程序设计 技术(concurrentprogramming),在多处理器系统上，它也能<strong>保证真正的并行处理</strong>(parallelism)。</p>
<p>Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。<strong>Linux把所有的线程都当做进程来实现</strong>。<strong>内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程</strong>。相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自 己的task_struct,所以在内核中，它看起来就像是一个普通的进程(只是线程和其他一些进程共 享某些资源，如地址空间)。</p>
<p>上述线程机制的实现与Microsoft Windows或是Sun Solaris等操作系统的实现差异非常 大。这些系统都在内核中提供了专门支持线程的机制(这些系统常常把线程称作轻量级进程 (lightweight processes))o “轻量级进程”这种叫法本身就概括了 Linux在此处与其他系统的差 异。在其他的系统中，相较于重量级的进程，线程被抽象成一种耗费较少资源，运行迅速的执行单元。而对于**<em>Linux来说，它只是一种进程间共享资源的手段(**</em>Linux的进程本身就够轻量级了)°。 举个例子来说，假如我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有 一个包含指向四个不同线程的指针的进程描述符。该描述符负责描述像地址空间、打开的文件这 样的共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅<strong>创建四个进程并分配四个普通的task_sturct结构</strong>。建立这四个进程时指定他们共享某些资源，这是相当高雅的做法。</p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS |CLONE_FILES |CLONE_SIGHAND,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>传递给clone()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。</p>
 <img data-src="/2022/02/16/Process/image10.png" class>

 <img data-src="/2022/02/16/Process/image11.png" class>



<h3 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h3><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程(kernel thread)完成— 独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程**<em>没有独立的地址空间**</em>(实际上指向地址空间的mm指针被设置为NULL).它们<strong>只在内核空间运行</strong>，<strong>从来不切到用户空间</strong>去。内核进程和普通进程一样，可以被调度，也可以被抢占。</p>
<p>在装有Linux系统的机子上运行<strong>ps -ef</strong>命令，你可以看到内核线程，有很多！这些线程在系统启 动时由另外一些内核线程创建。实际上，内核线程也只能由其他内核线程创建。<strong>内核是通过从 kthreadd内核进程中衍生出所有新的内核线程来自动处理这一点的</strong>。创建的进程处于不可运行状态，如果不通过调用<strong>wake_up_process()</strong> 明确地唤醒它，它不会主动运行。创建一个进程并让它运行起来，可以通过调用<strong>kthread_run()</strong> 来达到</p>
 <img data-src="/2022/02/16/Process/image12.png" class>

<p><strong>kthread_run()</strong> 宏实现</p>
 <img data-src="/2022/02/16/Process/image13.png" class>

<p>内核线程启动后就一直运行直到调用do_exit()退出，或者内核的其他部分调用kthread_ stop()退出，传递给kthread_stop()的参数为kthread_create()函数返回的task struct结构的地址：</p>
<blockquote>
<p>int kthread_stop(struct task_struct *k)</p>
</blockquote>
<h2 id="进程的终结"><a href="#进程的终结" class="headerlink" title="进程的终结"></a>进程的终结</h2><blockquote>
<p>当一个进程终结时，内核必须释放它所占有的资源 并把这一不幸告知其父进程。</p>
</blockquote>
<p>进程的析构是自身引起的。它发生在进程<strong>调用exit()系统调用</strong>时，</p>
<ul>
<li><p>既可能显式地调用这个系统调用</p>
</li>
<li><p>也可能隐式地从某个程序的主函数返回(其实C语言编译器会在main() 函数的返回点后面放置调用exit()的代码)。</p>
</li>
<li><p>当进程接受到它既不能处理也不能忽略的信号或异 常时，它还可能被动地终结。</p>
<p>不管进程是怎么终结的，该任务大部分都要靠<strong>do_exit()</strong>(定义于 kemel/exitx)来完成，</p>
</li>
</ul>
<p>do_exit完成的工作</p>
 <img data-src="/2022/02/16/Process/image14.png" class>

<p>的进程不会再被调度，所以这是进程所执行的最后一段代码。do_exit()永不返回。</p>
<p>与进程相关联的<strong>所有资源都被释放掉了</strong>(假设该进程是这些资源的唯一使用者)。进程<strong>不可运行</strong>(实际上也没有地址空间让它运行)并处于<strong>EXIT_ZOMBIE</strong>退出状态。它占用的所 有内存就是内核栈、thread_infb结构和tast_struct结构。此时<strong>进程存在的唯一目的就是向它的父进程提供信息</strong>。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内 存被释放，归还给系统使用。</p>
<h3 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h3><p>在调用了 do_exit()之后，尽管线程已经僵死不能再运行了，但是系统还<strong>保留了它的进程描述符</strong>。这样做可以让系统有办法在子进程终结后仍能获得它的信息。因此，**<em>进程终结时所需的清理工作和进程描述符的删除被分开执行**</em>。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。 </p>
 <img data-src="/2022/02/16/Process/image15.png" class>

<h3 id="孤儿进程（父进程在子进程之前推出）"><a href="#孤儿进程（父进程在子进程之前推出）" class="headerlink" title="孤儿进程（父进程在子进程之前推出）"></a>孤儿进程（父进程在子进程之前推出）</h3><p>如果<strong>父进程在子进程之前退出</strong>，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白地耗费内存。</p>
<p><strong>解决方法</strong>给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。在do_exit()中会调用exit_notify(),该函数会调用fbrget_original_parent(),而后者会调用find_new_reaper()来执行寻父过程：</p>
<p>一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。 init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。</p>
<p>父进程通过wait()系统调用族来收集其后代信息</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>Linux内核</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客网刷题-操作系统1</title>
    <url>/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/</url>
    <content><![CDATA[<ul>
<li><p>Windows 操作系统具有较强的存储管理功能，当主存容量不够时系统可以自动地扩充，为应用程序提供一个容量比实际物理主存大得多的存储空间。这种存储管理技术称为**<em>虚拟缓存器技术**</em></p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image01.png" class>

<ul>
<li><p>详细解释</p>
<ul>
<li><p>缓冲区技术，是为了协调吞吐速度相差很大的设置之间数据传送而采用的技术；</p>
</li>
<li><p>虚拟存储器技术，是为应用程序提供一个容量比实际物理主存大得多的存储空间，使当主存容量不够时系统可以自动地扩充的技术；</p>
</li>
<li><p>SPOOLing技术，是低速输入输出设备与主机交换的一种技术，也称为“假脱机真联机”技术</p>
</li>
<li><p>进程调度技术，是负责决定哪个进程投入运行，何时运行以及运行多长时间的技术</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>一个多道批处理系统中仅有 P1 和 P2 两个作业， P2 比 P1 晚 5ms 到达，它们的计算和 I/O 操作顺序如下：</p>
<p>P1 ：计算 60ms ， I/O 80ms ，计算 20ms</p>
<p>P2 ：计算 120ms ， I/O 40ms ，计算 40ms</p>
<p>若不考虑调度和切换时间，则完成两个作业需要的时间最少是 。**<em>（260ms）**</em></p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image02.png" class>



</li>
</ul>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image03.png" class>



<ul>
<li><p>​    在下列文件的物理结构中，不便于增删文件内容的是 <strong><em>连续文件</em></strong></p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image04.png" class>

<ul>
<li><p>详细解释</p>
<ul>
<li><p><strong>连续文件</strong>类似于<strong>数组</strong>，顺序访问速度快，但是增删数据时要移动其他数据块，所以速度很慢；</p>
</li>
<li><p><strong>链接文件</strong>类似于<strong>链表</strong>，随机访问速度慢，增删数据很快，不需要移动数据块，只需要改变指针指向即可；</p>
</li>
<li><p><strong>索引文件</strong>糅合了连续文件和链接文件，但更适合大文件；</p>
</li>
<li><p><strong>Windows使用显式链接文件</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>为提高操作系统自身的可适应性和可扩展性，现代操作系统通过引入和实现( <strong><em>逻辑设备</em></strong>) 的概念而实现了设备独立性。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image05.png" class>
</li>
<li><p>在操作系统中，用户程序申请使用 I/O 设备时，通常采用（ ）。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image06.png" class>

</li>
</ul>
<p>现代操作系统为了提高系统的可适应性和可扩展性，都实现了设备独立性或设备无关性。基本含义是**<em>应用程序独立于具体使用的物理设备，应用程序以逻辑设备名请求使用某类设备**</em>。实现了设备独立性功能可带来两方面的好处：</p>
<p>（1）设备分配时的灵活性；</p>
<p>（2）易于实现I/O 重定向。为了实现设备的独立性，应引入逻辑设备和物理设备概念。在应用程序中，使用逻辑设备名请求使用某类设备；系统执行时是使用物理设备名。鉴于驱动程序是与硬件或设备紧密相关的软件，必须在驱动程序之上设置一层设备独立性软件，<strong>执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换</strong>（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性。</p>
<blockquote>
<p>虚拟设备名</p>
</blockquote>
<p>通过<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%8A%80%E6%9C%AF/4968684">虚拟技术</a>将一台独占设备虚拟成多台逻辑设备，供多个进程同时使用的设备的名字。</p>
<p>虚拟设备技术的作用是提高慢速独占设备的利用率，采用了假脱机技术后—个程序对慢速独占设备的占用时间短了(因为连续了)。</p>
<blockquote>
<p>独占设备名</p>
</blockquote>
<p>独占设备：进程应互斥地访问这类设备，即系统一旦把这类设备分配给了某进程后，便由该进程独占，直到用完释放。典型的独占设备有打印机、磁带机等。系统在分配时，还应考虑到安全性</p>
<ul>
<li><p>现代OS具有并发性和共享性，是由（**<em>多道程序**</em>）的引入而导致的。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image07.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image44.png" class>



</li>
</ul>
<ul>
<li><p>下面的叙述中，（ <strong>节省系统内存</strong>）不是设备管理中引入缓冲机制的主要原因。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image08.png" class>



</li>
</ul>
<ul>
<li><p>若有 4 个进程共享同一程序段，而且每次最多允许 3 个进程进入该程序段，则信号量的变化范围是？</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image09.png" class>

</li>
</ul>
<p>最多允许3个进程进入，所以信号量初值为3，当程序段进入了三个进程后信号量变为0，第四个进程进入时，信号量减为-1。</p>
<ul>
<li><p>下列选项中，不属于进程关键要素的是________。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image10.png" class>

</li>
</ul>
<p>一般来说Linux系统中的进程都具备下列诸要素：</p>
<p>（1）有一段程序供其执行。（程序）</p>
<p>（2）有进程专用的系统堆栈空间。（数据和栈）</p>
<p>（3）在内核有task_struct数据结构。（进程控制块）</p>
<p>（4）有独立的存储空间，拥有专有的用户空间。</p>
<p>如果只具备前面三条而缺第四条，那就称为“线程”。如果完全没有用户空间，就称为“内核线程”；而如果共享用户空间则就称为“用户线程”。</p>
<ul>
<li>临界区是（） </li>
</ul>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image11.png" class>

<p>临界区：每个进程中访问临界资源的那段<strong>程序</strong>叫做临界区。进程对临界区的访问必须互斥，每次只允许一个进程进去临界区，其他进程等待</p>
<ul>
<li><p>在一单处理机系统中，若有4 个用户进程，在某一时刻，处于阻塞状态的用户进程最多有</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image12.png" class>

</li>
</ul>
<p>处于死锁的情况下。</p>
<ul>
<li><p>关于多线程和多线程编程，以下哪些说法正确的（）</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image13.png" class>





</li>
</ul>
<ul>
<li><p>计算机操作系统出现死锁的原因是什么?</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image14.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image15.png" class>





</li>
</ul>
<ul>
<li>同一文件系统中不允许文件同名 , 否则会引起混乱，这种说法正确吗？[<strong><em>错误</em></strong>]</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文件目录结构一般有一级目录结构、二级目录结构和多级目录结构。 一级目录结构的优点是简单，缺点是文件不能重名，限制了用户对文件的命名。 二级目录结构实现了文件从名字空间到外存地址空间的映射：用户名—&gt;文件名à文件内容。其优点是有利于文件的管理、共享和保护；适用于　 多用户系统；不同的用户可以命名相同文件名的文件，不会产生混淆，解决了命名冲突问题。缺点是不能对文件分类；当用文件较多时查找速度慢。</span><br><span class="line">多级目录结构的优点是便于文件分类，可为每类文件建立一个子目录；查找速度快，因为每个目录下的文件数目较少；可以实现文件共享；缺点是比较复杂。</span><br></pre></td></tr></table></figure>


<ul>
<li><p>死锁与安全状态的的关系是</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image16.png" class>

</li>
</ul>
<blockquote>
<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可以避免进入死锁状态。</p>
</blockquote>
<ul>
<li><p>一般用户更喜欢使用的系统是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image17.png" class>



</li>
</ul>
<blockquote>
<p>批处理系统</p>
</blockquote>
<p>  处理系统，又名批处理操作系统。<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86/1448600">批处理</a>是指<strong>用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行</strong>。这种采用<a href="https://baike.baidu.com/item/%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86/4973973">批量处理</a>作业技术的操作系统称为批处理操作系统。批处理操作系统分为<strong>单道批处理系统和<a href="https://baike.baidu.com/item/%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F/3792844">多道批处理系统</a>**。批处理操作系统</strong>不具有交互性**，它是为了提高CPU的利用率而提出的一种操作系统。</p>
  <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">所谓批处理(batch processing )就是将作业按照它们的性质分组（或分批），然后再成组（或成批）地提交给计算机系统，由计算机自动完成后再输出结果，从而减少作业建立和结束过程中的时间浪费。根据在内存中允许存放的作业数，批处理系统又分为单道批处理系统和多道批处理系统。早期的批处理系统属于单道批处理系统，其目的是减少作业间转换时的人工操作，从而减少CPU的等待时间。它的特征是内存中只允许存放一个作业，即当前正在运行的作业才能驻留内存，作业的执行顺序是先进先出，即按顺序执行。</span><br><span class="line">由于在单道批处理系统中，一个作业单独进入内存并独占系统资源，直到运行结束后下一个作业才能进入内存，当作业进行I/O操作时，CPU只能处于等待状态，因此，CPU利用率较低，尤其是对于I/O操作时间较长的作业。为了提高CPU的利用率，在单道批处理系统的基础上引入了多道程序设计（multiprogramming）技术，这就形成了多道批处理系统，即在内存中可同时存在若干道作业，作业执行的次序与进入内存的次序无严格的对应关系，因为这些作业是通过一定的作业调度算法来使用CPU的，一个作业在等待I/O处理时，CPU调度另外一个作业运行，因此CPU的利用率显著地提高了。</span><br><span class="line">批处理系统主要指多道批处理系统，它通常用在以科学计算为主的大中型计算机上，由于多道程序能交替使用CPU，提高了CPU及其他系统资源的利用率，同时也提高了系统的效率。多道批处理系统的缺点是延长了作业的周转时间，用户不能进行直接干预，缺少交互性，不利于程序的开发与调试。</span><br></pre></td></tr></table></figure>
<p>  <strong>操作系统的分类</strong></p>
   <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image18.png" class>



<ul>
<li>我们熟知的Windows XP、Linux、Mac OS X等都是<strong>多用户多任务分时操作系统</strong>，可见这个概念一直延续到了今天。它们最显著的特点就是可以让多个人使用同一台电脑而且不能互相窥探对方的秘密。当你使用电脑的时候可以边听音乐边看新闻，同时还能跟朋友聊天。只要你觉得你的大脑还能处理得过来，你还能让这台电脑同时干更多的事情。其实这类操作系统我们完全可以只用“<strong>分时</strong>”二字简要概述下来。因为“分时”就像它最初的定义那样：将电脑的时间资源适当分配给所有使用者身上，让所有使用者有独占机器的感觉。但是如果把“使者”进行抽象，就不仅可以代表人，还可以将任务也理解为电脑时间资源的使用者，那么<strong>“分时”就是多用户和多任务的基础和前提</strong>。所以，既然是“分时”的，一般都会支持多用户和多任务</li>
</ul>
<ul>
<li><p>能实现紧凑技术的存储管理（ ）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image19.png" class>

</li>
</ul>
<blockquote>
<p>—- 动态重定位分区分配算法与动态分区分配算法基本上相同，差别仅在于：在这种分配算法中，<strong>添加了紧凑功能</strong> <strong>。</strong></p>
<p>—- 通常，在找不到足够大的空闲分区来满足用户需求时进行紧凑。</p>
</blockquote>
<blockquote>
<p>存储器管理的对象是主存，也称内存。它的主要功能包括分配和回收主存空间、提高主存利用率、扩充主存、对主存信息实现有效保护。</p>
<p>存储管理方案的主要目的是解决多个用户使用主存的问题，其存储管理方案主要包括<strong>分区存储管理</strong>、<strong>分页存储管理</strong>、<strong>分段存储管理</strong>、<strong>段页式存储管理</strong>以及<strong>虚拟存储管理</strong>。</p>
<p>分区存储管理又有三种不同的方式：<strong>静态分区、可变分区、可重定位分区</strong> 。</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image20.png" class>



<ul>
<li><p>为实现设备分配，应为每一类设备配置一张 。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image21.png" class>

</li>
</ul>
<p>逻辑设备表（LUT）功能是完成逻辑名到物理设备名的映射。</p>
<p>设备分配表（DCT）是，系统为每一个设备配置了一张设备控制表，记录设备的特性以及与设备控制器的连接情况，其中有字段“设备状态”用来表示设备是忙还是闲，“COCT指针”指向与该设备相连接的设备控制器。</p>
<ul>
<li>当计算机系统没有用户执行时，处理机完全处于空闲状态。[<strong><em>错</em></strong>]</li>
</ul>
<blockquote>
<p><strong>系统本身也会有很多状态要维护，会一直处于监听状态。</strong></p>
</blockquote>
<p>​                            </p>
<ul>
<li><p>下列关于总线的说法中正确的是(  )</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image22.png" class>



</li>
</ul>
<ul>
<li><p>A：总线是用于连接CPU、内存、外存和各种I/O设备并在它们之间传输信息的一组共享的传输线及其控制电路。如果不特别指出，总线一般指代内总线。<br>B：内部总线位于CPU内部，连接各个寄存器和运算器。<br>C：I/O总线是用于连接主机和I/O设备的总线。<br>D：计算机总线中包含内部总线、系统总线（前端总线）、I/O总线。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image23.png" class>





</li>
</ul>
<ul>
<li><p>一个进程执行过程中不可能对应()。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image24.png" class>

</li>
</ul>
<blockquote>
<p>PCB:  Process Control Block 进程控制块</p>
<p>了描述控制进程的运行，系统中存放进程的管理和控制信息的数据结构称为<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97/7205297">进程控制块</a>（PCB Process Control Block），它是进程实体的一部分，是操作系统中最重要的记录性数据结构。它是进程管理和控制的最重要的数据结构，每一个进程均有一个PCB，在创建进程时，建立PCB，伴随进程运行的全过程，直到进程撤消而撤消。</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image25.png" class>

<p><strong>进程（Process）和作业（Job）是一个意思，不同书中表述不同，JCB就相当于是PCB。一个进程一个PCB，所以不会对应到多个PCB</strong></p>
<ul>
<li>进程申请不到CPU 时，其状态将变为阻塞状态，这样的说法正确吗 【**<em>错误**</em>】</li>
</ul>
<p>也可能是就绪，其他都准备好了，只差CPU</p>
<ul>
<li><p>“进程一次性申请全部所需资源”通过防止( )条件的出现实现死锁预防</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image26.png" class>

</li>
</ul>
<p><img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/Users\flower\AppData\Roaming\Typora\typora-user-images\image-20220217164051506.png" alt="image-20220217164051506"></p>
<ul>
<li><p>在分时系统中，若当前运行的进程连续获得了两个时间片，原因可能是（ ）</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image27.png" class>

</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">就绪队列为空 </span><br><span class="line">无其他进程需要使用CUP,所以连续分配时间片</span><br></pre></td></tr></table></figure>


<ul>
<li><p>在 段页式存储管理中 ，每个进程拥有多个段表，但只有一张页表。[<strong><em>错误</em></strong>]</p>
</li>
<li><p>需要周期刷新的存储器是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image28.png" class>

<p>考察的是不同<strong>存储器</strong>的功能特点。</p>
<ul>
<li>A选项为<strong>静态随机存取存储器</strong>（Static Random-Access Memory，SRAM）是随机存取存储器的一种。是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。</li>
<li>B选项为<strong>动态随机存取存储器</strong>(Dynamic Random Access Memory，DRAM)最为常见的系统内存。<strong>DRAM的存储位元是基于电容器的电荷量存储，这个电荷量会随着时间和温度而减少，因此必须定期的刷新，以保持它们原来记忆的正确信息。对DRAM的所有存储单元恢复一次原状态的时间间隔，叫做刷新周期。</strong></li>
<li>C选项<strong>只读存储器</strong>(Read-Only Memory，ROM)所存数据稳定 ，断电后所存数据也不会改变；其结构较简单，读出较方便，因而常用于存储各种固定程序和数据。</li>
<li>D选项属于<strong>静态存储器的原理</strong>，即靠双稳态触发器的两个稳定状态保存信息</li>
</ul>
</li>
</ul>
<ul>
<li><p>实现虚拟存储的目的是（）</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image29.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image30.png" class>



</li>
</ul>
<ul>
<li>解决死锁问题通常意味着牺牲资源的效率   【**<em>正确**</em>】</li>
</ul>
<blockquote>
<p>解决死锁通常是释放部分进程资源，故牺牲了资源的效率</p>
</blockquote>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">破坏死锁的方法包括： 1. 破坏互斥条件，如果系统资源都能共享，则不会死锁--但由于打印机等资源显然不能被共享，该方法不好。 2. 破坏请求并保持条件，预先分配全部资源，运行时才投入使用，并一直独享，系统资源被浪费。 3. 破坏不可剥夺条件，保持不可剥夺资源的进程，在请求新资源未被满足时，必须先释放保持的资源，需要时重新申请，反复申请和释放增加了开销。 4. 破坏循环等待条件，采用顺序资源分配，用编号分配资源，按次序操作会造成浪费。</span><br></pre></td></tr></table></figure>


<ul>
<li><p>存放在磁盘上的文件</p>
<blockquote>
<p>即可随机访问，又可顺序访问</p>
</blockquote>
</li>
</ul>
<ul>
<li><p>位示图可用于()</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image31.png" class>

</li>
</ul>
<p>操作系统管理空闲存储空间的方法：位示图法【**<em>0表示空闲，1表示已经分配**</em>】、空闲区表法、空闲链表法以及成组链接法</p>
<ul>
<li><p>在 Word 中，执行打开文件 C:\a.doc 操作，是将 <strong><strong>____</strong></strong></p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image32.png" class>

</li>
</ul>
<blockquote>
<p>C盘是硬盘，A盘和B盘都是软盘；我们现在说的内存一般都是RAM，而ROM也可以做内存，只不过是Read Only的(只能写一次)，通常用来存储BIOS程序，断电后内容还在。</p>
</blockquote>
<ul>
<li><p>单道程序系统中程序的执行也需要同步和互斥 【**<em>错**</em>】</p>
<ul>
<li><p>详细解释</p>
<ul>
<li><p><strong>1. 资源独占性</strong></p>
<p>任何时候，位于内存中的程序可以使用系统中的一切资源，不可能有其他程序与之竞争</p>
<p><strong>2. 执行的顺序性</strong></p>
<p>内存中只有一个程序，各个程序是按次序执行的。在做完一个程序的过程中，不可能夹杂进另一个程序执行</p>
<p> <strong>3. 结果的可再现性</strong></p>
<p>只要执行环境和初始条件相同，重复执行一个程序，获得的结果总是一样的</p>
<p> <strong>4. 运行结果的无关性</strong></p>
<p>程序的运行结果与程序执行的速度无关。系统中的作业以串行的方式被处理，无法提高CPU、内存的利用率</p>
<p>本来就是有序的，故不需要同步互斥</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>目录在linux文件系统中是以怎样的形式存在的？</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image33.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image34.png" class>







</li>
</ul>
<ul>
<li><p>使用下面那些存储管理方法可以实现虚拟存储？【**<em>BCD**</em>】</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image35.png" class>

</li>
</ul>
<blockquote>
<p>虚拟存储器的实现方法：<br>1、分页请求系统<br>2、分段请求系统<br>3、两种方式的结合</p>
</blockquote>
<p>而分区分配是指为如何用户程序分配内存空间的策略</p>
<p>分区是为用户程序<strong>分配内存</strong>的策略，不是<strong>虚拟存储</strong>的实现方法。</p>
<ul>
<li><p>假设某系统共有10台磁带机，有三个进程P1，P2，P3对磁带机的需求量分别是8，6，4台。设在T0时刻P1，P2，P3已分别获得3，4，1台，于是在T0时刻后存在的安全序列为（ **?**）。</p>
</li>
<li><p>```<br>（P1，P2，P3）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  （P3，P2，P1）</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>（P2，P3，P1）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;</span><br><span class="line">  （P2，P1，P3）</span><br></pre></td></tr></table></figure></li>
<li><pre><code>（P1，P3，P2）
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 关于进程和线程，下列说法正确的是____</span><br><span class="line"></span><br><span class="line"> &#123;%asset_image image36.png%&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;txt</span><br><span class="line">A：进程是资源分配和拥有的单位</span><br><span class="line">C：线程是处理机调度和分配的单位</span><br><span class="line">B：进程之间可以并发执行，同一个进程的多个线程之间也可并发执行</span><br><span class="line">E：每个线程拥有自己的堆栈，和自己的寄存器上下文</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<ul>
<li>两个线程并发执行以下代码，假设a是全局变量，初始值是1，那么以下输出中（）是可能的。</li>
</ul>
<blockquote>
<p>void<code> </code>foo ( )<br>{<br><code>++a; </code>printf<code>(</code>“%d”``,a);<br>}</p>
</blockquote>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image37.png" class>

<blockquote>
<p>假设线程x和y同时执行，x和y可随时被抢占，a的初始值为1</p>
<p>A：3, 2<br>y先执行++a，a为2;<br>y再执行printf，a入栈，在打印到终端之前切换到x<br>x执行＋＋a，a为3;<br>x执行printf，输出3;再切换到y<br>y执行打印，输出2</p>
<p>B：2 3<br>x先执行＋＋a，a为2;<br>x再执行printf，输出2;切换到y<br>y执行＋＋a，a为3;<br>y执行printf，输出3;</p>
<p>C：3 3<br>x先执行＋＋a，a为2;切换到y<br>y执行＋＋a，a为3;<br>y执行printf，输出3;切换到x<br>x执行printf，输出3</p>
<p>D：2 2<br>类似C， 执行++a操作但没有写回到内存</p>
<p>这里关键有两点：<br>（1)两个线程可*<strong>随时被抢占***<br>（2)＋＋a和printf<strong>不是原子指令</strong>，可随时被打断；特别注意函数printf，a作为参数压栈后，*</strong>a再变化则不会影响输出*<strong>（printf实际打印的是压栈的参数，是值**<em>拷贝</em></strong>的栈变量）</p>
</blockquote>
<ul>
<li><p>以下关于Linux操作系统内存的描述中，正确的有（)</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image38.png" class>

<ul>
<li><p>A.<a href="%E8%8B%A5%E4%B8%80%E5%8F%B0%E6%9C%BA%E5%99%A8%E7%9A%84%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%BA2GB%EF%BC%8C%E5%88%99%E5%9C%A8%E8%AF%A5%E6%9C%BA%E5%99%A8%E4%B8%8A%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%9B%E7%A8%8BA%E5%92%8C%E8%BF%9B%E7%A8%8BB%E6%89%80%E5%8D%A0%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B9%8B%E5%92%8C%E6%9C%89%E5%8F%AF%E8%83%BD%E5%A4%A7%E4%BA%8E2GB">点击访问</a>   32位下windows大概2g，而Linux3G，其余的都是给了内核【**<em>注意题中说是用户态地址空间**</em>】</p>
</li>
<li><p>B. [ <strong><em>?</em></strong> ]</p>
<blockquote>
<p>进程A和B都有自己的虚拟地址，程序在运行的时候在一个特定的时候并不会把所有需要的数据都加载到内存中，当前不使用的数据会被置换到硬盘上，只有在使用的时候才会被置换到内存中。因此，两个进程所占的物理存储之和完全有可能大于2GB。例如当进程A和B同时运行的时候，都只有部分数据被加载到内存中，假设在某一时刻A和B进程占用内存之和为2GB，如果此时A所需的数据不在内存中，此时系统采用特定的算法把进程A与B当前可能不使用的数据置换到硬盘上。因此，选项B正确。</p>
</blockquote>
</li>
<li><p>申请了1GB的内存，不一定会全部占用</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>下列软件中，属于系统软件的是（）。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image39.png" class>

</li>
</ul>
<blockquote>
<p>软件系统主要包括系统软件和应用软件。办公自动化软件、管理信息系统、指挥信息系统都是属于应用软件， Windows XP 属于系统软件，因此答案选择 B 。</p>
</blockquote>
<ul>
<li><p>进程A、B共享变量x，需要互斥执行；进程B、C共享变量y，B、C也需要互斥执行，因此进程A、C必须互斥执行    【错】</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在操作系统中，互斥没有传递性。在题目中，AC不存在资源竞争，以为着不需要互斥</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>( ) 被称为文本文件或 ACSII 文件。</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image40.png" class>

</li>
</ul>
<blockquote>
<p>exe 可执行文件  软件一般有这样的应用程序</p>
<p>txt  文本文件 </p>
<p>doc  word 文本格式</p>
<p>com  可执行文件的内存映像</p>
</blockquote>
<ul>
<li><p>从执行状态挂起的进程解除挂起时进入()状态。</p>
<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image41.png" class>

<img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image42.png" class>



</li>
</ul>
<ul>
<li><p>采用动态重定位方式装入作业，在执行中允许（）将其移走</p>
 <img data-src="/2022/02/17/%E7%89%9B%E5%AE%A2%E7%BD%91%E5%88%B7%E9%A2%98-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/image43.png" class>

</li>
</ul>
<blockquote>
<p><strong>动态重定位装入方式</strong>：</p>
<p>其运行环境：多道程序环境；</p>
<p>程序在运行过程中在内存的位置可能变动，装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正执行时才进行。说白了，动态重定位装入方式，是在程序执行时由CPU硬件进行地址重定位。</p>
<p>特点：程序在内存中可以浮动，不要求整个应用程序占用连续控件；为使地址转换不影响指令的执行速度，需要一个重定位寄存器的支持。</p>
<p>动态重定位分区分配是 内存为程序分配空间的一种分配方式。 可以将内存块进行搬移，将小块拼成大块，将小空闲“紧凑”成大空闲，腾出较大的内存以容纳新的程序进程。可以减少“碎片”，当然这种条件是**<em>系统完成的，并不是用户**</em>。</p>
</blockquote>
<blockquote>
<p><strong>可重定位装入方式</strong>：</p>
<p>运行环境：多道程序环境</p>
<p>程序目标模块的起始地址通常是从0开始的，程序中的其他地址也都是相对于起始地址计算的；根据内存的当前情况，将装入模块装入到内幕才能的适当位子；地址变换通常是装入时一次完成的，以后不再改变，所以是静态重定位。</p>
<p>特点：无需硬件支持；程序不能在内存中移动；要求程序的存储空间是连续的，不能把程序放在若干不连续区域</p>
<p><strong>绝对装入方式</strong>：</p>
<p>环境：使用单批道程序环境</p>
<p>绝对装入需要实现知道程序驻留在内存的位置，程序按照装入模块中的地址，将程序和数据装入内存。所以程序中的逻辑地址与实际地址完全相同，当操作系统把程序装入内存时，不需要对程序和数据进行地址修改；</p>
<p>特点：是CPU执行目标代码块，由于内存大小的限制，能装入内存并发执行的进程数大大减少。</p>
</blockquote>
<ul>
<li>在请求式分页系统中，缺页的中断率与程序结构无关。最短 CPU 执行期优先算法一定是剥夺式的。 【 <strong><em>false</em></strong> 】</li>
</ul>
<blockquote>
<p>第一个问题：false</p>
<p><strong>请求式分页</strong>也称虚拟页式存储管理，在进程开始运行之前不是装入全部页面，而是装入一个或零个页面之后根据进程运行的需要动态装入其他页面。</p>
<p>查页表时，当状态位指示该页不在主存时，则引起一个<strong>缺页中断</strong>发生，相应的中断程序把控制转向缺页中断子程序。————–<strong><em>缺页的中断率与程序结构有关</em></strong></p>
<h4 id="缺页中断率的因素有："><a href="#缺页中断率的因素有：" class="headerlink" title="缺页中断率的因素有："></a><strong>缺页中断率的因素有</strong>：</h4><p>①分配给作业的主存块数多则缺页率低，反之缺页中断率就高。<br>②页面大，缺页中断率低；页面小缺页中断率高。<br>③程序编制方法。以数组运算为例，如果每一行元素存放在一页中，则按行处理各元素缺页中断率低；反之，按列处理各元素，则缺页中断率高。<br>④页面调度算法对缺页中断率影响很大，但不可能找到一种最佳算法。</p>
<h4 id="第二个问题：false"><a href="#第二个问题：false" class="headerlink" title="第二个问题：false"></a><strong>第二个问题：false</strong></h4><h3 id="短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式"><a href="#短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式" class="headerlink" title="短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式"></a>短作业优先（SJF）–即最短CPU执行期优先算法有两种调度方式</h3><ul>
<li><strong>非抢占式（非剥夺式）调度</strong>：一旦进程拥有了CPU，只有当该CPU脉冲时间结束才会让出CPU的控制权。</li>
<li><strong>抢占式（剥夺式）调度</strong>：当有比当前进程剩余时间片更短的进程到来时，新来的进程抢占当前进程获得CPU运行。这种方式也被称为最短剩余时间优先调度（SRTF）。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度</title>
    <url>/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="Linux进程调度"><a href="#Linux进程调度" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h1> <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image01.png" class>



<p>调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。进程调度程序(常常简称调度程序)可看做在可运行态进程之间分配有限的**<em>处理器时间资源的内核子系统**</em>。调度程序是像Linux这样的多任务操作系统的基础。只有通过调度程序的合理调度，系统资源才能最大限度地发挥作用，多进程才会有并发执行的效果。 </p>
<blockquote>
<p>在一组处于可运行状态的进程中选择一个来执行，是调度程序所需完成的基本工作,最大程度的利用处理器时间为原则。</p>
</blockquote>
<h2 id="多任务操作系统"><a href="#多任务操作系统" class="headerlink" title="多任务操作系统"></a>多任务操作系统</h2><p>多任务操作系统就是能同时并发地交互执行多个进程的操作系统。在单处理器机器上，这会产生多个进程在同时运行的幻觉。在多处理器机器上，这会使多个进程在不同的处理机上真正同时、并行地运行。无论在单处理器或者多处理器机器上，多任务操作系统都能使多个进程处堵塞或者睡眠状态，</p>
<p>多任务系统可以划分为两类：</p>
<blockquote>
<p>非抢占式多任务(cooperative multitasking)</p>
</blockquote>
<p>在非抢占式多任务模式下，除非进程自己主动停止运行，否则它会一直执行。进程主动挂起自己的操作称为让步(yielding)。理想情况下，进程通常做出让步，以便让每个可运行进程享有足够的处理器时间。但这种机制有很多缺点：调度程序无法对每个进程该执行多长时间做出统一规定，所以进程独占的处理器时间可能超出用户的预料；更糟的是，一个决不做出让步的悬挂进程就能使系统崩溃。</p>
<blockquote>
<p>抢占式多任务(preemptive multitasking)</p>
</blockquote>
<p>由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到执行机会。这个*<strong>强制的挂起动作就叫做抢占(preemption)**<em>。进程在被抢占之前能够运行的时间是预先设置好的，而且有一个专门的名字，叫</em></strong>进程的时间片(timeslice)***。时间片实际上是分配给每个可运行进程的处理器时间段。有效管理时间片能使调度程序从系统全局的角度做出调度决定，这样做还可以避免个别进程独占系统资源</p>
<h2 id="Linux进程调度-1"><a href="#Linux进程调度-1" class="headerlink" title="Linux进程调度"></a>Linux进程调度</h2><p>开始采用了一种叫做<strong>O(1)*<em>调度程序的新调度程序一一它是因为其算法的行为而得名，0(1)调度程序虽然对于大服务器的工作负载很理想，但是在有很多交互程序要运行的桌面系统上则表现不佳，因为**</em>其缺少交互进程*</strong></p>
<p>自2.6内核系统开发初期，开发人员为了提高对交 互程序的调度性能引入了新的进程调度算法。其中最为著名的是“**<em>反转楼梯最后期限调度算法(Rotating Staircase Deadline scheduler(RSDL)**</em>,该算法吸取了队列理论，将公平调度的概念引入了 Linux调度程序。并且最终在2623内核版本中替代了 0(1)调度算法，它此刻被称为“完全公平调度算法”，或者简称<strong>CFS</strong></p>
<h2 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h2><h3 id="根据进程分类确定策略"><a href="#根据进程分类确定策略" class="headerlink" title="根据进程分类确定策略"></a>根据进程分类确定策略</h3><blockquote>
<p>进程可以被分为I/O消耗型和处理器消耗型。</p>
</blockquote>
<ul>
<li><p>IO消耗型</p>
<p>指进程的<strong>大部分时间用来提交I/O请求或是等待I/O请求</strong>。因此，这样的进程经常处于可运行状态，但通常都是**<em>运行短短的一会儿**</em>，因为它在等待更多的I/O请求时总会阻塞</p>
<p>举例来说，多数用户图形界面程序（GUI）都属于I/O密集型，即便它们从不读取或者写入磁盘，它们也会在多数时间里都在等待来自鼠标或者键盘的用户交互操作。</p>
<img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image02.png" class>



</li>
</ul>
<ul>
<li><p>处理器耗费型(用于计算)</p>
<p>处理器耗费型进程把时间大多用在执行代码上。除非被抢占，否则它们通常都一直不停地运行，因为它们没有太多的I/O需求。但是，因为它们不属于I/O驱动类型，所以从系统响应速度考虑，调度器不应该经常让它们运行。对于这类处理器消耗型的进程，调度策略往往是**<em>尽量降低它们的调度频率，而延长其运行时间**</em>。</p>
<img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image03.png" class>

</li>
</ul>
<p>有必要指出，随着CPU变得越来越快*<strong>，更多的进程倾向为I/O密集型**<em>。这种现象之所以发生是因为</em></strong>CPU 的改进比磁盘的改进快得多***，其结果是，未来对I/O密集型进程的调度处理似乎更为重要。这里的基本思想 是，如果需要运行I/O密集型进程，那么就应该让它尽快得到机会，以便发出磁盘请求并保持磁盘始终忙 碌。从图中可以看到，如果进程是I/O密集型的，则需要多运行一些这类进程以保持CPU的充分利用。</p>
<blockquote>
<p>调度策略通常要在两个矛盾的目标中间寻找平衡：进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）。</p>
</blockquote>
<p><strong><em>Linux为了保证交互式应用和桌面系统的性能，所以对进程的响应做了优化（缩短响应时间），更倾向于优先调度I/O消耗型进程</em></strong></p>
<h3 id="根据进程优先级确定调度策略"><a href="#根据进程优先级确定调度策略" class="headerlink" title="根据进程优先级确定调度策略"></a>根据进程优先级确定调度策略</h3><p>调度算法中最基本的一类就是基于优先级的调度。这是一种根据进程的价值和其对处理器时</p>
<p>间的需求来对进程分级的想法。</p>
<p>通常做法是（其并未被Linux系统完全采用）优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式进行调度（一个接一个，重复进行）。</p>
<p>Linux采用了两种不同的优先级范围:</p>
<blockquote>
<p>nice值</p>
<p>它的范围是从-20到+19, 默 认值为0 ；越大的nice值意味着更低的优先级;</p>
<p>在Mac OS X, 进程的nice值 代表分配给进程的时间片的绝对值；而Linux系统中，nice值则代表时间片的比例。你可以通过ps-el命令査看系统中的进程列表，结果中标记N1的一列就是进程对应的nice值。 </p>
</blockquote>
<blockquote>
<p>实时优先级</p>
<p>默认情况下它的变化范围是从0到99 （包括0和99）。与nice值意义相反，越高的实时优先级数值意味着进程优先级越高。</p>
<p>实时优先级和nice优先级处于互不相交的两个范畴</p>
</blockquote>
<h3 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h3><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。*<strong>调度策略必须规定一*** *</strong>个默认的时间片***</p>
<blockquote>
<p>时间片太长</p>
</blockquote>
<p>时间片过长会导致系统对交互的响应表现欠佳，让人觉得系统无法并发执行应用程序</p>
<blockquote>
<p>时间片太短</p>
</blockquote>
<p>会明显增大进程切换带来的处理器耗时，因 为肯定会有相当一部分系统时间用在进程切换上，而这些进程能够用来运行的时间片却很短。</p>
<p>i/o消耗型和处理器消耗型的进程之间的矛盾在这里也再次显露出来：I/O消耗型不需要长的时间片，而处理器消耗型的进程则希望越长越好</p>
<p><strong><em>Linux的CFS调度器并没有直接分配时间片到进程，它是将处理器的使用比划分给了进程。</em></strong></p>
<p>进程所获得的处理器时间其实是和系统负载密切相关的。这个比例进一步还会受进程nice值的影响</p>
<p><strong>Linux系统是抢占式的</strong>,其抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢 占当前进程。否则，将推迟其运行。</p>
<h3 id="案例：文本编辑器（IO）VS视频编码器（处理）"><a href="#案例：文本编辑器（IO）VS视频编码器（处理）" class="headerlink" title="案例：文本编辑器（IO）VS视频编码器（处理）"></a>案例：文本编辑器（IO）VS视频编码器（处理）</h3><p>对于视频编码器。它对什么时间开始运行没有太严格的要求 用户几乎分辨不出也并不关心它到底是立刻就运行还是半秒钟以后才开始的。当然，它完成得越早越好，至于所花时间并不是我们关注的主要问题。 </p>
 <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image04.png" class>

<p>​    </p>
<h2 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h2><p>Linux调度器是以**<em>模块方式提供**</em>的，这样做的目的是允许不同类型的进程可以有针对性地选择调度算法。 </p>
<p>这种模块化结构被称为<strong>调度器类</strong>（scheduler classes）,它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级，基础的调度器代码定义kemel/schedx文件中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那一个程序。 </p>
<p>完全公平调度（CFS）是一个**<em>针对普通进程的调度类**</em>，在Linux中称为SCHED_NORMAL（在POSIX中称为SCHED_OTHER） , CFS算法实现定义在文件kemel/sched_fair.c中</p>
<h3 id="Unix系统中的进程调度–CFS公平调度"><a href="#Unix系统中的进程调度–CFS公平调度" class="headerlink" title="Unix系统中的进程调度–CFS公平调度"></a>Unix系统中的进程调度–CFS公平调度</h3><p>CFS的做法是允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了，CFS在所有可运行进程总数基础上计算出一个进程应该运行多久，而不是依靠nice值来计算时间片</p>
<p>任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值的相对差值决定的。nice值对时间片的作用<strong>不再是算数加权，而是几何加权</strong>。任何nice值对应的绝对时间不再是一个绝对值，而是<strong>处理器的使用比</strong>。CFS称为公平调度器是因为它确保给每个进程公平 的处理器使用比。正如我们知道的，CFS不是完美的公平，它只是近乎完美的多任务。但是它确实在多进程环境下，降低了调度延迟带来的不公平性。</p>
<blockquote>
<p>目标延迟</p>
</blockquote>
<p>CFS为完美多任务中的无限小调度周期的近似值设立了一个目标。越小的调度周期将带来越好的交互性，同时也更接近完美的多任务。但是你必须承受更高的切换代价和更差的系统总吞吐能力。</p>
<blockquote>
<p>最小粒度</p>
</blockquote>
<p>CFS为此引入每个进程获得的时间片底线， 这个底线称为最小粒度。默认情况下这个值是1ms。如此一来，即便是可运行进程数量趋于无穷，每个最少也能获得1ms的运行时间，确保切换消耗被限制在一定范围内（避免为了降低延迟不断的无限小调度周期，从而增加了进程切换的消耗）</p>
<h2 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h2><h3 id="时间记账"><a href="#时间记账" class="headerlink" title="时间记账"></a>时间记账</h3><p>所有的调度器都必须对进程运行时间做记账。多数Unix系统，正如我们前面所说，分配一个时间片给每一个进程。那么当每次系统时钟节拍发生时，时间片都会被减少一个节拍周期。当一个进程的时间片被减少到0时，它就会被另一个尚未减到0的时间片可运行进程抢占。</p>
<h3 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h3><p>当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。这其实就是CFS调度算法的核心：选择具有最小vruntime的任务。【**<em>最完美的调度：所有可运行进程的vruntime值将一致**</em>】</p>
<p>CFS使用**<u>红黑树</u>**来组织可运行进程队列，并利用其迅速找到最小vruntime值的进程。</p>
<h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h3><p>进程调度的主要入口点是函数schedule(),它定义在文件kemel/sched.c中。Schedule()通常都需要和一个具体的调度类相关联，也就是说，它会找到一个最高优先级的调度类睡眠和唤醒。</p>
<p><strong><em>pick_next_task()</em></strong>会以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选取最高优先级的进程。</p>
<h3 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h3><p><strong>休眠</strong>(被阻塞)的进程处于一个特殊的不可执行状态。这点非常重要，如果没有这种特殊状态的话，调度程序就可能选出一个本不愿意被执行的进程。</p>
<blockquote>
<p>休眠的操作</p>
</blockquote>
<p>内核的操作都相同：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule。选择和执行一个其他进程。</p>
<p>休眠有两种相关的进程状态：**<em>TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE**</em>.它们的唯_区别是处于TASK_UNINTERRUPTIBLE的进程会忽略信号，而处于TASK_INTERRUPTIBLE状态的进程如果接收到一个信号，会被提前唤醒并响应该信号。 两种状态的进程位于同一个等待队列上，等待某些事件，不能够运行。</p>
<blockquote>
<p>唤醒的操作</p>
</blockquote>
<p>唤醒操作通过函数wake_up()进行，它会唤醒指定的等待队列上的所有进程。它调用函数try_to_wake_up(),该函数负责将进程设置为TASK_RUNNING状态，调用enqueue_task()将此进程放入红黑树中，如果被唤醒的进程优先级比当前正在执行的进程的优先级高，还要设置need_resched标志</p>
<h2 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h2><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>上下文切换，也就是从一个可执行进程切换到另一个可执行进程，由定义在kemel/sched.c中的context_switch()函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用该函数。它完成了两项基本的工作： </p>
<ul>
<li><p>调用声明在&lt;asm/mmu_context.h&gt;中的switch_mm(),该函数负责把虚拟内存从上一个进程映射切换到新进程中。</p>
</li>
<li><p>调用声明在＜asm/system.h＞中的switch_to(),该函数负责从上一个进程的处理器状态切换 </p>
<p>到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结’ </p>
<p>构相关的状态信息，都必须以每个进程为对象进行管理和保存。</p>
</li>
</ul>
<h3 id="抢占"><a href="#抢占" class="headerlink" title="抢占"></a>抢占</h3><p>内核提供了一个**<em>need_resched**</em>标志来表明是否需要重新执行一次调度。</p>
<h4 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h4><ul>
<li> 从系统调返回用户空间时。 </li>
<li>从中断处理程序返回用户空间时。</li>
</ul>
<h4 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h4><ul>
<li>中断处理程序正在执行，且返回内核空间之前。</li>
<li>内核代码再一次具有可抢占性的时候。 </li>
<li>如果内核中的任务显式地调用schedule。</li>
<li>如果内核中的任务阻塞(这同样也会导致调用schedule())</li>
</ul>
<h1 id="调度【现代操作系统中根据不同操作系统总结】"><a href="#调度【现代操作系统中根据不同操作系统总结】" class="headerlink" title="调度【现代操作系统中根据不同操作系统总结】"></a>调度【现代操作系统中根据不同操作系统总结】</h1><h2 id="何时调度"><a href="#何时调度" class="headerlink" title="何时调度"></a>何时调度</h2><blockquote>
<p>在创建一个新进程之后，需要决定是运行父进程还是运行子进程。</p>
</blockquote>
<p>由于这两种进程都处于就绪状态，所以这是一种正常的调度决策，可以任意决定，也就是说，调度程序可以合法选择先运行父进程还是先运行子进程。 </p>
<blockquote>
<p>在一个进程退出时必须做出调度决策。</p>
</blockquote>
<p>一个进程不再运行（因为它不再存在），所以必须从就绪进程集中选择另外某个进程。如果没有就绪的进程，通常会运行一个系统提供的空闲进程。</p>
<blockquote>
<p>当一个进程阻塞在I/O和信号量上或由于其他原因阻塞时，必须选择另一个进程运行。</p>
</blockquote>
<p>有时，阻塞的原因会成为选择的因素。例如，如果A是一个重要的进程，并正在等待B退出临界区，让B随后运行将会使得B退出临界区，从而可以让A运行。不过问题是，通常调度程序并不拥有做出这种相关考虑的必要信息。</p>
<blockquote>
<p>在一个I/O中断发生时，必须做出调度决策。</p>
</blockquote>
<p>如果中断来自I/O设备，而该设备现在完成了工作，某些被阻塞的等待该I/O的进程就成为可运行的就绪进程了。是否让新就绪的进程运行，这取决于调度程序的决定，或者让中断发生时运行的进程继续运行，或者应该让某个其他进程运行。</p>
<p><strong><em>根据如何处理时钟中断，可以把调度算法分为两类。</em></strong></p>
<ul>
<li><p>非抢占式调度算法</p>
<p>非抢占式调度算法挑选一个进程，然后让该进程运行直至被阻塞（阻塞在I/O上或等待另一个进程），或者直到该进程自动释放CPU。即使该进程运行了若干个小时，它也不会被强迫挂起。这样做的结果是，在时钟中断发生时不会进行调度。在处理完时钟中断后，如果没有更高优先级的进程等待到时，则被中断的进程会继续执行。 </p>
</li>
<li><p>抢占式调度算法</p>
<p>抢占式调度算法挑选一个进程，并且让该进程运行某个固定时段的最大值。如果在该时段结束时，该进程仍在运行，它就被挂起，而调度程序挑选另一个进程运行（如果存在一个就绪进程）。进行抢占式调度处理，需要在时间间隔的末端发生时钟中断，以便把CPU控制返回给调度程序。如果没有可用的时钟，那么非抢占式调度就是惟一的选择了。</p>
</li>
</ul>
<h3 id="调度算法分类"><a href="#调度算法分类" class="headerlink" title="调度算法分类"></a>调度算法分类</h3><p>不同的环境需要不同的调度算法，在不同的系统中，调度程序的优化是不同的。</p>
<ul>
<li><p>批处理 </p>
<blockquote>
<p>批处理系统在商业领域仍在广泛应用，用来处理薪水册、存货清单、账目收入、账目支出、利息计算 （在银行）、索赔处理（在保险公司）和其他的周期性的作业。在批处理系统中，不会有用户不耐烦地在终端旁等待一个短请求的快捷响应。因此，*<strong>非抢占式算法**<em>，或对每个进程</em></strong>都有长时间周期的抢占式算法***，通常都是可接受的。这种处理方式减少了进程的切换从而改善了性能。这些批处理算法实际上相当普及，并经常可以应用在其他场合。</p>
</blockquote>
</li>
<li><p>交互式</p>
</li>
</ul>
<p>为了避免一个进程霸占CPU拒绝为其他进程服务，抢占是必需的。即便没有进程想永远运行，但是，某个进程由于一个程序错误也可能无限期地排斥所有其他进程。为了避免这种现象发生，抢占也是必要的。服务器也归于此类，因为通常它们要服务多个突发的（远程）用户。 </p>
<ul>
<li>实时</li>
</ul>
<p>有实时限制的系统中，抢占有时是不需要的，因为进程了解它们可能会长时间得不到运行，所以 通常很快地完成各自的工作并阻塞。实时系统与交互式系统的差别是，实时系统只运行那些用来推进现有应用的程序，而交互式系统是通用的，它可以运行任意的非协作甚至是有恶意的程序。 </p>
 <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image05.png" class>

<blockquote>
<p>在所有的情形中，公平是很重要的。相似的进程应该得到相似的服务。</p>
</blockquote>
<blockquote>
<p>保持系统的所有部分尽可能忙碌。【CPU针对于CPU密集作业和磁盘针对于IO密集作业的组合，保证CPU和磁盘是尽可能忙碌，减少空转】</p>
</blockquote>
<h3 id="批处理系统中的调度"><a href="#批处理系统中的调度" class="headerlink" title="批处理系统中的调度"></a>批处理系统中的调度</h3><h4 id="先来先服务（first-come-first-served）"><a href="#先来先服务（first-come-first-served）" class="headerlink" title="先来先服务（first-come first-served）"></a>先来先服务（first-come first-served）</h4><p>使用该算法，进程按照它们请求CPU的顺序使用CPU。【**<em>非抢占式**</em>】</p>
<h5 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h5><blockquote>
<p>有一个就绪进程的单一队列。早上，当第一个作业从外部进入系统，就立即开始并允许运行它所期望的时间。不会中断该作业，因为它需要很长的时间运行。当其他作业进入时，它们就被安排到队列的尾部。当正在运行的进程被阻塞时，队列中的第一个进程就接着运行。在 <strong>被阻塞的进程变为就绪时，就像一个新来到的作业一样，排到队列的末尾。</strong> </p>
</blockquote>
<h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul>
<li>主要优点是易于理解并且便于在程序中运用</li>
<li>在计算密集型和IO密集型应用的组合上容易出现问题。</li>
</ul>
<p>IO密集型应用在运行期间，多半时间花费在磁盘读写操作上，且时间比较长，影响了计算密集型应用对于CPU的占有使用。</p>
<h5 id="最短作业优先"><a href="#最短作业优先" class="headerlink" title="最短作业优先"></a>最短作业优先</h5><p>适用于运行时间可以预知的另一个**<em>非抢占式**</em>的批处理调度算法</p>
<p>当输入队列中有**<em>若干个同等重要的作业**</em>被启动时，调度程序应使用最短作业优先（shortest job first）算法</p>
 <img data-src="/2022/02/22/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/image06.png" class>

<p><strong>a)</strong>   有4个作业A、B、C、D，运行时间分别为8、4、4、4分钟。若按图中的次序运行，则A的周转时间为8分钟，B为12分钟，C为16分钟，D为20分钟，平均为14分钟。</p>
<p><strong>b）</strong>目前周转时间分别为4、8、12和20分钟，平均为11分钟。可以证明最短作业是最优的。</p>
<blockquote>
<p><strong>为什么最短作业最优</strong>的推导</p>
</blockquote>
<p>考虑有4个作业的情况，其运行时间分别为a、b、c、d。第一个作业在时间a结束，第二个在时间a+b结束，以此类推。平均周转时间为（4a+3b+2c+d）/4。显然a对平均值影响最大，所以它应是最短作业，其次是b，再次是c，最后的d只影响它自己的周转时间</p>
<p><strong><em>只有在所有的作业都可同时运行的情形下，最短作业优先算法才是最优化的</em></strong>，不然，运行时间成本里还需要考虑对相关作业的等待时间。</p>
<h5 id="最短剩余时间优先"><a href="#最短剩余时间优先" class="headerlink" title="最短剩余时间优先"></a>最短剩余时间优先</h5><p>最短作业优先的*<strong>抢占式版本**<em>是最短剩余时间优先（shortest remaining time next）算法。使用这个算法， 调度程序总是选择剩余运行时间最短的那个进程运行。再次提醒，有关的运行时间必须提前掌握。当一个新的作业到达时，其整个时间同当前进程的剩余时间做比较。如果新的进程比当前运行进程需要更少的时间，</em></strong>当前进程就被挂起，而运行新的进程***【抢占】。这种方式可以使新的短作业获得良好的服务</p>
]]></content>
      <categories>
        <category>Linux系统内核相关</category>
      </categories>
      <tags>
        <tag>进程</tag>
      </tags>
  </entry>
</search>
